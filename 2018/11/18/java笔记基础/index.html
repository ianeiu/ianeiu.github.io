<!DOCTYPE html>
<html lang="zh" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta name="generator" content="Hugo 0.46" />
  <meta charset="utf-8">
  <title>Java笔记——基础 · IanEiU</title>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java基础笔记整理 关键字 用于定义数据类型 class interface 【引用数据类型：类、接口、数组】 boolean(1) char(2) byte(1) short(2) int(4) long(8) float(4) double(8) 【8个内置数据类型】 类型转换： byte→sho" />

  <meta name="keywords" content="Hugo, theme, ianeiu, 吴炜棉" />
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
<link rel="stylesheet" href="https://ianeiu.github.io/css/den.css">

<link rel="stylesheet" href="https://ianeiu.github.io/css/custom.css">




<meta property="og:title" content="Java笔记——基础" />
<meta property="og:description" content="Java基础笔记整理 关键字 用于定义数据类型 class interface 【引用数据类型：类、接口、数组】 boolean(1) char(2) byte(1) short(2) int(4) long(8) float(4) double(8) 【8个内置数据类型】 类型转换： byte→sho" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ianeiu.github.io/2018/11/18/java%E7%AC%94%E8%AE%B0%E5%9F%BA%E7%A1%80/" />



<meta property="article:published_time" content="2018-11-18T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2018-11-18T00:00:00&#43;00:00"/>











<meta itemprop="name" content="Java笔记——基础">
<meta itemprop="description" content="Java基础笔记整理 关键字 用于定义数据类型 class interface 【引用数据类型：类、接口、数组】 boolean(1) char(2) byte(1) short(2) int(4) long(8) float(4) double(8) 【8个内置数据类型】 类型转换： byte→sho">


<meta itemprop="datePublished" content="2018-11-18T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-11-18T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="6977">



<meta itemprop="keywords" content="基础,笔记," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java笔记——基础"/>
<meta name="twitter:description" content="Java基础笔记整理 关键字 用于定义数据类型 class interface 【引用数据类型：类、接口、数组】 boolean(1) char(2) byte(1) short(2) int(4) long(8) float(4) double(8) 【8个内置数据类型】 类型转换： byte→sho"/>
</head>
<body>
  
  <div class="header-container" style="background: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)), url('https://ianeiu.github.io/images/bg3.jpg'); background-position: center; background-size: cover;">
  <div class="container">
  <nav class="header-nav navbar navbar-expand-md navbar-dark light-dark">
    <div class="header-logo navbar-brand">
      
        <a class="float-left" href="https://ianeiu.github.io/">
      
        
        <img class="mr20 header-logo-image" src="https://ianeiu.github.io/images/avatar.ico" alt="logo">
        
        
          IanEiU
         
      </a>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="nav-menu collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://ianeiu.github.io/">All</a>
              
            
          </li>
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://ianeiu.github.io/categories">分类</a>
              
            
          </li>
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://ianeiu.github.io/tags">标签</a>
              
            
          </li>
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://ianeiu.github.io/category/java/">Java</a>
              
            
          </li>
        
          <li class="nav-item">
            
              <a class="nav-link" href="https://ianeiu.github.io/about/">About</a>
            
          </li>
        
        
      </ul>
    </div>
  </nav>
</div>

<div class="container header-wrapper">
  <div class="row">
    <div class="col-lg-12">
      <div class="header-content">
        <h1 class="header-title">Java笔记——基础</h1>
        <p class="header-date">作者：
          吴炜棉 /
        
        2018-11-18
          / 分类：
          <a href="https://ianeiu.github.io/category/java/">java</a>
        </p>
        
        <div class="header-underline"></div>
        
          <div class="clearfix"></div>
          <p class="float-right header-tags">
              <i class="fas fa-tags" aria-hidden="true"></i>
              <a href="https://ianeiu.github.io/tag/%E5%9F%BA%E7%A1%80/">基础</a>, 
                <a href="https://ianeiu.github.io/tag/%E7%AC%94%E8%AE%B0/">笔记</a>
          </p>
        
        

      </div>
    </div>
  </div>
</div>

  </div>
<div class="container content">
  

<p>Java基础笔记整理</p>

<h2 id="关键字">关键字</h2>

<ul>
<li><p>用于定义数据类型</p>

<ul>
<li>class interface  【引用数据类型：类、接口、数组】<br /></li>

<li><p>boolean(1) char(2) byte(1) short(2) int(4) long(8) float(4) double(8) 【8个内置数据类型】<br />
类型转换：<br />
byte→short→int→→(可能丢失精度)float→→(可能丢失精度)long→→(可能丢失精度)double<br />
char→int<br />
int→long<br />
int→double<br />
float→double</p></li>

<li><p>void</p></li>
</ul></li>

<li><p>用于定义数据类型值</p>

<ul>
<li>true false null</li>
</ul></li>

<li><p>用于定义流程控制</p>

<ul>
<li>if else switch case default【选择】<br />
【switch jdk5前：case byte\short\int\char。jdk5：case：enum。jdk7：case String】<br /></li>
<li>while do for【循环】<br /></li>
<li>break continue return【流程跳转】
<br /></li>
</ul></li>
</ul>

<div style="border:1px solid red;padding:10px 10px">
    直接for循环效率最高，其次是迭代器和 ForEach操作。作为语法糖，ForEach底层是使用迭代器实现，反编译后testForEach方法如下，可以看到，只比迭代器遍历多了生成中间变量这一步，因为性能也略微下降了一些。</div>
    

<pre><code>```
public static void testForEach(List list) {  
    for (Iterator iterator = list.iterator(); iterator.hasNext();) {  
        Object t = iterator.next();  
        Object obj = t;  
    }  
}  
```
</code></pre>

<ul>
<li>用于定义访问权限修饰符

<ul>
<li>private public protected</li>
</ul></li>
<li>用于定义类、函数、变量

<ul>
<li>abstract final static synchronized</li>
</ul></li>
<li>类与类之间的关系

<ul>
<li>extends implements</li>
</ul></li>
<li>建立实例、引用实例、判断实例

<ul>
<li>new this super instanceof</li>
</ul></li>
<li>异常处理

<ul>
<li>try catch throw throws finally</li>
</ul></li>
<li>包

<ul>
<li>package import</li>
</ul></li>
<li>其它

<ul>
<li>native strictfp transient volatile assert</li>
<li>goto const 【保留字】</li>
</ul></li>
</ul>

<h2 id="标识符">标识符</h2>

<p>类、接口、方法、变量的名字<br />
合法字符组成：英文字幕、数字、$、_【不能以数字开头】</p>

<h2 id="注释">注释</h2>

<ul>
<li>单行 //</li>
<li>多行 /**/</li>
<li>文档 /**  */</li>
</ul>

<h2 id="常量">常量</h2>

<ul>
<li>字面值 &ldquo;hello&rdquo;,10.true</li>
<li>自定义 final int LINK_CODE = 0;

<ul>
<li>final 修饰变量（基本类型值不变，引用类型地址值不变）（只能在构造方法执行之前赋值一次）</li>
</ul></li>
</ul>

<h2 id="变量">变量</h2>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">类变量（静态变量）</th>
<th align="left">实例变量（成员变量）</th>
<th align="left">局部变量（本地变量）</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">位置（代码）</td>
<td align="left">类中</td>
<td align="left">类中方法外</td>
<td align="left">方法定义中、方法声明上</td>
</tr>

<tr>
<td align="left">位置（内存）</td>
<td align="left">方法区中静态区</td>
<td align="left">堆</td>
<td align="left">栈</td>
</tr>

<tr>
<td align="left">生命周期</td>
<td align="left">随类加载而加载</td>
<td align="left">随对象</td>
<td align="left">随方法</td>
</tr>

<tr>
<td align="left"></td>
<td align="left">this无法存在静态中；</td>
<td align="left"></td>
<td align="left"></td>
</tr>

<tr>
<td align="left"></td>
<td align="left">静态方法只能访问静态变量</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>

<h2 id="运算符">运算符</h2>

<ul>
<li>算术运算符<br />
<code>
% + - * / ++  --
</code></li>
<li>赋值运算符<br />
<code>
= += -= *= /= %=
</code></li>
<li>比较运算符<br />
<code>
== != &gt; &lt; &gt;= &lt;= 
</code></li>
<li>逻辑运算符<br />
<code>
&amp; | ^(异或) ! &amp;&amp; || 【&amp;&amp; || 有短路效果】
</code></li>

<li><p>位运算符<br />
<code>
&lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移) &amp; | ^ ~(按位取反)
</code></p></li>

<li><p>三元运算符<br />
<code>
max = a &gt; b ? a : b
</code></p></li>
</ul>

<h2 id="代码块">代码块</h2>

<p>代码块加载顺序： 静态代码块（类初始化）&ndash;&gt; 局部代码块 &ndash;&gt; 构造代码块（对象初始化）</p>

<pre><code>public class Importtant06Code {
    static { System.out.println(&quot;Importtant06Code静态代码块&quot;);}

    public static void main(String[] args) {
        System.out.println(&quot;main&quot;);
        User user = new User();
        User user2 = new User();
    }
}

class User{
    static { System.out.println(&quot;User静态代码块&quot;);}
    {System.out.println(&quot;User局部代码块&quot;);}
    public User() {System.out.println(&quot;User构造代码块&quot;);}

}
</code></pre>

<p>运行结果：</p>

<pre><code>Importtant06Code静态代码块
main
User静态代码块
User局部代码块
User构造代码块
User局部代码块
User构造代码块
</code></pre>

<hr />

<h2 id="java面向对象三大特性">Java面向对象三大特性</h2>

<p>封装、继承、多态</p>

<h2 id="类与对象">类与对象</h2>

<ul>
<li>类：一组相关属性和行为的集合（抽象）</li>
<li>对象：改类事物的具体表现形式（具体存在的个体）</li>
</ul>

<h2 id="封装">封装</h2>

<blockquote>
<p>把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口<br />
好处：隐藏实现细节,提供公共访问方式，复用性，安全性</p>
</blockquote>

<p>关键字：private、this、static、new</p>

<p>例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">User</span><span class="p">{</span>
	<span class="n">private</span> <span class="n">String</span> <span class="n">userName</span> <span class="o">=</span> <span class="s2">&#34;wm&#34;</span><span class="p">;</span>
	<span class="n">private</span> <span class="n">Integer</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
	
	<span class="n">public</span> <span class="n">User</span><span class="p">(){</span>
		<span class="n">this</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;sg&#34;</span><span class="p">;</span>
		<span class="n">this</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Demo</span> <span class="p">{</span>
	<span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">){</span>
		<span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">new</span> <span class="n">User</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>对象构造过程：</p>

<ol>
<li>将User.class文件加载到内存</li>
<li>栈内存放置user，堆内存放置对象</li>
<li>给成员变量进行初始化

<ul>
<li>默认初始化 name:null  age:0</li>
<li>显示初始化 name:wm    age:18</li>
<li>构造初始化 name:sg    age:25</li>
</ul></li>
<li>将地址值赋给变量user</li>
</ol>

<h2 id="继承">继承</h2>

<blockquote>
<p>从已有类得到继承信息创建新类的过程<br />
好处：复用、维护、多态前提</p>
</blockquote>

<p>关键字：extends、this、super</p>

<h4 id="重载与重写">重载与重写</h4>

<ul>
<li>重写（Override） 子类重写父类方法,多态的条件之一</li>
<li>重载（Overload） 同一个类中不同参数的方法</li>
</ul>

<h4 id="注意">注意</h4>

<ol>
<li>子类初始化之前会先进行父类的初始化</li>
<li>父类没有无参构造，编译会报错</li>
<li>子类重写父类方法，方法访问权限不能比之更低</li>
</ol>

<h2 id="多态">多态</h2>

<blockquote>
<p>允许不同子类型的对象对同一消息作出不同的响应<br />
好处： 维护、扩展</p>
</blockquote>

<p>父类接口指向子类对象，主要体现在抽象类</p>

<p>Fu f = new Zi();<br />
成员方法：编译看父类，运行看子类。<br />
静态方法：编译看父类，运行看子类。<br />
成员变量：编译看父类，运行看子类。<br />
构造方法：编译看父类，运行看父子。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">package</span> <span class="n">com</span><span class="o">.</span><span class="n">wm</span><span class="o">.</span><span class="n">demo</span><span class="o">.</span><span class="n">learn</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">d1tod4</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Fu</span> <span class="p">{</span>
	<span class="n">public</span> <span class="nb">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	
	<span class="n">public</span> <span class="n">Fu</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">super</span><span class="p">();</span>
		<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&#34;new Fu&#34;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">public</span> <span class="n">void</span> <span class="n">show</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&#34;show Fu&#34;</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&#34;function Fu&#34;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Zi</span> <span class="n">extends</span> <span class="n">Fu</span> <span class="p">{</span>
	<span class="n">public</span> <span class="nb">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">public</span> <span class="nb">int</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

	<span class="n">public</span> <span class="n">Zi</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">super</span><span class="p">();</span>
		<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&#34;new Zi&#34;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="n">public</span> <span class="n">void</span> <span class="n">show</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&#34;show Zi&#34;</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">public</span> <span class="n">void</span> <span class="n">method</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&#34;method zi&#34;</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&#34;function Zi&#34;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Demo04DuoTai</span> <span class="p">{</span>
	<span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s2">&#34;static-access&#34;</span><span class="p">)</span>
	<span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">//</span><span class="err">父类引用指向子类对象</span>  <span class="err">父</span> <span class="n">f</span> <span class="o">=</span>  <span class="n">new</span> <span class="err">子</span><span class="p">();</span>
		<span class="n">Fu</span> <span class="n">f</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Zi</span><span class="p">();</span>
		<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">num</span><span class="p">);</span>
		<span class="o">//</span><span class="err">找不到符号</span>
		<span class="o">//</span><span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">num2</span><span class="p">);</span>
		
		<span class="n">f</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
		<span class="o">//</span><span class="err">找不到符号</span>
		<span class="o">//</span><span class="n">f</span><span class="o">.</span><span class="n">method</span><span class="p">();</span>
		<span class="n">f</span><span class="o">.</span><span class="n">function</span><span class="p">();</span>
		
		<span class="o">/*</span><span class="n">new</span> <span class="n">Fu</span>
		<span class="n">new</span> <span class="n">Zi</span>
		<span class="mi">100</span>
		<span class="n">show</span> <span class="n">Zi</span>
		<span class="n">function</span> <span class="n">Fu</span><span class="o">*/</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<hr />

<p><kbd>java多态的实现原理</kbd></p>

<p>当JVM执行Java字节码时，类型信息会存储在方法区中，为了优化对象的调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。</p>

<p>方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。
方法区的内存回收目标是针对常量池的回收及对类型的卸载。</p>

<p>方法表的构造</p>

<p>由于java的单继承机制，一个类只能继承一个父类，而所有的类又都继承Object类，方法表中最先存放的是Object的方法，接下来是父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。</p>

<p>由于这样的特性，使得方法表的偏移量总是固定的，例如，对于任何类来说，其方法表的equals方法的偏移量总是一个定值，所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。</p>

<p>实例</p>

<p>假设Class A是Class B的子类，并且A改写了B的方法的method()，那么B来说，method方法的指针指向B的method方法入口；对于A来说，A的方法表的method项指向自身的method而非父类的。</p>

<p>流程：调用方法时，虚拟机通过对象引用得到方法区中类型信息的方法表的指针入口，查询类的方法表 ，根据实例方法的符号引用解析出该方法在方法表的偏移量，子类对象声明为父类类型时，形式上调用的是父类的方法，此时虚拟机会从实际的方法表中找到方法地址，从而定位到实际类的方法。<br />
注：所有引用为父类，但方法区的类型信息中存放的是子类的信息，所以调用的是子类的方法表。</p>

<hr />

<h2 id="抽象类与接口">抽象类与接口</h2>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">抽象类</th>
<th align="left">接口</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">特点</td>
<td align="left">1.抽象类与方法需用abstract修饰</td>
<td align="left">1.接口用interface修饰</td>
</tr>

<tr>
<td align="left"></td>
<td align="left">2.抽象类不一定有抽象方法，有则为抽象类</td>
<td align="left">2.类实现接口用implements</td>
</tr>

<tr>
<td align="left"></td>
<td align="left">3.不能直接实例化（通过多态可实例化）</td>
<td align="left">3.不能被实例化</td>
</tr>

<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>

<tr>
<td align="left">实现</td>
<td align="left">抽象类、具体类（重写所有方法）</td>
<td align="left">抽象类，具体类</td>
</tr>

<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>

<tr>
<td align="left">成员特点-属性</td>
<td align="left">变量、常量</td>
<td align="left">常量</td>
</tr>

<tr>
<td align="left">成员特点-构造方法</td>
<td align="left">有</td>
<td align="left">无</td>
</tr>

<tr>
<td align="left">成员特点-成员方法</td>
<td align="left">抽象、非抽象</td>
<td align="left">抽象、【JDK8有 default、static方法】</td>
</tr>

<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>

<tr>
<td align="left">关键字</td>
<td align="left">不能与private、final、static(无意义)共存</td>
<td align="left"></td>
</tr>

<tr>
<td align="left"></td>
<td align="left">编译报错</td>
<td align="left"></td>
</tr>
</tbody>
</table>

<h2 id="内部类">内部类</h2>

<ol>
<li><p>成员内部类</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Outer</span><span class="p">{</span>
    <span class="n">static</span> <span class="nb">int</span> <span class="n">num0</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
    <span class="n">public</span> <span class="nb">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        
    <span class="k">class</span> <span class="nc">Inner</span><span class="p">{</span>
        <span class="n">public</span> <span class="nb">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
        <span class="n">public</span> <span class="n">void</span> <span class="n">show</span><span class="p">(){</span>
            <span class="nb">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
            <span class="n">system</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="o">//</span><span class="mi">30</span>
            <span class="n">system</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">num</span><span class="p">);</span><span class="o">//</span><span class="mi">20</span>
            <span class="n">system</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">Outer</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">num</span><span class="p">);</span><span class="o">//</span><span class="mi">10</span>
                
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
    
<span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">){</span>
        <span class="n">Outer</span><span class="o">.</span><span class="n">Inner</span> <span class="n">oi</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Outer</span><span class="p">()</span><span class="o">.</span><span class="n">new</span> <span class="n">Inner</span><span class="p">();</span>
        <span class="n">oi</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div></li>

<li><p>局部内部类</p>

<pre><code>class Outer{
    static int num0 = 99;
    public int num = 10;
        
    public void method(){
        final int num2 = 100;//存放于堆内存
        int num3 = 101;//随调用产生，随结束消失
        class Inner{
            Outer o = new Outer();
            system.out.println(o.num0);
            system.out.println(o.num1);
            system.out.println(o.num2);
            //system.out.println(o.num3);//无法访问，编译报错
        }
    }
}
    
class Test{
    public static void main(String[] args){
        Outer o = new Outer();
        o.method();
    }
}
</code></pre></li>

<li><p>匿名内部类</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">interface</span> <span class="n">Person</span><span class="p">{</span><span class="n">void</span> <span class="n">study</span><span class="p">();}</span>
    
<span class="k">class</span> <span class="nc">PersonDemo</span><span class="p">{</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">method</span><span class="p">(</span><span class="n">Person</span> <span class="n">p</span><span class="p">){</span>
        <span class="n">p</span><span class="o">.</span><span class="n">study</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
    
<span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">){</span>
        <span class="n">PersonDemo</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">new</span> <span class="n">PersonDemo</span><span class="p">();</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">new</span> <span class="n">Person</span><span class="p">(){</span>
            <span class="n">public</span> <span class="n">void</span> <span class="n">study</span><span class="p">(){</span>
                <span class="o">//</span><span class="n">dosomething</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span> 
<span class="p">}</span>
    </code></pre></div></li>

<li><p>静态内部类（访问外部数据必须用static修饰）</p>

<pre><code>class Outer{
    static int num0 = 99;
    public int num = 10;
        
    static class Inner{
        public int num = 20;
        public void show(){
            int num = 30;
            system.out.println(num);//30
            system.out.println(this.num);//20
            system.out.println(Outer.this.num);//10
                
        }
    }
}
    
class Test{
    public static void main(String[] args){
        Outer.Inner oi = new Outer().Inner();
        oi.show();
            
        Outer.Inner.show();
    }
}
</code></pre></li>
</ol>

<h2 id="异常">异常</h2>

<p><img src="http://images2015.cnblogs.com/blog/679904/201510/679904-20151025210813989-921927916.jpg" alt="yc" /></p>

<p>Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</p>

<ol>
<li><p>Throwable
Throwable是 Java 语言中所有错误或异常的超类。
Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。
Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。</p></li>

<li><p>Exception
Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。</p></li>

<li><p>RuntimeException
RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。
编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既&rdquo;没有通过throws声明抛出ArithmeticException异常&rdquo;，也&rdquo;没有通过try&hellip;catch&hellip;处理该异常&rdquo;，也能通过编译。这就是我们所说的&rdquo;编译器不会检查RuntimeException异常&rdquo;。</p></li>

<li><p>非RuntimeException
Exception类本身，以及Exception的子类中除了&rdquo;运行时异常&rdquo;之外的其它子类都属于被检查异常。
Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。</p></li>

<li><p>Error
和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。<br />
和RuntimeException一样， 编译器也不会检查Error。</p></li>
</ol>

<h2 id="collection概述">Collection概述</h2>

<p>Collection 是对象集合，继承了超级接口Iterable，使用Iterator迭代器实现遍历。 Collection 有两个子接口 List 和 Set。</p>

<p>List 可以通过下标 (1,2..) 来取得值，值是有序重复，有自己的迭代器ListIterator，可以通过这个迭代器进行逆序的迭代。</p>

<p>ArrayList、Vector、LinkedList 是List的实现类。</p>

<p>ArrayList 是线程不安全的，底层采用数组实现（并且该数组的类型是Object类型的），默认长度为10。<br />
Vector 是线程安全的，底层采用数组实现。<br />
LinkedList 是线程不安全的，底层是由（双向循环Deque）链表实现的。</p>

<p>Stack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。<br />
Queue接口：提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList（实现双端队列Deque）、PriorityQueue等。</p>

<hr />

<p>Set 只能通过游标来取值，并且值是不能重复的。Set中的元素类必须有一个有效的equals方法。</p>

<p>Set子接口有NavigableSet、SortedSet；Set子类有EnumSet、HashSet、LinkedHashSet、TreeSet、AbstractSet等。</p>

<p>HashSet 底层是哈希表（元素为链表的数组）实现（方法代码使用了HashMap），由hashcode()和equals()方法保证元素唯一。<br />
TreeSet 底层是红黑树（自平衡的二叉树）实现，元素是可排序的。</p>

<p>LinkedHashSet 底层由链表和哈希表实现，保证元素有序且唯一。</p>

<p>TreeSet有两种排序实现。自然排序(内比较器)，类实现Comparable；比较器排序，使用匿名内部方式实现。</p>

<pre><code>//比较器排序
TreeSet&lt;User&gt; userSet = new TreeSet&lt;&gt;(
	new Comparator&lt;User&gt;(){
		public int compare(User user1, User user2){
			if (user1.getAge() &gt; user2.getAge()) return 1;
			else if (user1.getAge() = user2.getAge()) return 0;
			else  return -1;
		}
	}
)
</code></pre>

<p>注意：</p>

<ul>
<li>使用迭代器Iterator遍历集合时修改添加元素会报并发修改异常，而用ListIterator则不会。</li>
<li>使用size()获取集合长度</li>
<li>toString()实现：AbstractColletion使用iterator()迭代器方法得到迭代器，之后使用StringBuilder拼接遍历的值。</li>
</ul>

<h2 id="arraylist-linkedlist-vector的底层实现和区别">ArrayList、LinkedList、Vector的底层实现和区别</h2>

<ul>
<li>从同步性来看，ArrayList和LinkedList是不同步的，而Vector是的。所以线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList、LinkedList，使我们也达到同步，但效率可能会有所降低。</li>
<li>从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。如果你要在集合中保存大量的数据，那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。</li>
<li>ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或者删除元素那么花费的时间会呈线性增长O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置，因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList底层是由双向循环链表实现的，LinkedList在插入、删除集合中任何位置的元素所花费的时间都是一样的O(1)，但它在索引一个元素的时候比较慢，为O(i)，其中i是索引的位置，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。</li>
</ul>

<h2 id="map概述">Map概述</h2>

<p>Map 是键值对集合。HashTable和HashMap是Map的实现类。</p>

<p>HashMap不是线程安全的，键唯一（哈希表实现），可以存储null值。<br />
HashTable是线程安全的，键唯一，不能存储null值。</p>

<p>LinkedHashMap键是唯一有序的（哈希表和链表实现）<br />
TreeMap键是可排序的（红黑树实现）</p>

<h2 id="io流">IO流</h2>

<p>//TODO</p>

<h2 id="多线程相关">多线程相关</h2>

<ol>
<li>多线程实现方案：

<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口结合线程池</li>
</ul></li>
<li>线程安全问题产生条件

<ul>
<li>多线程环境</li>
<li>有共享数据</li>
<li>有多条语句操作共享数据</li>
</ul></li>
<li>同步的方式：

<ul>
<li>同步代码块 <code>synchronized(对象){//doSomething}</code></li>
<li>同步方法</li>
</ul></li>
<li>run()与start()

<ul>
<li>run():封装了被线程执行的代码,直接调用仅仅是普通方法的调用</li>
<li>start():启动线程，并由JVM自动调用run()方法</li>
</ul></li>
<li>sleep()与wait()

<ul>
<li>sleep():必须指定时间;不释放锁。</li>
<li>wait(): 可不指定时间;释放锁。</li>
</ul></li>
</ol>

<h2 id="线程状态">线程状态</h2>

<ul>
<li>新建（New）:创建后尚未启动的线程处于这种状态。</li>
<li>运行(Runnable)：Runnable包括了操作系统状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间。</li>
<li>无限期等待（Waiting）:处于这种状态的进程不会被分配CPU执行时间，它们要等待被其他线程显示的唤醒。以下方法会让线程陷入无限期的等待状态：

<ul>
<li>没有设置Timeout参数的Object.wait()方法</li>
<li>没有设置Timeout参数的Thread.join()方法</li>
<li>LockSupport.park()方法</li>
</ul></li>
<li>限期等待（Timed Waiting）:处于这种状态的进程不会被分配CPU执行时间，不过无需等待被其他线程显示的唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：

<ul>
<li>Thread.sleep()方法</li>
<li>设置了Timeout参数的Object.wait()方法</li>
<li>设置了Timeout参数的Thread.join()方法</li>
<li>LockSupport.parkNanos()方法</li>
<li>LockSupport.parkUnitil()方法</li>
</ul></li>
<li>阻塞（Blocked）:进程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获取到一个排它锁，这个事件将在另一个线程放弃这个锁的时候发生；而等待状态则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
<li>结束（Terminated）:已终止线程的线程状态，线程已经结束执行。</li>
</ul>

<h2 id="socket编程">Socket编程</h2>

<p>//TODO</p>

<h2 id="反射机制">反射机制</h2>

<p>反射技术：动态加载一个指定的类，并获取该类中所有的内容。并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。</p>

<blockquote>
<p>好处：大大增强了程序的扩展性。</p>
</blockquote>

<p>反射的基本步骤：</p>

<ol>
<li>获得Class对象，就是获得指定的名称的字节码文件对象</li>
<li>实例化对象，获得类的属性、方法或者构造函数</li>
<li>访问属性、调用方法、调用构造函数创建对象</li>
</ol>


  
  


</div>
<div class="footer gradient-2">
  <div class="container footer-container ">
    <div class="row">
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        <div class="footer-title">网站导航</div>
        <ul class="list-unstyled">
            
              
                <li><a href="https://ianeiu.github.io/tags/">标签</a></li>
              
              
                <li><a href="https://ianeiu.github.io/categories/">分类</a></li>
              
            
            
            
            <li><a rel="alternate" type="application/rss&#43;xml" href="https://ianeiu.github.io/index.xml"><i class="fas fa-rss-square"></i> RSS 订阅</a></li>
            
            
        </ul>
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">社交</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/ianeiu" rel="noopener" target="_blank">GitHub</a></li>
          
        </ul>
        
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">链接</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/ianeiu" rel="noopener" target="_blank">关于我</a></li>
          
        </ul>
        
      </div> 
      <div class="col-xs-12 col-sm-3 col-md-3 col-lg-3">
        <p class="pull-right text-right">
          <small><em>Proudly powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a></em></small><br/>
          <small><em>Theme - <a href="https://github.com/shaform/hugo-theme-den" rel="noopener" target="_blank">Den</a></em></small><br/>
          <small>
            &copy; 
            WuWeiMian
            2018
          </small>
          
        </p>
      </div>
    </div>
  </div>
</div>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
 <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
</body>
</html>
