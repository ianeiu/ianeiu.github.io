<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 吴炜棉</title>
    <link>https://ianeiu.github.io/post/</link>
    <description>Recent content in Posts on 吴炜棉</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 08 Jul 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://ianeiu.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mysql面试题</title>
      <link>https://ianeiu.github.io/p/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>MySQL InnoDB、Mysaim的特点  InnoDB  支持事务处理、外键、行锁 不保存表的具体行数，扫描表来计算多少行 对于AUTO_INCREMENT类型的字段，必须包含只有该字段的索引 DELETE表时，是一行一行的删除 把数据和索引存放在表空间里面 跨平台直接拷贝使用 表格很难被压缩   Mysaim （适合读多写少的场景）  不支持事务、外键 保存表具体行数 AUTO_INCREMENT可以与其他字段一起建联合索引 DELETE表时先drop表，然后重建 表将存放三个文件。frm文件存在表格定义，myds数据文件，myi存在索引 跨平台很难卡片被 表格可压缩    Mysql主备同步的基本原理  master将该表记录到二进制日志 binary log中 salve将master的binary log events 拷贝到它的中继日志relay log salve重做中继日志中的事件，改变数据  如何优化数据库性能（索引、分库分表、批置操作、分页算法、升级硬盘SSD、业务优化、主从部署）  选择合适的数据库引擎，合理使用索引 分页获取数据，按需取字段 优化业务代码，减少数据库IO 分库分表 部署主从数据库 升级硬件  SQL什么情况下不会使用索引（不包含，不等于，函数）  select * 可能导致不走索引 空值会导致不走索引 索引列有函数运算 隐式转换可能导致不走索引 表的数据库小或者需要选择大部分数据，不走索引 != 或者 &amp;lt;&amp;gt; like &amp;lsquo;%ex&amp;rsquo; not in 、 not exist  一般在什么字段上建索引（过滤数据最多的字段）  表的主键、外键 数据量超过300的表 经常与其他表进行连接的表的连接字段 经常出现在where语句上的字段 应该建在选择性高的字段、小字段  mysql调优  explain select 语句 当只要一条数据时使用limit 1 为查询字段建索引 避免select * 字段尽量使用not null 垂直分割 拆分大的delete和insert，这俩会锁表 分库分表分区  </description>
    </item>
    
    <item>
      <title>struts工作流程</title>
      <link>https://ianeiu.github.io/p/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid>
      <description>struts工作流程  客户端浏览器发出HTTP请求。 根据web.xml配置，该请求被FilterDispatcher接收。 根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。 Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。 Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。 返回HTTP响应到客户端浏览器。</description>
    </item>
    
    <item>
      <title>Spring面试题</title>
      <link>https://ianeiu.github.io/p/spring%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/spring%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>Spring装配Bean的过程  实例化; 设置属性值; 如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name; 如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory; 如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext 调用BeanPostProcessor的预先初始化方法; 调用InitializingBean的afterPropertiesSet()方法; 调用定制init-method方法； 调用BeanPostProcessor的后初始化方法;  springboot的启动过程  通过 SpringFactoriesLoader加载 META-INF/spring.factories文件，获取并创建 SpringApplicationRunListener对象 然后由 SpringApplicationRunListener来发出 starting 消息 创建参数，并配置当前 SpringBoot 应用将要使用的 Environment 完成之后，依然由 SpringApplicationRunListener来发出 environmentPrepared 消息 创建 ApplicationContext 初始化 ApplicationContext，并设置 Environment，加载相关配置等 由 SpringApplicationRunListener来发出 contextPrepared消息，告知SpringBoot 应用使用的ApplicationContext已准备OK 将各种 beans 装载入 ApplicationContext，继续由 SpringApplicationRunListener来发出 contextLoaded 消息，告知SpringBoot 应用使用的 ApplicationContext已装填OK refresh ApplicationContext，完成IoC容器可用的最后一步 由 SpringApplicationRunListener来发出 started 消息 完成最终的程序的启动 由 SpringApplicationRunListener来发出 running 消息，告知程序已运行行起来了  
spring事件的实现原理，写出常用的几个事件  事件机制：Spring中的事件机制是一个观察者模式的实现.观察者模式就是一个目标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。 spring默认存在的事件：  ContextStartedEvent：ApplicationContext启动后触发的事件 ContextStoppedEvent：ApplicationContext停止后触发的事件 ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件 ContextClosedEvent：ApplicationContext关闭后触发的事件    spring中的设计模式  简单工厂：spring中的BeanFactory就是简单工厂模式的体现，根据传⼊入一个唯一的标识来获得bean对象，但是否是在传⼊参数后创建还是传入参数前创建这个要根据具体情况来定。 单例模式：Spring下默认的bean均为singleton。 代理模式：为其他对象提供⼀种代理以控制对这个对象的访问。从结构上来看和Decorator模式类似，但Proxy是控制，更更像是一种对功能的限制，而Decorator是增加职责。 spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更更新。spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 模板模式：类似 JdbcTemplate 等则是应用了模板模式。  </description>
    </item>
    
    <item>
      <title>Java笔记之NIO</title>
      <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/</link>
      <pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/</guid>
      <description>Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？ Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。 首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。 交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时， 在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。 java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。
很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、 HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。
第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象， 可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。
第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。 异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里， 当后台处理完成，操作系统会通知相应线程进行后续工作。
NIO是一种非阻塞式I/O；采用了双向通道进行数据传输，NIO基于Channel和Buffer(缓冲区)进⾏操作，数据总是从通道读取到缓冲区中，或者从缓冲区 写⼊入到通道中。Selector(选择区 [阻塞] )用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。 利用单线程轮询事件的机制，有效避免大量客户端连接时，频繁线程切换带来的问题。
IO、NIO IO 概览:</description>
    </item>
    
    <item>
      <title>JVM笔记之调优及参数</title>
      <link>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B0%83%E4%BC%98%E5%8F%8A%E5%8F%82%E6%95%B0/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B0%83%E4%BC%98%E5%8F%8A%E5%8F%82%E6%95%B0/</guid>
      <description>调优 调优时机  内存（⽼年代）持续上涨达到设置的最大内存值； Full GC 次数频繁； GC 停顿时间过长（超过1秒）； 应用出现OutOfMemory 等内存异常； 应⽤中使用本地缓存占用大量内存空间； 系统吞吐量量与响应性能不高或下降。  调优原则  多数的Java应用不需要在服务器上进行JVM优化，JVM优化是到最后不得已才采用的⼿段； 多数导致GC问题的Java应用，往往是代码问题，分析GC情况优化代码； 在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）； 减少创建对象的数量； 减少使用全局变量和大对象  调优目标 GC低停顿、低频率； 低内存占用；⾼吞吐量
调优步骤  分析GC日志及dump⽂文件，判断是否需要优化，确定瓶颈问题点； 确定jvm调优量化目标； 确定jvm调优参数（根据历史jvm参数来调整）； 调优一台服务器，对比观察调优前后的差异； 不断的分析和调整，直到找到合适的jvm参数配置； 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。  参数 堆参数设置   -Xms 设置Java程序启动时初始化JVM堆内存大小。
  -Xmx 设置Java程序能获得最大JVM堆内存大小。
  -XX:+PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志。
  -XX:+PrintGCDetails 可以查看详细信息，包括各个区的情况
  -XX:+PrintHeapAtGC 打印 GC 前后的详细堆栈信息
  -XX:+PrintFlagsInitial打印JVM初始化参数。
  -XX:+PrintFlagsFinal　标记人为修改过的参数。
  -XX:+PrintCommandLineFlags 查看默认垃圾回收器。
  新生代参数设置   -XX:NewSize=5m 设置新生代最小空间大小</description>
    </item>
    
    <item>
      <title>正则表达式——贪婪模式与懒惰模式</title>
      <link>https://ianeiu.github.io/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F/</guid>
      <description>知识点：正则表达式中表示字符串重复个数的元字符，如 ?,+,*,{} 默认贪婪模式匹配最大长度匹配字符串。 在元字符后加个?即可切换为懒惰模式
前言 之前做过一个短信模版的配置功能，需要用到正则判断完成预览方法，踩了个小坑。
&amp;lt;!-- 部分代码 --&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt; &amp;lt;script src=&amp;quot;//libs.baidu.com/jquery/1.10.2/jquery.min.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; $(document).ready(function () { createContentPreview() }); function createContentPreview(){ //遍历获取所有input标签值 var vals=[]; $(&amp;quot;#tExaDiv&amp;quot;).find(&amp;quot;input&amp;quot;).each(function(){ var val=$(this).val(); vals.push(val); }) // 含有&amp;lt;input type=&amp;quot;..&amp;quot; /&amp;gt;标签 var html=$(&amp;quot;#tExaDiv&amp;quot;).html(); //遍历替换 var reg=/&amp;lt;input[^]*?&amp;gt;/; for(var i=0;i&amp;lt;vals.length;i++){ html=html.replace(reg,vals[i]); } //渲染 $(&amp;quot;#contentPreview&amp;quot;).html(html); } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;quot;tExaDiv&amp;quot;&amp;gt; 如果我是&amp;lt;input =&amp;quot;text&amp;quot; value=&amp;quot;dj&amp;quot;/&amp;gt;,你会&amp;lt;input =&amp;quot;text&amp;quot; value=&amp;quot;爱&amp;quot;/&amp;gt;我吗？ &amp;lt;/div&amp;gt; &amp;lt;div id=&amp;quot;contentPreview&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; contentPreview内容：如果我是dj,你会爱我吗？
如果未加?，则是贪婪模式。contentPreview显示错误内容：如果我是dj我吗？
懒惰模式 对字符串进行最小长度匹配
字符串：&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt;</description>
    </item>
    
    <item>
      <title>Java面试之并发</title>
      <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/</guid>
      <description>什么是乐观锁和悲观锁？ 1、悲观锁
Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。
2、乐观锁
乐观锁（Optimstic Locking）其实是一种思想。相对悲观锁而言，乐观锁假定认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式地对数据的冲突与否进行检测，如果发现冲突了，则返回错误信息。
什么是AQS AbstractQueuedSynchronizer，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、FutureTask等。
AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作 哨兵节点或这哑节点，它不与任何线程关联。其他节点与等待线程关联，每个节点维护一个等待状态waitStatus。
同步容器与并发容器  同步容器  同步容器主要代表用Vector和Hashtable，及Collections.synchronizedXXX等 锁粒度为整体对象 迭代器是及时失败的，迭代过程修改会抛出ConcurrentModificationException   并发容器  主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet 锁粒度是分散的、细粒度，即读写使用不同锁 迭代器具有弱一致性，能够迭代时修改。    synchronized 底层如何实现？什么是锁的升级、降级？ synchronized 代码块是由 monitorenter/monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。
在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。
现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现， 也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。
所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制， 当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。
当没有竞争出现时，默认会使用偏斜锁。 JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。 这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。
如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。 轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</description>
    </item>
    
    <item>
      <title>Java面试题</title>
      <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>Java平台理解及Java是解释执行吗？ 首先Java是一种面向对象的语言，本身具有两个特性：一个是跨平台能力（一次编写，到处运行），屏蔽了操作系统和硬件的细节； 第二个就是垃圾自动回收机制（GC）。
我们日常接触到的jre（Java runtime environment）和jdk（Java development kit）， jre是Java运行时环境，包含了JVM和java类库； jdk则是Java开发工具，里面提供了许多开发工具如；编译器(javac)、诊断和监控(jconsole)工具等。
java生态：spring，spark，elasticsearch，maven
不完全正确，Java是通过对源文件进行编译成字节码文件（.class），然后jvm（Java虚拟机）对字节码文件逐条进行解释运行。 但是往往有一部分热点代码（hot spot）会占有大部分时间解释，所以Java中会有jit（Just-In-Time）。即时编译器将该部分直接编译成机器代码直接运行，大大提高效率。 这部分热点代码就是编译执行了而不是解释执行。
在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。 主流 Java 版本中，如 JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。 通常运行在 server 模式的 JVM，会进行上万次调用以收集足够的信息进行高效的编译，client 模式这个门限是 1500 次。 Oracle Hotspot JVM 内置了两个不同的 JIT compiler， C1 对应前面说的 client 模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用； C2 对应 server 模式，它的优化是为长时间运行的服务器端应用设计的，默认是采用所谓的分层编译（TieredCompilation）。
除了我们日常最常见的 Java 使用模式，其实还有一种新的编译方式， 即所谓的 AOT（Aheadof-Time Compilation），直接将字节码编译成机器代码， 这样就避免了 JIT 预热等各方面的开销， 比如 Oracle JDK 9 就引入了实验性的 AOT 特性，并且增加了新的 jaotc 工具。
java创建对象的方式  使用new关键字创建对象 使用Class类的newInstance方法(反射机制) 使用Constructor类的newInstance方法(反射机制) 使用Clone方法创建对象 使用(反)序列化机制创建对象  Exception和Error有什么区别 Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</description>
    </item>
    
    <item>
      <title>Mybatis之面试篇</title>
      <link>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E9%9D%A2%E8%AF%95%E7%AF%87/</link>
      <pubDate>Sun, 09 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E9%9D%A2%E8%AF%95%E7%AF%87/</guid>
      <description>#{}和${}的区别？ ${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换。
#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值
最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？ Dao接口的全限定名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中MappedStatement的id值；接口方法内的参数，就是传递给sql的参数。
Mapper接口是没有实现类的，当调用接口方法时，全限定名+方法名作为key值，可唯一定位一个MappedStatement。
Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。
Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。
mybatis是如何分页的  SQL带参直接分页 使用拦截器分页
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 RowBounds分页
Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。数据量小时，RowBounds不失为一种好办法。但是数据量大时，实现拦截器就很有必要了。  Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？  使用标签，逐一定义列名和对象属性名之间的映射关系。 使用sql列的别名功能，将列别名书（不区分大小写）写为对象属性名，比如TNAME AS NAME  Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？ Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
原理：使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。
Mybatis都有哪些Executor执行器？它们之间的区别是什么？ Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。
BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。
Mybatis是否可以映射Enum枚举类 Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</description>
    </item>
    
    <item>
      <title>Java开发之命名规范</title>
      <link>https://ianeiu.github.io/p/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</guid>
      <description>原文： 编码5分钟，命名2小时？史上最全的Java命名规范参考！
一、Java中的命名规范    类型(名) 约束 例     项目 全部小写 多个单词用中划线分隔‘-’	spring-cloud   包 全部小写 com.alibaba.fastjson   类 单词首字母大写 Feature,FieldDeserializer   变量 首字母小写多个单词组成时，除首个单词其他单词首字母都要大写 password, userName   常量 全部大写，多个单词，用&#39;_&amp;lsquo;分隔 CACHEEXPIREDTIME   方法 同变量 read(), getById(Long id)    二、包命名    前缀 例 含义     indi或onem indi.发起者名.项目名.模块名.…… 个体项目个人发起，但非自己独自完成可公开或私有项目，copyright主要属于发起者。   pers pers.个人名.项目名.模块名.…… 个人项目指个人发起，独自完成，可分享的项目,copyright主要属于个人   priv priv.</description>
    </item>
    
    <item>
      <title>Mybatis之XML篇</title>
      <link>https://ianeiu.github.io/p/mybatis%E4%B9%8Bxml%E7%AF%87/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/mybatis%E4%B9%8Bxml%E7%AF%87/</guid>
      <description>Mybatis xml映射文件中，除了常见的select、insert、updae、delete标签之外 还有动态sql标签 trim、 where、set、foreach、if、choose、when、otherwise、bind等
where标签 反例：
SELECTmodule_code, oper_type, oper_content, data_id, oper_by, oper_name, oper_dt, INET_NTOA(oper_ip) as oper_ipFROM tb_operation_log l WHERE 1=1&amp;lt;if test=&amp;quot;param.moduleCode != null&amp;quot;&amp;gt;AND l.module_code = #{param.moduleCode}&amp;lt;/if&amp;gt;&amp;lt;if test=&amp;quot;param.operBy != null and param.operBy !=&#39;&#39;&amp;quot;&amp;gt;AND l.oper_by = #{param.operBy}&amp;lt;/if&amp;gt;&amp;lt;if test=&amp;quot;param.operName != null and param.operName !=&#39;&#39;&amp;quot;&amp;gt;AND l.oper_name LIKE CONCAT(&amp;quot;%&amp;quot;,#{param.operName},&amp;quot;%&amp;quot;)&amp;lt;/if&amp;gt;&amp;lt;if test=&amp;quot;param.operDtStart != null and param.operDtEnd != null&amp;quot;&amp;gt;AND l.oper_dt BETWEEN #{param.operDtStart} AND #{param.operDtEnd}&amp;lt;/if&amp;gt;order by l.</description>
    </item>
    
    <item>
      <title>Spring常用注解</title>
      <link>https://ianeiu.github.io/p/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</guid>
      <description>常用注解    注解 描述     @Component 泛指组件，类似在xml中配置bean    @Configuration 把类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。   @Repository 用于标注数据访问组件   @Service 用于标注业务层组件,默认bean的id为类名且首字母小写   @Controller 用于标注控制层组件   @RestController spring4.0之后，@controller和@responsebody的结合   @Scope 作用域 表示将Action的范围声明为原型，可以利用容器的scope=&amp;ldquo;prototype&amp;quot;来保证每一个请求有一个单独的Action来处理，避免struts中Action的线程安全问题。spring默认scope是单例模式(scope=&amp;ldquo;singleton&amp;rdquo;)，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2是要求每次次访问都对应不同的Action，scope=&amp;ldquo;prototype&amp;quot;可以保证当有请求的时候都创建一个Action对象。   @Lazy(true) 延迟初始化   @RequestMapping 用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。value：指定请求的实际地址；method：指定请求的method类型，GET、POST、PUT、DELETE等（Spring4.3中引进了｛@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping｝，来帮助简化常用的HTTP方法的映射）   @ResponseBody 将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，效果等同于通过response对象输出指定格式的数据 效果等同于如下代码：@RequestMapping(&amp;quot;/login&amp;rdquo;) public void login(User user, HttpServletResponse response){ response.getWriter.write(JSONObject.fromObject(user).toString()); }   @PostConstruct 初始化注解,用于指定初始化方法（用在方法上）   @PreDestory 用于指定销毁方法（用在方法上）   @DependsOn 定义Bean初始化及销毁时的顺序   @Primary 自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常   @Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用   @Resource 默认按名称装配,当找不到与名称匹配的bean才会按类型装配   @Async 异步方法调用   @RequestParam 接收参数,从request里面拿取值   @PathVariable 接收参数,从一个URI模板里面来填充   @PathParam 这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包   @QueryParam JAX-RS 提供的，和Spring的RequestParam作用一致   @RequestBody 一般是post请求的时候才会使用这个请求(处理application/json、application/xml等格式的数据)    属性注入 @Autowired 自动装配，可消除代码里的getter/setter与bean属性中的property</description>
    </item>
    
    <item>
      <title>JVM之volatile关键字</title>
      <link>https://ianeiu.github.io/p/jvm%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/jvm%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>引入 Java内存模型简称JMM（Java Memory Model），是Java虚拟机所定义的一种抽象规范， 用来屏蔽不同硬件和操作系统的内存访问差异，让java程序在各种平台下都能达到一致的内存访问效果。
  主内存（Main Memory）
主内存可以简单理解为计算机当中的内存，但又不完全等同。
主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。
  工作内存（Working Memory）
工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。
每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。
线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。
不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。
  对于一个静态变量
static int s = 0；  线程A执行如下代码：
s = 3；  通过一系列内存读写的操作指令，线程A把静态变量 s=0 从主内存读到工作内存，再把 s=3 的更新结果同步到主内存当中。
从单线程的角度来看，这个过程没有任何问题。这时候我们引入线程B，执行如下代码：
System.out.println(&amp;quot;s=&amp;quot; + s);  有可能输出 0 或 3
可以使用synchronized同步锁（影响性能）或者使用volatile关键字修饰（轻量）
volatile的实现原理 volatile可以实现内存的可见性和防止指令重排序。
通过内存屏障技术实现的。
为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障指令，内存屏障效果有：
 禁止volatile 修饰变量指令的重排序 写入数据强制刷新到主存 读取数据强制从主存读取  使用原则：
 对变量的写操作不依赖于当前值。例如 i++ 这种就不适用。 该变量没有包含在具有其他变量的不变式中。  volatile的使用场景不是很多，使用时需要仔细考虑下是否适用volatile，注意满足上面的二个原则。
volatile 之 可见性 volatile关键字具有许多特性，其中最重要的特性就是保证了用volatile修饰的变量对所有线程的可见性[当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值]。</description>
    </item>
    
    <item>
      <title>redis笔记</title>
      <link>https://ianeiu.github.io/p/redis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/redis%E7%AC%94%E8%AE%B0/</guid>
      <description>redis Redis本质上是一个Key-Value类型的内存数据库，支持保存多种数据结构，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。
因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。
Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
配置  daemonize：是否以后台进程运行，默认为no。Windows下不支持修改 。Linux平台下可以改为yes，这样就不用为了启动Redis而单独保留一个shell窗口。 pidfile：如以后台进程运行，则需指定一个pid，默认为/var/run/redis.pid。Windows下不支持修改。 bind：绑定主机IP，默认值为127.0.0.1（注释） protected-mode：以保护模式运行，默认yes port： 监听端口，默认为6379 timeout： 超时时间，默认为300（秒） loglevel： 日志记录等级，有4个可选值，debug，verbose（默认值），notice，warning logfile： 日志记录方式，默认值为stdout databases： 可用数据库数，默认值为16，默认数据库为0 save ： 指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。这个可以多个条件配合，比如默认配置文件中的设置，就设置了三个条件。  save 900 1 900秒（15分钟）内至少有1个key被改变 save 300 10 300秒（5分钟）内至少有10个key被改变 save 60 10000 60秒内至少有10000个key被改变   rdbcompression： 存储至本地数据库时是否压缩数据，默认为yes dbfilename： 本地数据库文件名，默认值为dump.rdb dir： 本地数据库存放路径，默认值为 ./ slaveof： 当本机为从服务时，设置主服务的IP及端口（注释） masterauth： 当本机为从服务时，设置主服务的连接密码（注释） requirepass 连接密码（注释） maxclients： 最大客户端连接数，默认不限制（注释） maxmemory ： 设置最大内存，达到最大内存设置后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，任到达最大内存设置，将无法再进行写入操作。（注释） appendonly： 是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认值为no appendfilename： 更新日志文件名，默认值为appendonly.aof（注释） appendfsync： 更新日志条件，共有3个可选值。no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次（默认值）。 vm-enabled： 是否使用虚拟内存，默认值为no vm-swap-file： 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-max-memory： 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0。  命令  info replication 查看信息，本机角色（master、slave）、ip、端口、状态  哨兵配置 # 这个是Redis6379配置内容，其他文件同理新增然后改一下端口即可，26380 26381 #当前Sentinel服务运行的端口 port 26381 bind 127.</description>
    </item>
    
    <item>
      <title>Eclipse笔记</title>
      <link>https://ianeiu.github.io/p/eclipse%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/eclipse%E7%AC%94%E8%AE%B0/</guid>
      <description>快捷键 使用频率极高的快捷键    DESC KEY     代码提示 alt+/   自动生成object方法 alt + shift + s，然后根据提示继续   复制当前行 ctrl +alt + ↓   查找文本 ctrl + k ,ctrl + shfit + k   如何跳转到文件中的特定行 ctrl + l   调出搜索文本的视图 ctrl + f   进行全局搜索和局部搜索 ctrl + h    文件    DESC KEY     创建各种类型的文件 ctrl + n   关闭当前文件 ctrl + w   关闭所有文件 ctrl + shift + w   打开文件所在目录 alt + shift + w，选择system explorer    类    DESC KEY     显示出当前打开的所有文件 ctrl + e   文件切换 ctrl + pg、up ,ctrl + pg、dn   视图切换 ctrl + f7	跳转到代码编辑器视图 f12   经典的quick access ctrl + 3 搜maven、server   eclipse的面包屑功能 alt + shift + b （右键面包屑有关闭按钮）    文本    DESC KEY     删除当前行 ctrl + d   查看字符串出现的地方 ctrl + shift + u   显示html和xml元素的所有属性 ctrl + shift + ,   大小写转换 变小写ctrl + shift + y,变大写ctrl +shift + x   重构-修改名字 alt + shift + r 统一修改方法的参数名字、或者类变量、方法变量   重构-抽取类方法 选中代码，然后使用alt + shift + m,就会弹出抽取视图    Eclipse-插件  Team  Subclipse   Theme  Eclipse Color Theme Darkest Dark Theme with DevStyle   反编译  Enhanced Class Decompiler   UML  AmaterasUML_1.</description>
    </item>
    
    <item>
      <title>IDEA笔记</title>
      <link>https://ianeiu.github.io/p/idea%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/idea%E7%AC%94%E8%AE%B0/</guid>
      <description>快捷键设置  默认情况下，我们输入代码时IDEA会自动弹出代码提示框，这时候是不用按快捷键的，直接使用方向键选择我们需要的条目就可以了。 如果我们想主动 使用代码提示时，默认的快捷键是CTRL+空格，但是中文系统这个快捷键为切换输入法，我们应该调整一下这个快捷键的功能。 首先我们点击左上角的File（文件）——》Setting（设置），打开全局设置。 我们在左侧菜单选择KeyMap，Main Menu-&amp;gt;Code-&amp;gt;Complation，找到Basic和Cyclic Expand Word两个快捷键设置。 在Cyclic Expand Word上点击右键，移除原本的快捷键（AIT+/）。 Basic就是代码提示功能的选项了，我们在这条项目上点击右键，选择第一项，增加快捷键。 在这个界面，我们按下的键就会成为快捷键，此时我们按下AIT+/ 把它作为代码提示的快捷键。 添加完之后代码提示有了两个快捷键了，我们再次点击右键，删除原来的AIT+空格的快捷键就可以了！  常用快捷键 辅助    DESC KEY     查找Intellij的命令 Ctrl+Shift+A   运行 Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止   调整项目窗口宽度 alt+1定位到project视图，使用ctrl+shift+左右箭头来调整项目窗口宽度    查询    DESC KEY     跳转文件指定行 ctrl + l   搜索文本 ctrl + f   全局搜索和局部搜索 ctrl + h   结合ctrl + f 快捷上下查找文本 ctrl + k ,ctrl + shift + k   查找接口实现类 ctrl + alt +B ，ctrl + T   查询 shift + shift   方位名查询 ctrl + shift + alt + n   目录查询 ctrl + shift + alt + n，输入/    编辑    DESC KEY     自动处理 alt+Enter   代码联系 ctrl + alt + space   自动生成方法 alt+insert，然后根据提示继续   删除当前行 ctrl + d、x   复制当前行 ctrl +alt + ↓   选中单词 ctrl + shift + ←、→   大小写转换 ctrl + shift + u、y   收尾补充（;{}等） ctrl + shift + 回车   驼峰下划线命名切换 ctrl + alt + c   重构-修改类、方法、参数名字 alt + shift + r   重构-抽取类方法 选中代码，然后使用alt + shift + m,就会弹出抽取视图   重构-可选择 Ctrl+Shift+Alt+T   代码生成 Template/Postfix +Tab    文件    DESC KEY     关闭所有文件 ctrl + shift + w   显示最近打开的文件 ctrl + e   显示最近修改的文件 ctrl + shift + e   文件切换 ctrl + pg、up   bookmarks ctrl + shift + F11   bookmarks查看 shift + F11    视图    DESC KEY     视图切换 ctrl + Tab   显示类结构 ctrl + o   显示文件位置 Alt+F1   项目切换 ctrl + alt + [ 、]   选择窗口 alt + 窗口代码（1、2、3 .</description>
    </item>
    
    <item>
      <title>Maven笔记</title>
      <link>https://ianeiu.github.io/p/maven%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/maven%E7%AC%94%E8%AE%B0/</guid>
      <description>简介 项目构建和管理自动化工具
  坐标(可由groupId、artifactId、version组成)。
  构件通过坐标作为其唯一标识。
  仓库：
  远程仓库：maven-model-builder-3.3.3.jar\org\apache\maven\model,超级pom.xml文件，全球中央仓库地址：https://repo.maven.apache.org/maven2
  镜像仓库：/conf/setting文件:
&amp;lt;mirror&amp;gt; &amp;lt;id&amp;gt;maven.net.cn&amp;lt;/id&amp;gt; &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt; &amp;lt;name&amp;gt;central mirror in china&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://maven.net.cn/content/groups/public&amp;lt;/url&amp;gt; &amp;lt;/mirror&amp;gt;    本地仓库：修改本地仓库的位置 &amp;lt;localRepository&amp;gt;D:/Maven/repository&amp;lt;/localRepository&amp;gt;
    指定jdk1.7
&amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;jdk-1.7&amp;lt;/id&amp;gt; &amp;lt;activation&amp;gt; &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt; &amp;lt;jdk&amp;gt;1.7&amp;lt;/jdk&amp;gt; &amp;lt;/activation&amp;gt;	&amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;maven.compiler.compilerVersion&amp;gt;1.7&amp;lt;/maven.compiler.compilerVersion&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; ``
  常用构建命令 mvn compile 编译 mvn test 测试 mvn package 打包 mvn clean 删除target mvn install 安装jar包到本地仓库 自动创建目录骨架  archetype:generate 按照提示进行 archetype:generate -DgroupId=组织名, 公司网址的反写+项目名</description>
    </item>
    
    <item>
      <title>Git笔记</title>
      <link>https://ianeiu.github.io/p/git%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/git%E7%AC%94%E8%AE%B0/</guid>
      <description>Git使用教程 Git使用教程
几条常用命令记录  git status 查看本地分支文件信息，确保更新时不产生冲突 git checkout –- [file name] 若文件有修改，可以还原到最初状态; 若文件需要更新到服务器上，应该先merge到服务器，再更新到本地 git branch 查看当前分支情况 git checkout remote branch 若分支为本地分支，则需切换到服务器的远程分支 git pull 拉取代码 git checkout branchA 切换到分支branchA git branch branchB 创建分支branchB  git 工具本地用户名修改  获取当前的用户名 git config user.name 修改用户名 git config --global user.name &amp;quot;用户名&amp;quot;  reset 与 revert  如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用 reset 如果我们想恢复之前的某一版本（该版本不是merge类型），但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用 revert  推荐文章 Git恢复之前版本的两种方法reset、revert（图文详解）
恢复修改的文件 情况1：
修改了文件，没有做过任何git操作，直接 git checkout -- test.txt 就OK了。
情况2：
修改了文件，只进行了git add，执行 git reset HEAD 回退到当前版本, 然后git checkout -- test.</description>
    </item>
    
    <item>
      <title>常用代码片段</title>
      <link>https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</link>
      <pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</guid>
      <description>操作元素的样式 $(&amp;quot;#msg&amp;quot;).css(&amp;quot;background&amp;quot;); //返回元素的背景颜色 $(&amp;quot;#msg&amp;quot;).css(&amp;quot;background&amp;quot;,&amp;quot;#ccc&amp;quot;) //设定元素背景为灰色 $(&amp;quot;#msg&amp;quot;).height(300); $(&amp;quot;#msg&amp;quot;).width(&amp;quot;200&amp;quot;); //设定宽高 $(&amp;quot;#msg&amp;quot;).css({ color: &amp;quot;red&amp;quot;, background: &amp;quot;blue&amp;quot; });//以名值对的形式设定样式 $(&amp;quot;p&amp;quot;).attr(&amp;quot;class&amp;quot;, &amp;quot;ddiiyy&amp;quot;); //设置p元素的class为 &amp;quot;ddiiyy&amp;quot; $(&amp;quot;#nm_p&amp;quot;).addClass(&amp;quot;another&amp;quot;); // 追加样式 $(&amp;quot;p&amp;quot;).removeClass(&amp;quot;ddiiyy another&amp;quot;); //溢出样式 $(&amp;quot;p&amp;quot;).toggleClass(&amp;quot;ddiiyy&amp;quot;); //如果存在（不存在）就删除（添加）名为ddiiyy的class $(&amp;quot;p&amp;quot;).hasClass(&amp;quot;another&amp;quot;); //是否含有某个class。是返true，否返false $(&amp;quot;p&amp;quot;).is(&amp;quot;.another&amp;quot;); //is(&amp;quot;.&amp;quot;+class);//JQuery实现，增强代码可读性   readonly和disabled 表单中readOnly和disabled的区别：
readonly只针对input(text/ password)和textarea有效，而disabled对于所有的表单元素都有效，包括select,radio, checkbox, button等。
但是表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去（这种情况出现在我们将某个表单中的textarea元素设置为disabled或readonly，但是submit或button却是可以使用的）。
 隐藏和显示(操作display属性) $(&amp;quot;#id&amp;quot;).show();//表示display:block, $(&amp;quot;#id&amp;quot;).hide();//表示display:none; $(&amp;quot;#id&amp;quot;).toggle();//切换元素的可见状态。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。 $(&amp;quot;#id&amp;quot;).css(&#39;display&#39;,&#39;none&#39;); $(&amp;quot;#id&amp;quot;).css(&#39;display&#39;,&#39;block&#39;); 或 $(&amp;quot;#id&amp;quot;)[0].style.display = &#39;none&#39;;   操作disabled属性 js操作：
function disableElement(element,val){ document.getElementById(element).disabled=val;d }  jQuery进行操作：
//两种方法设置disabled属性 $(&#39;#areaSelect&#39;).attr(&amp;quot;disabled&amp;quot;,true); $(&#39;#areaSelect&#39;).attr(&amp;quot;disabled&amp;quot;,&amp;quot;disabled&amp;quot;); //三种方法移除disabled属性 $(&#39;#areaSelect&#39;).attr(&amp;quot;disabled&amp;quot;,false); $(&#39;#areaSelect&#39;).removeAttr(&amp;quot;disabled&amp;quot;); $(&#39;#areaSelect&#39;).attr(&amp;quot;disabled&amp;quot;,&amp;quot;&amp;quot;);  获取s:textfield，并设置其disabled属性：
functiondisableTextfieldofAccountDiv(element,val) { $(element).</description>
    </item>
    
    <item>
      <title>Java笔记之基础篇</title>
      <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <description>Java基础笔记整理
关键字  用于定义数据类型  class interface 【引用数据类型：类、接口、数组】 boolean(1) char(2) byte(1) short(2) int(4) long(8) float(4) double(8) 【8个内置数据类型】
类型转换：
byte→short→int→→(可能丢失精度)float→→(可能丢失精度)long→→(可能丢失精度)double
char→int
int→long
int→double
float→double void   用于定义数据类型值  true false null   用于定义流程控制   if else switch case default【选择】
【switch jdk5前：case byte\short\int\char。jdk5：case：enum。jdk7：case String】
  while do for【循环】
  break continue return【流程跳转】
直接for循环效率最高，其次是迭代器和 ForEach操作。作为语法糖，ForEach底层是使用迭代器实现，反编译后testForEach方法如下，可以看到，只比迭代器遍历多了生成中间变量这一步，因为性能也略微下降了一些。
public static void testForEach(List list) { for (Iterator iterator = list.iterator(); iterator.hasNext();) { Object t = iterator.</description>
    </item>
    
    <item>
      <title>Java笔记之web篇</title>
      <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bweb%E7%AF%87/</link>
      <pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bweb%E7%AF%87/</guid>
      <description>JavaWeb笔记整理
XML XML(EXtensible Markup Language):可扩展标记型语言，主要是为了存储数据（程序配置文件）、数据交换
格式：&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
XML两种文档约束类型： dtd （file_name.dtd）和schema（file_name.xsd 可被XML解析器解析）
XML存储结构化信息，使用DOM或SAX（边读边解析）方式解析
Properties存储平面信息，使用Properties类解析
常见的XML解析器实现：JDOM、DOM4J（首选）、SAX
XPath:XML路径语言，用来确定XML文档中某部分位置
Web服务器 Tomcat（Apache）、JBOSS（Redhat）、WebLogic（Oracle）、WebSphere（IBM）等等
JavaWeb三大组件  Servlet Filter Listener  Servlet Servlet是多线程、单实例。
继承关系：MyServlet &amp;ndash;extends&amp;ndash;&amp;gt; HttpServlet &amp;ndash;extends&amp;ndash;&amp;gt; QenericServlet &amp;ndash;implements&amp;ndash;&amp;gt; Servlet、ServletConfig
Servlet生命周期  初始化：服务器在Servlet第一次被访问时或在服务器启动时创建Servlet。创建后，调用init()方法； 提供服务：当服务器每次接收到请求时，会调用service()方法处理请求； 销毁：当服务器关闭时，服务器会去销毁Servlet。销毁前会调用destroy()方法。  在web.xml中配置 ... &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;myServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;com.ianeiu.web.MyServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;!-- 通过ServletConfig获取 --&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;key&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;value&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!-- 值越小，优先级越大 --&amp;gt; &amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;myServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattren&amp;gt;/my/*&amp;lt;/url-pattren&amp;gt; &amp;lt;/servlet-mapping&amp;gt; ... 访问路径可以使用通配符 * /* /myName/* *.doHttpServlet 实现了service(..,..),重写service(HttpServletRequest ..,HttpServletResponse &amp;hellip;),子类只需调用doGet() doPost()。</description>
    </item>
    
    <item>
      <title>TCP与UDP笔记</title>
      <link>https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/</guid>
      <description>tcp/ip协议 TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。
 数据链路层负责帧数据的传递; 网络层责数据怎样传递过去; 传输层负责传输数据的控制（准确性、安全性）; 应用层负责数据的展示和获取。  物理层： 为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。
TCP协议  Transmission Control Protocol，传输控制协议 面向连接的协议 需要三次握手建立连接 需要四次挥手断开连接 TCP报头最小长度：20字节  TCP与UDP 面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。 面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。
TCP与UDP的区别 1、基于连接与无连接;
2、TCP要求系统资源较多，UDP较少; 3、UDP程序结构较简单;
4、流模式（TCP）与数据报模式(UDP);
5、TCP保证数据正确性，UDP可能丢包;
6、TCP保证数据顺序，UDP不保证。
三次握手的过程  客户端发送：SYN = 1, SEQ = X, 端口号 服务器回复：SYN = 1, ACK = X + 1, SEQ = Y 客户端发送：ACK = Y + 1, SEQ = X + 1   确认应答信号ACK = 收到的SEQ + 1。连接建立中，同步信号SYN始终为1。连接建立后，同步信号SYN=0。
 Tcp建立连接的过程</description>
    </item>
    
    <item>
      <title>计算机网络基础汇总</title>
      <link>https://ianeiu.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</link>
      <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</guid>
      <description>计算机网络体系分类： 计算机网络整个体系有两个大的分类：一个是国际组织制定的OSI七层模型，一种是实际使用中的TCP/IP四层模型。
   OSI七层模型 TCP/IP四层模型     应用层    表示层 应用层   会话层    传输层 传输层   网络层 网络层   数据链路层 物理接入层   物理层     物理层： 物理层主要是实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。
通信方式：   **单工通信：**只能由A主机向B主机发送消息，通信是单向的。
  **半双工通信：**同一时间只能是由A主机向B主机或者是B主机向A主机发送信息，不能同时发送消息。
  全双工通信： A主机和B主机可以实现在同一时间内既接收消息，又发送消息，极大的提升了通信效率。
  常见引导型传输媒体： 双绞线： 分为屏蔽双绞线（STP）和非屏蔽双绞线（UTP），屏蔽双绞线就是在非屏蔽双绞线外边又加了一层屏蔽层
tips：为什么双绞线要两根线绞起来，两个线绞起来可以有效的减少相互之间的电磁干扰。
同轴电缆： 由内导体铜制芯线，绝缘层，网状编织的外导体屏蔽层，以及塑料保护外层组成。有良好的抗干扰性，被广泛用于较高速率的传输。
光缆： 由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通讯柱。可以分为单模光纤和多模光纤。
信道复用技术：   **频分复用：**根据传输的波的频率的不同，将不同频段的波用于不同的通信。
  时分复用：将时间分割为时间段，规定在某个时间段内发送什么样的信息，根据时间段来进行信息类别的区分。也称为同步时分复用</description>
    </item>
    
    <item>
      <title>Java面试之基础题（Integer、String、内部类与final）</title>
      <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%A2%98integerstring%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8Efinal/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%A2%98integerstring%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8Efinal/</guid>
      <description>Integer Integer a = 1000,b=1000; Integer c = 100,d=100; @Test public void testIntegerDD(){ System.out.println(a==b);//false System.out.println(c==d);//true }  运行代码，我们会得到 false true。这道题笔试用经常出现，原理也很简单 ,可看Integer源码valueOf(int i)方法
public static Integer valueOf(int i) { if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } Integer 的缓存范围虽然默认是 -128 到 127，但是在特别的应用场景，比如我们明确知道应用会频繁使用更大的数值，这时候应该怎么办呢？
缓存上限值实际是可以根据需要调整的，JVM 提供了参数设置：
-XX:AutoBoxCacheMax=N
接下来，简单的扩展几个Integer的关系运算符==的比较。
@Test public void testIntegerDD(){ Integer a = 1000,b=1000; Integer c = 100,d=100; Integer e = new Integer(100); Integer f = new Integer(100); int g = 1000; Integer h = new Integer(1000);	//1、进行自动装箱操作；2、Integer中把-128-127 缓存了下来 System.</description>
    </item>
    
    <item>
      <title>SpringBoot初体验</title>
      <link>https://ianeiu.github.io/p/springboot%E5%88%9D%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Thu, 01 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/springboot%E5%88%9D%E4%BD%93%E9%AA%8C/</guid>
      <description>如非说明，皆是使用1.5
 本文只进行简单的代码提示，具体内容可自行百度
CXF @Beanpublic ServletRegistrationBean CXFServlet() {ServletRegistrationBean cxfBean = new ServletRegistrationBean(new CXFServlet(), &amp;quot;/webservice/*&amp;quot;);cxfBean.setName(&amp;quot;CXFServlet&amp;quot;);cxfBean.setLoadOnStartup(1);return cxfBean;}@Configurationpublic class CXFConfig {@Autowiredprivate Bus bus;@Autowiredprivate SSOService sSOService;@Beanpublic Endpoint endpointSSO() {EndpointImpl endpoint = new EndpointImpl(bus, sSOService);endpoint.publish(&amp;quot;/sso&amp;quot;);return endpoint;}} 错误页面配置 /*** 跳转至错误页面* add 2018.07.11* @author wm* @param code* @return*/@RequestMapping(&amp;quot;/error/{code}&amp;quot;)public String goToErrorPage(@PathVariable(value=&amp;quot;code&amp;quot;) String code){return code;} 新增拦截器：</description>
    </item>
    
    <item>
      <title>Spring拦截器</title>
      <link>https://ianeiu.github.io/p/spring%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/spring%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>前言 接到一个需求，将已开发完成的系统接入权限系统。其中需要在多处请求返回的ModelAndView中添加权限代码集合，方便显示层做菜单按钮的显示控制。所以当时想法是新建一个拦截器对这几个请求做统一处理（放入权限代码集合），类似之前项目的错误页面拦截器。
拦截器简介 Spring 框架实现拦截器功能主要有两种方法，第一种是实现HandlerInterceptor接口，第二种是实现WebRequestInterceptor接口。
HandlerInterceptor接口通过实现HandlerInterceptor接口，重写方法preHandle()、postHandle()和afterCompletion()拦截请求。Spring 框架中还提供了另外一个接口和一个抽象类，实现了对HandlerInterceptor接口的功能扩展，分别为：AsyncHandlerInterceptor和HandlerInterceptorAdapter。
对于AsyncHandlerInterceptor接口，其在继承HandlerInterceptor接口的同时，又声明了一个新的方法afterConcurrentHandlingStarted()；
而HandlerInterceptorAdapter抽象类，在其继承AsyncHandlerInterceptor接口的同时，又复写了preHandle方法。
 preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)方法，该方法在请求处理之前进行调用。SpringMVC 中的 Interceptor 是链式调用的，在一个应用中或者说是在一个请求中可以同时存在多个 Interceptor 。每个 Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是 Interceptor 中的 preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求做一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值 Boolean 类型的，当它返回为 false 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 true 时，就会继续调用下一个 Interceptor 的 preHandle 方法，如果已经是最后一个 Interceptor 的时候，就会是调用当前请求的 Controller 中的方法。 postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)方法，通过 preHandle 方法的解释咱们知道这个方法包括后面要说到的 afterCompletion 方法都只能在当前所属的 Interceptor 的 preHandle 方法的返回值为 true 的时候，才能被调用。postHandle 方法在当前请求进行处理之后，也就是在 Controller 中的方法调用之后执行，但是它会在 DispatcherServlet 进行视图返回渲染之前被调用，所以咱们可以在这个方法中对 Controller 处理之后的 ModelAndView 对象进行操作。postHandle 方法被调用的方向跟 preHandle 是相反的，也就是说，先声明的 Interceptor 的 postHandle 方法反而会后执行。这和 Struts2 里面的 Interceptor 的执行过程有点类型，Struts2 里面的 Interceptor 的执行过程也是链式的，只是在 Struts2 里面需要手动调用 ActionInvocation 的 invoke 方法来触发对下一个 Interceptor 或者是 action 的调用，然后每一个 Interceptor 中在 invoke 方法调用之前的内容都是按照声明顺序执行的，而 invoke 方法之后的内容就是反向的。 afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)方法，也是需要当前对应的 Interceptor 的 preHandle 方法的返回值为 true 时才会执行。因此，该方法将在整个请求结束之后，也就是在 DispatcherServlet 渲染了对应的视图之后执行，这个方法的主要作用是用于进行资源清理的工作。  WebRequestInterceptor接口在WebRequestInterceptor接口中也定义了 3 个方法，方法名同HandlerInterceptor接口相同，3 个方法都传递了同一个参数 WebRequest。WebRequest 是 Spring 中定义的一个接口，它里面的方法定义跟 HttpServletRequest 类似，在WebRequestInterceptor中对 WebRequest 进行的所有操作都将同步到 HttpServletRequest 中，然后在当前请求中依次传递。</description>
    </item>
    
    <item>
      <title>JVM笔记之JVM类加载机制</title>
      <link>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
      <description>虚拟机类加载机制 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换（准备）、解析和初始化，最终形成可以被Java虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
类从被加载到虚拟内存中开始，到卸载内存为止，它的整个生命周期包括了：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)七个阶段。
其中，验证，准备和解析三个部分统称为连接(Linking)。
 类加载的过程 类加载的全过程，加载，验证，准备，解析和初始化这五个阶段。
加载 在加载阶段，虚拟机需要完成以下三件事情：
 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口  Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等
验证 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能有所不同，但大致上都会完成下面四个阶段的检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。
 文件格式验证 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 元数据验证 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。 字节码验证 整个验证过程中最复杂的一个阶段，主要工作是数据流和控制流的分析。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。 符号引用验证 发生在虚拟机将符号引用直接转化为直接引用的时候，这个转化动作将在连接的第三个阶段－解析阶段产生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验。  准备 正式为类变量分配内存并设置类变量初始值的阶段（创建类或接口中的静态变量，并初始化静态变量的初始值），这些内存都将在方法区进行分配。
解析 解析阶段是虚拟机将常量池的符号引用转换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。
初始化 前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由Java虚拟机主导和控制。
到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。 在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者说初始化阶段是执行类构造器()方法的过程。
真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。
 准备阶段 常量和不同静态变量有什么区别 public class CLPreparation { public static int a = 100; public static final int INT_CONSTANT = 1000; public static final Integer INTEGER_CONSTANT = Integer.</description>
    </item>
    
    <item>
      <title>JVM笔记之引用、GC及OOM</title>
      <link>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%95%E7%94%A8gc%E5%8F%8Aoom/</link>
      <pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%95%E7%94%A8gc%E5%8F%8Aoom/</guid>
      <description>强引用、软引用、弱引用和虚引用 强引用（Strong Reference）只有这个引用被释放之后，对象才会被释放掉。只要引用存在，垃圾回收器永远不会回收。
我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。
当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。
对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了， 具体回收时机还是要看垃圾收集策略。
软引用（Soft Reference）内存溢出之前通过代码回收的引用。 通常用来实现内存敏感的缓存（图片缓存框架中，“内存缓存”中的图片是以这种引用来保存）。
软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度； 当内存不足时，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象，自动删除这部分缓存数据，从真正的来源查询这些数据。
弱引用（Weak Reference）第二次垃圾回收时回收的引用，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。 同样可用于内存敏感的缓存（在静态内部类中，经常会使用虚引用。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏） 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。
虚引用（Phantom Reference) 又称幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例的任何属性或函数。
可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。
当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。
虚引用和软引用弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有
Java内存回收机制 不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。
Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。
在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，另一个是给对象赋予了新值，这样重新分配了内存空间。
GC算法分类  引用计数法(没有被java采⽤用) 标记清除法（通过根节点标记所有从根节点开始的可达对象，清除没标记过的对象，标记和清除两个过程效率不高，产生内存碎⽚） 标记压缩法（压缩：将所有存活对象压缩到内存的一端，清除边界外所有的空间） 复制回收算法 分代回收法（根据对象存活周期的不同将内存划分几块，一般是新生代和老年代，新⽣代基本采用复制算法，老年代采⽤用标记清除算法。  MinorGC &amp;amp; FullGC  Minor GC通常发生在新生代的Eden区，一般采用复制回收算法（对象生存期短，发生GC的频率较高，回收速度比较快）。 Full GC/Major GC 发生在老年代，所采用的是标记清除算法。  内存泄漏 内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示Out of memory。
Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：
1、静态集合类引起内存泄漏
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。
static Vector v = new Vector(10); for (int i = 1; i&amp;lt;100; i++){ Object o = new Object(); v.</description>
    </item>
    
    <item>
      <title>Http笔记</title>
      <link>https://ianeiu.github.io/p/http%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 29 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/http%E7%AC%94%E8%AE%B0/</guid>
      <description>浏览器输入URL到返回页面的过程  根据域名，进行DNS域名解析 拿到解析的IP地址，建立TCP连接 向IP地址发送HTTP请求 服务器处理请求 返回响应结果 关闭TCP连接 浏览器解析HTML 浏览器布局渲染  简介 HTTP即超文本传输协议（HTTP，Hyper Text Transport Protocol）。HTTP协议默认监听80端口，主要用于描述请求和响应的数据格式。
版本  0.9　已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。 HTTP/1.0　建立连接后只能请求响应一次 HTTP/1.1　持久连接（可以进行多次请求和响应）被默认采用，能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度  维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求   刷新页面不需要重新建立 SSL 连接   和服务器建立多个 TCP 连接 Pipelining 实现同一时刻只能处理一个请求  浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的 一些代理服务器不能正确的处理 HTTP Pipelining Head-of-line Blocking 连接头阻塞     HTTP/2 多个 HTTP 请求可以在同一个 TCP 连接中并行进行（Multiplexing ）  浏览器对同一 Host 建立 TCP 连接到数量有没有限制 有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。</description>
    </item>
    
    <item>
      <title>Java笔记之名词简介</title>
      <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 29 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E7%AE%80%E4%BB%8B/</guid>
      <description>web容器 给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。
EJB容器 Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。
 JDBC 用来访问数据库的API（规范）
JNDI：（Java Naming &amp;amp; Directory Interface） JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。
JMS：（Java Message Service） JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。
JTA：（Java Transaction API） JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。
JAF：（Java Action FrameWork） JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。
RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议） 他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。
JSP Jsp页面由HTML和前去其中的Java代码组成，用来实现动态视图
JavaMail JavaMail利用JAF来初拉力MIME编码的邮件附件
 MVC 标准主流现在的编程方式都是采用MVC综合设计模式，MVC本身不属于设计模式的一种，它描述的是一种结构，最终目的达到解耦（更改某一层代码不会影响我其他层代码）。
视图层如jsp调用控制层，控制层action调用业务层service，业务层调用数据dao访问层。
DAO层 DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，DAO层的设计首先是设计DAO的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。
Service层 Service层主要负责业务模块的逻辑应用设计。同样是首先设计接口，再设计其实现的类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。
Controller层 Controller层负责具体的业务模块流程的控制，在此层里面要调用Serice层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。
 VO 即value object值对象。主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象。然后用一个VO对象在控制层与视图层进行传输交换。
DTO Data Transfer Object数据传输对象，经过处理后的PO，可能增加或者减少PO的属性，主要用于远程调用等需要大量传输对象的地方。
POJO POJO（plain ordinary java object）即简单java对象，是一种概念或者接口，身份及作用随环境变化而变化。 它不包含业务逻辑或持久逻辑等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。
 SpringMVC Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。</description>
    </item>
    
    <item>
      <title>Java面试之HashMap</title>
      <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/</guid>
      <description>HashMap（数组+链表）  HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。 当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象。 当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。  
public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i; //1. 如果当前table为空，新建默认大小的table if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //2. 获取当前key对应的节点 if ((p = tab[i = (n - 1) &amp;amp; hash]) == null) //3.</description>
    </item>
    
    <item>
      <title>Mybatis之参数篇</title>
      <link>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E5%8F%82%E6%95%B0%E7%AF%87/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E5%8F%82%E6%95%B0%E7%AF%87/</guid>
      <description>参数传递符号   #{}
  ${}
select * from tbl_employee where id=${id} and last_name=#{userName} Preparing: select * from tbl_employee where id=&amp;lsquo;admin&amp;rsquo; and last_name=?
  区别：
#{}:是以预编译的形式，将参数设置到sql语句中。通过PreparedStatement可防止sql注入。
大多情况下，取参数的值都应该使用#{}。
${}:取出的值直接拼装在sql语句中；会有安全问题；
原生jdbc不支持占位符的地方我们就可以使用${}进行取值，比如分表、排序；按照年份分表拆分
select * from ${year}_salary where xxx; select * from tb_sys_user order by ${f_name} ${order}  #{}更丰富的用法 规定参数的一些规则： javaType、 jdbcType、 mode（存储过程）、 numericScale、resultMap、 typeHandler、 jdbcTypeName、 expression（未来准备支持的功能）；
jdbcType通常需要在某种特定的条件下被设置：在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）； JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不能正确处理;
由于全局配置中：jdbcTypeForNull=OTHER；oracle不支持；有以下两种办法解决：
 #{email,jdbcType=OTHER} jdbcTypeForNull=NULL   参数传递 单个参数 #{参数名/任意名}：取出参数值。
&amp;lt;!-- TbSysUser getUserById(String id); --&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>Mybatis之开发异常篇</title>
      <link>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E5%BC%80%E5%8F%91%E5%BC%82%E5%B8%B8%E7%AF%87/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E5%BC%80%E5%8F%91%E5%BC%82%E5%B8%B8%E7%AF%87/</guid>
      <description>mapped Statements collection does not contain 初次接触使用Mybatis会出现“Mapped Statements collection does not contain value for &amp;hellip;.“错误提示
常见的错误原因有几种：
 mapper.xml中没有加入namespace mapper.xml中的方法和接口mapper的方法不对应 mapper.xml没有加入到mybatis-config.xml中(即总的配置文件)，例外：配置了mapper文件的包路径的除外 mapper.xml文件名和所写的mapper名称不相同。  </description>
    </item>
    
    <item>
      <title>Java开发之常量定义</title>
      <link>https://ianeiu.github.io/p/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89/</guid>
      <description>原文： 如何在Java中定义常量(Constant)
Java中定义常量的四种方法 /** * Method One * 采用接口(Interface)的中变量默认为static final的特性。 */ interface ConstantInterface { String SUNDAY = &amp;#34;SUNDAY&amp;#34;; String MONDAY = &amp;#34;MONDAY&amp;#34;; String TUESDAY = &amp;#34;TUESDAY&amp;#34;; String WEDNESDAY = &amp;#34;WEDNESDAY&amp;#34;; String THURSDAY = &amp;#34;THURSDAY&amp;#34;; String FRIDAY = &amp;#34;FRIDAY&amp;#34;; String SATURDAY = &amp;#34;SATURDAY&amp;#34;; } /** * Method Two * 采用了Java 5.0中引入的Enum类型 (推荐使用) */ enum ConstantEnum { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY } /** * Method Three * 采用了在普通类中使用static final修饰变量的方法 */ class ConstantClassField { public static final String SUNDAY = &amp;#34;SUNDAY&amp;#34;; public static final String MONDAY = &amp;#34;MONDAY&amp;#34;; public static final String TUESDAY = &amp;#34;TUESDAY&amp;#34;; public static final String WEDNESDAY = &amp;#34;WEDNESDAY&amp;#34;; public static final String THURSDAY = &amp;#34;THURSDAY&amp;#34;; public static final String FRIDAY = &amp;#34;FRIDAY&amp;#34;; public static final String SATURDAY = &amp;#34;SATURDAY&amp;#34;; } /** * Method Four * 类似方法三，但是通过函数来获取常量 * http://www.</description>
    </item>
    
    <item>
      <title>Java面试之初中级题集</title>
      <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%88%9D%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%9B%86/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%88%9D%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%9B%86/</guid>
      <description>数组在内存中如何分配  简单的值类型的数组，每个数组成员是一个引用（指针），引用到栈上的空间（因为值类型变量的内存分配在栈上） 引用类型，类类型的数组，每个数组成员仍是一个引用（指针），引用到堆上的空间（因为类的实例的内存分配在堆上）  String的substring()方法内部是如何实现 substring方法通过原字符串创建了一个新的对象。
当为字符串分配内存时，char数组value[]存储字符，offset=0，count=字符串长度。
在Java6里，由substring(start,end)调用构造函数String(int,in,char[])时，实际上是改变offset和count的位置达到取得子字符串的目的，而子字符串里的value[]数组，因为引用是强引用，仍然指向原字符串。
由于String是不可变的(immutable)，基于这种共享同一个字符数组的设计有以下好处： 调用substring()时无需复制数组，可重用value[]数组；且substring()的运行是常数时间，非线性，性能得到提高；而劣势，便是可能会产生内存泄露。
假设原字符串s有1GB，且我们需要的是s.substring(1,10)这样一段小的字符串，但由于substring()里的value[]数组仍然指向1GB的原字符串，导致原字符串无法在GC中释放，从而产生了内存泄露。
在Java7里，String的substring()方法实现已经改变，由原来的共享数组变成了传统的拷贝，原字符串的字符数组已经不再被引用，杜绝了内存泄露的同时也将运行时间由常数变成了线性，这个改变也使得substring()创建字符串的操作更加耗时，以前的开销是O(1)，现在最坏情况是O(n)。
什么是不可修改对象(Immutable Object) 可修改对象是那些一旦被创建就不能修改的对象。对这种对象的任何改动的后果都是会创建一个新的对象，而不是在原对象本身做修改。
大多数这样的类通常都是final类型的，因为这样可以避免自己被继承继而被覆盖方法。例如Java中的String类。
也可以通过将类的成员设置成private非final的来获得同样的效果。同时类不能通过方法暴露成员，特别是可修改类型的成员。
当类的方法接收客户类传入的可修改对象的话，应该使用一个复制的对象来防止客户代码来修改这个传入的可修改类。比如，传入java.util.Date对象的话，应该使用clone()方法来获得一个副本。
当通过类方法返回一个可修改对象时，需要返回的是类对象的副本，防止客户代码通过此引用修改了成员对象的属性。
什么时候需要重写hashCode()和equals()方法 当你需要根据业务逻辑来进行相等性判断、而不是根据对象相等性来判断的时候你就需要重写这两个函数了。
例如，两个Employee对象相等的依据是它们拥有相同的emp_id，尽管它们有可能是两个不同的对象，并且分别在不同的地方被创建。同时，如果你准备把它们当作HashMap中的key来使用的话，你也必须重写这两个方法。现在，作为Java中equals-hashcode的一个约定，当你重写equals的时候必须也重写hashcode，否则你会打破诸如Set, Map等集合赖以正常工作的约定。
当你向HashMap插入一个key的时候，首先，这个对象的hashCode()方法会被调用，调用结果用来计算将要存储的位置(bucket)。
因为某个位置上可能以链表的方式已经包含了多个Map.Entry对象，所以HashMap会使用equals()方法来将此对象与所有这些Map.Entry所包含的key进行对比，以确定此key对象是否已经存在。
mybatis如何处理结果集 MyBatis的结果集是通过反射来实现的。并不是通过get/set方法。在实体类中无论是否定义get/set()方法，都是可以接收到的。
cookie和session的区别，分布式环境怎么保存用户状态 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。
3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。
4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
分布式环境下的session（举例两种）：
服务器session复制
原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。
优点：可容错，各个服务器间session能够实时响应。
缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。
session共享机制
使用分布式缓存方案比如memcached、redis，但是要求Memcached或Redis必须是集群。
写一段栈溢出、堆溢出的代码 public class Test { //不断创建对象可以导致堆溢出public void testHeap(){ for(;;){ ArrayList list = new ArrayList (2000); } } //递归调用可以导致栈溢出int num=1; public void testStack(){ num++; this.testStack(); } public static void main(String[] args){ Test t = new Test (); t.</description>
    </item>
    
    <item>
      <title>JVM笔记之JVM结构</title>
      <link>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/</guid>
      <description>JVM运行时数据区 运行时数据区（分布在操作系统堆中，由程序员管理）
 方法区 虚拟机栈（Java栈） 堆（Java堆） 本地方法栈/区 程序计数器  JVM结构
虽然这几个区域都是属于运行时数据区，但是这几个区域的创建时机是不一致的，有的是随虚拟机启动而创建的，随虚拟机销毁而销毁；有的是随线程创建而创建，随线程销毁而销毁。
线程独享的区域 程序计数器 程序计数器是来指示当前线程正在执行的JVM指令，因此程序计数器是线程独有的。一个JVM支持多个线程，每一个线程都要自己的程序计数器。
如果线程正在执行的方法是Java方法，则程序计数器保存的是当前线程正在执行的JVM指令，如果正在执行的方法是Native方法，则保存为空（undefined)。
虚拟机栈 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用。每个栈中的数据(原始类型和对象引用)都是私有的。数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失。 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
本地方法区 本地方法区存储着native方法的调用状态，一般会随着线程创建而针对每一个线程分配。
全局共享的区域 方法区 方法区是可供各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量等。当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域。
由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。
运行时常量池 ：方法区的一部分（Java jdk1.7中的常量池是移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域）	，存放着类中固定的常量信息、方法、和field的引用信息。JVM在加载类的时候会为每一个Class分配一个独立的常量池。
堆 JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，存储着所有类实例即类对象和数组对象。对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定
理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。
JVM
JVM 本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT Compiler 在运行时对热点方法进行编译，就会将编译后的方法储存在 Code Cache 里面；GC 等功能需要运行在本地线程之中，类似部分都需要占用内存空间。
JDK 已经发生了很大变化，Intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，Intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。
堆内部结构 堆内部结构
  新生代
新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫from、to 区域，被用来放置从 Minor GC 中保留下来的对象。
JVM 会随意选取一个 Survivor 区域作为“to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 from 区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</description>
    </item>
    
    <item>
      <title>WebService简介</title>
      <link>https://ianeiu.github.io/p/webservice%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 03 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/webservice%E7%AE%80%E4%BB%8B/</guid>
      <description>WebService简介 webService（又名XML Web Service）是一种跨语言跨操作系统的远程调用技术（是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术）。
WebService平台技术 XML+XSD WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的 返回结果是什么）。
XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。
SOAP SOAP是&amp;quot;简单对象访问协议&amp;quot;，是一种简单的、基于HTTP和XML的协议, 用于在WEB上交换结构化的数据。
soap消息：请求消息和响应消息
WSDL WSDL是webservice定义语言, 对应.wsdl文档, 一个webservice会对应一个唯一的wsdl文档, 定义了客户端与服务端发送请求和响应的数据格式和过程。
工作调用原理 对客户端而言，我们给这各类WebService客户端API传递wsdl文件的url地址，这些API就会创建出底层的代理类，我们调用 这些代理，就可以访问到webservice服务。
代理类把客户端的方法调用变成soap格式的请求数据再通过HTTP协议发出去，并把接收到的soap 数据变成返回值返回。
对服务端而言，各类WebService框架的本质就是一个大大的Servlet，当远程调用客户端给它通过http协议发送过来 soap格式的请求数据时，它分析这个数据，就知道要调用哪个java类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成 soap格式的数据，通过http响应消息回给客户端。
相比HTTP（post/get）的优势  接口中实现的方法和要求参数一目了然 不用担心大小写问题 不用担心中文urlencode问题 代码中不用多次声明认证(账号,密码)参数 传递参数可以为数组，对象等  框架简介 JWS JWS是Java语言对WebService服务的一种实现，用来开发和发布服务。而从服务本身的角度来看JWS服务是没有语言界限的。但是Java语言为Java开发者提供便捷发布和调用WebService服务的一种途径。
Axis2 Axis2是从Axis1.x系列发展而来，不过它从底层全部重新实现，使用了新的扩展性更好模块架构。
Axis2是Apache下的一个重量级WebService框架，准确说它是一个Web Services / SOAP / WSDL 的引擎，是WebService框架的集大成者，它能不但能制作和发布WebService，而且可以生成Java和其他语言版WebService客户端和服务端代码。这是它的优势所在。但是，这也不可避免的导致了Axis2的复杂性，使用过的开发者都知道，它所依赖的包数量和大小都是很惊人的，打包部署发布都比较麻烦，不能很好的与现有应用整合为一体。但是如果你要开发Java之外别的语言客户端，Axis2提供的丰富工具将是你不二的选择。
XFire XFire是一个高性能的WebService框架，它的响应时间是Axis1.3的1/2到1/5，在Java6之前，它的知名度甚至超过了Apache的Axis2，XFire的优点是开发方便，与现有的Web整合很好，可以融为一体，并且开发也很方便。但是对Java之外的语言，没有提供相关的代码工具。XFire后来被Apache收购了，原因是它太优秀了，收购后，随着Java6 JWS的兴起，开源的WebService引擎已经不再被看好，渐渐的都败落了。现在估计只有老旧项目还在使用。
CXF CXF是Apache旗下一个重磅的SOA简易框架，它实现了ESB（企业服务总线），支持可集成spring。CXF是XFire和Celtix项目的结合产品，是XFire经过改造后形成的，就像目前的Struts2来自WebWork一样。可以看出XFire的命运会和WebWork的命运一样，最终会淡出人们的视线。CXF不但是一个优秀的Web Services / SOAP / WSDL 引擎，也是一个不错的ESB总线，为SOA的实施提供了一种选择方案，当然他不是最好的，它仅仅实现了SOA架构的一部分。
Axis2与CXF比较  通用结构WS-Policy等，数据并对XMLBeans等，Axis2与CXF后面的几个版本基本都支持了，差别不大。 CXF可以很好支持Spring。Axis2不能 Axis2支持多语言-除了Java,他还支持C/C++版本。  从开发者的角度，两个框架的特性相当的不同。
Axis2的开发方式类似一个小型的应用服务器，Axis2的开发包要以WAR的形式部署到Servlet容器中，比如Tomcat，通过这些容器可以对工作中的Web Service进行很好的监控和管理。Axis2的Web administrion模块可以让我们动态的配置Axis2.一个新的服务可以上载，激活，使之失效，修改web服务的参数。管理UI也可以管理一个或者多个处于运行状态的服务。这种界面化管理方式的一个弊端是所有在运行时修改的参数没有办法保存，因为在重启动之后，你所做的修改就会全部失效。Axis2允许自己作为独立的应用来发布Web Service，并提供了大量的功能和一个很好的模型，这个模型可以通过它本身的架构（modular architecture）不断添加新的功能。有些开发人员认为这种方式对于他们的需求太过于繁琐。这些开发人员会更喜欢CXF。
CXF更注重开发人员的工效（ergonomics）和嵌入能力（embeddability）。大多数配置都可以API来完成，替代了比较繁琐的XML配置文件， Spring的集成性经常的被提及，CXF支持Spring2.</description>
    </item>
    
    <item>
      <title>SpringMVC的运行流程及九大组件</title>
      <link>https://ianeiu.github.io/p/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Thu, 30 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/</guid>
      <description>运行流程 
 用户发送请求至前置控制器DispatcherServlet DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 执行处理器/后端控制器Controller Controller执行完成返回ModelAndView HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet DispatcherServlet将ModelAndView传给视图解析器ViewReslover ViewReslover解析后返回具体View DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet响应用户。  从上面可以看出，DispatcherServlet有接收请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度。
九大组件 HandlerMapping 处理器映射器:根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet
HandlerAdapter 适配器。因为SpringMVC中的Handler可以是任意的形式,但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。HandlerAdapter的作用就是让固定的Servlet处理方法调用Handler（Controller）来进行处理。
有篇文章总结的很好：Handler是用来干活的工具；HandlerMapping用于根据需要干的活找到相应的工具；HandlerAdapter是使用工具干活的人。
HandlerExceptionResolver 异常处理:自定义异常处理类继承此类或其子类，实现resolveException方法。如下：
@Component public class GlobalExceptionResolver implements HandlerExceptionResolver { ... /** * 针对请求处理异常 */ @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { boolean isHttpApi = isHttpApi(handler); HandleResult result = handleException(ex); if (isReturnReponseBody(handler) || isHttpApi) { if(isHttpApi){ result = apiHandleException(ex); } ModelAndView modelAndView = new ModelAndView(); //处理异常 response.</description>
    </item>
    
    <item>
      <title>常见状态码简介</title>
      <link>https://ianeiu.github.io/p/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 23 Aug 2018 16:01:23 +0800</pubDate>
      
      <guid>https://ianeiu.github.io/p/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E4%BB%8B/</guid>
      <description>部分状态码简介 200  200—请求成功 202—常用于异步请求。客户端发送请求到服务器，服务器立即返回一个202 Accepted表示已经成功接收到客户端的请求。后面怎么处理由服务器自己决定，一般服务器会给客户端预留一个可以查询处理状态的接口，客户端可以选择轮训该接口来知道请求的处理进度和结果。  30X  301—永久移动。被请求的资源已被永久移动位置 302—请求的资源现在临时从不同的 URI 响应请求（请求重定向） 305—使用代理。被请求的资源必须通过指定的代理才能被访问 304—请求资源没有改变 307—临时跳转。被请求的资源在临时从不同的URL响应请求  4XX  400—错误请求 402—需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付 403—禁止访问。服务器已经理解请求，但是拒绝执行它 404—找不到对象。请求失败，资源不存在 406—不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体 408—请求超时 409—冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成 410—遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址 413—响应实体太大(客户端上传图片太大等情况)。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值 414—客户端访问的URI太长，超出了服务器允许限制 417—期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足 418—我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现 420—方法失效 422—不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应  500  500—服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理  </description>
    </item>
    
    <item>
      <title>Java笔记之常见的RuntimeException</title>
      <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84runtimeexception/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84runtimeexception/</guid>
      <description>RuntimeException 运行时异常，是所有Java虚拟机正常操作期间可以被抛出的异常的父类。
 NumberFormatException - 数字格式异常 NullPointerException - 空指针引用异常 ClassCastException - 类型强制转换异常。 IllegalArgumentException - 传递非法参数异常。 ArithmeticException - 算术运算异常 ArrayStoreException - 向数组中存放与声明类型不兼容对象异常 IndexOutOfBoundsException - 下标越界异常 NegativeArraySizeException - 创建一个大小为负数的数组错误异常 UnsupportedOperationException - 不支持的方法异常。指明请求的方法不被支持情况的异常 EnumConstantNotPresentException - 枚举常量不存在异常。当应用试图通过名称和枚举类型访问一个枚举对象，但该枚举对象并不包含常量时，抛出该异常。 IllegalMonitorStateException - 违法的监控状态异常。当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常。 IllegalStateException - 违法的状态异常。当在Java环境和应用尚未处于某个方法的合法调用状态，而调用了该方法时，抛出该异常。 NegativeArraySizeException - 数组大小为负值异常。当使用负数大小值创建数组时抛出该异常。 SecurityException 安全异常。由安全管理器抛出，用于指示违反安全情况的异常。 TypeNotPresentException - 类型不存在异常。当应用试图以某个类型名称的字符串表达方式访问该类型，但是根据给定的名称又找不到该类型是抛出该异常。该异常与ClassNotFoundException的区别在于该异常是unchecked（不被检查）异常，而ClassNotFoundException是checked（被检查）异常。  </description>
    </item>
    
    <item>
      <title>兼容IE的代码片段</title>
      <link>https://ianeiu.github.io/p/%E5%85%BC%E5%AE%B9ie%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/%E5%85%BC%E5%AE%B9ie%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</guid>
      <description>JS  方法/函数：减少使用JS原生方法  indexOf。可用jquery里的$.inArray替代indexOf。 具体使用：$.inArray(“a”, divarr)==-1  AJAX：  上传文件：IE下ajaxSubmit将file对象传递到控制层，建议使用ajaxFileUpload。
有些方法调用获取数据是直接读缓存的，这时候加个属性 cache:false 即可。  DOM：  复选框赋值兼容问题：
for(var k =0; k&amp;lt;number.length; k++){
//$(&amp;quot;:checkbox[name=&amp;lsquo;tCheckTwo&amp;rsquo;][value=&#39;&amp;quot;+number[k]+&amp;quot;&#39;]&amp;quot;).attr(&amp;ldquo;checked&amp;rdquo;, true);
//解决ie8的复选框赋值兼容问题。eq的是索引
$(&amp;quot;:checkbox[name=&amp;lsquo;tCheckTwo&amp;rsquo;]&amp;quot;).eq(number[k]).attr(&amp;ldquo;checked&amp;rdquo;, true);
};  CSS  IE支持rgba半透明的方法： 低版本IE下不支持rgba()的表示方法， 如：background:rgba(0,0,0,0.5);
使用代码,filter:progid:DXImageTransform.Microsoft.gradient(startcolorstr=#7F000000,endcolorstr=#7F000000);即可实现
7F其实就是alpha*255换成16进制 。常用的rgba和IE下filter数值的转换：
rgba透明值：0.1　0.2　0.3　0.4　0.5　0.6　0.7　0.8　0.9
IE下filter值：19　33　4c　66　7f　99　b2　c8　e5
HTML  隐藏元素： &amp;lt;div class=&amp;quot;bBox&amp;quot; id=&amp;quot;orderOperDiv&amp;quot; style=&amp;quot;display: none;&amp;quot;&amp;gt;&amp;lt;!-- 兼容IE，不使用hidden --&amp;gt;  按钮value显示null &amp;lt;!-- &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;上传&amp;quot; class=&amp;quot;sBtn&amp;quot; onclick=&amp;quot;uploadDataFile(1,0);&amp;quot; /&amp;gt; --&amp;gt; &amp;lt;a href=&amp;quot;javascript:void(0);&amp;quot; class=&amp;quot;sBtn&amp;quot; onclick=&amp;quot;uploadDataFile(1,0)&amp;quot;&amp;gt;上传&amp;lt;/a&amp;gt;  插件  Webuploader IE浏览器兼容问题（点击无反应） webuploader 加载后会默认先使用H5，在浏览器不支持H5,再采用flash,方式上传。</description>
    </item>
    
  </channel>
</rss>
