<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IanEiU</title>
    <link>https://ianeiu.github.io/</link>
    <description>Recent content on IanEiU</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>WuWeiMian</copyright>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://ianeiu.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://ianeiu.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://ianeiu.github.io/about/</guid>
      
        <description>

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;一名Java渣渣、LOL&lt;del&gt;黄金&lt;/del&gt;白银段位&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;邮箱：weimianwu@foxmail.com&lt;/li&gt;
&lt;li&gt;微信：qq747151921&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;友链&#34;&gt;友链&lt;/h3&gt;

&lt;p&gt;木有&lt;/p&gt;

&lt;hr /&gt;
</description>
      
    </item>
    
    <item>
      <title>侃侃而谈——WebService及框架简介</title>
      <link>https://ianeiu.github.io/2018/09/03/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88webservice%E5%8F%8A%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 03 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/09/03/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88webservice%E5%8F%8A%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</guid>
      
        <description>

&lt;h1 id=&#34;webservice简介&#34;&gt;WebService简介&lt;/h1&gt;

&lt;p&gt;webService（又名XML Web Service）是一种跨语言跨操作系统的远程调用技术（是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术）。&lt;/p&gt;

&lt;h3 id=&#34;webservice平台技术&#34;&gt;WebService平台技术&lt;/h3&gt;

&lt;h4 id=&#34;xml-xsd&#34;&gt;XML+XSD&lt;/h4&gt;

&lt;p&gt;WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的 返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。&lt;/p&gt;

&lt;h4 id=&#34;soap&#34;&gt;SOAP&lt;/h4&gt;

&lt;p&gt;SOAP是&amp;rdquo;简单对象访问协议&amp;rdquo;，是一种简单的、基于HTTP和XML的协议, 用于在WEB上交换结构化的数据。&lt;br /&gt;
soap消息：请求消息和响应消息&lt;/p&gt;

&lt;h4 id=&#34;wsdl&#34;&gt;WSDL&lt;/h4&gt;

&lt;p&gt;WSDL是webservice定义语言, 对应.wsdl文档, 一个webservice会对应一个唯一的wsdl文档, 定义了客户端与服务端发送请求和响应的数据格式和过程。&lt;/p&gt;

&lt;h3 id=&#34;工作调用原理&#34;&gt;工作调用原理&lt;/h3&gt;

&lt;p&gt;对客户端而言，我们给这各类WebService客户端API传递wsdl文件的url地址，这些API就会创建出底层的代理类，我们调用 这些代理，就可以访问到webservice服务。&lt;/p&gt;

&lt;p&gt;代理类把客户端的方法调用变成soap格式的请求数据再通过HTTP协议发出去，并把接收到的soap 数据变成返回值返回。&lt;/p&gt;

&lt;p&gt;对服务端而言，各类WebService框架的本质就是一个大大的Servlet，当远程调用客户端给它通过http协议发送过来 soap格式的请求数据时，它分析这个数据，就知道要调用哪个java类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成 soap格式的数据，通过http响应消息回给客户端。&lt;/p&gt;

&lt;h1 id=&#34;框架简介&#34;&gt;框架简介&lt;/h1&gt;

&lt;h3 id=&#34;jws&#34;&gt;JWS&lt;/h3&gt;

&lt;p&gt;JWS是Java语言对WebService服务的一种实现，用来开发和发布服务。而从服务本身的角度来看JWS服务是没有语言界限的。但是Java语言为Java开发者提供便捷发布和调用WebService服务的一种途径。&lt;/p&gt;

&lt;h3 id=&#34;axis2&#34;&gt;Axis2&lt;/h3&gt;

&lt;p&gt;Axis2是从Axis1.x系列发展而来，不过它从底层全部重新实现，使用了新的扩展性更好模块架构。&lt;/p&gt;

&lt;p&gt;Axis2是Apache下的一个重量级WebService框架，准确说它是一个Web Services / SOAP / WSDL 的引擎，是WebService框架的集大成者，它能不但能制作和发布WebService，而且可以生成Java和其他语言版WebService客户端和服务端代码。这是它的优势所在。但是，这也不可避免的导致了Axis2的复杂性，使用过的开发者都知道，它所依赖的包数量和大小都是很惊人的，打包部署发布都比较麻烦，不能很好的与现有应用整合为一体。但是如果你要开发Java之外别的语言客户端，Axis2提供的丰富工具将是你不二的选择。&lt;/p&gt;

&lt;h3 id=&#34;xfire&#34;&gt;XFire&lt;/h3&gt;

&lt;p&gt;XFire是一个高性能的WebService框架，它的响应时间是Axis1.3的1/2到1/5，在Java6之前，它的知名度甚至超过了Apache的Axis2，XFire的优点是开发方便，与现有的Web整合很好，可以融为一体，并且开发也很方便。但是对Java之外的语言，没有提供相关的代码工具。XFire后来被Apache收购了，原因是它太优秀了，收购后，随着Java6 JWS的兴起，开源的WebService引擎已经不再被看好，渐渐的都败落了。现在估计只有老旧项目还在使用。&lt;/p&gt;

&lt;h3 id=&#34;cxf&#34;&gt;CXF&lt;/h3&gt;

&lt;p&gt;CXF是Apache旗下一个重磅的SOA简易框架，它实现了ESB（企业服务总线），支持可集成spring。CXF是XFire和Celtix项目的结合产品，是XFire经过改造后形成的，就像目前的Struts2来自WebWork一样。可以看出XFire的命运会和WebWork的命运一样，最终会淡出人们的视线。CXF不但是一个优秀的Web Services / SOAP / WSDL 引擎，也是一个不错的ESB总线，为SOA的实施提供了一种选择方案，当然他不是最好的，它仅仅实现了SOA架构的一部分。&lt;/p&gt;

&lt;h3 id=&#34;axis2与cxf比较&#34;&gt;Axis2与CXF比较&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;通用结构WS-Policy等，数据并对XMLBeans等，Axis2与CXF后面的几个版本基本都支持了，差别不大。&lt;/li&gt;
&lt;li&gt;CXF可以很好支持Spring。Axis2不能&lt;/li&gt;
&lt;li&gt;Axis2支持多语言-除了Java,他还支持C/C++版本。
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从开发者的角度，两个框架的特性相当的不同。&lt;br /&gt;
Axis2的开发方式类似一个小型的应用服务器，Axis2的开发包要以WAR的形式部署到Servlet容器中，比如Tomcat，通过这些容器可以对工作中的Web Service进行很好的监控和管理。Axis2的Web administrion模块可以让我们动态的配置Axis2.一个新的服务可以上载，激活，使之失效，修改web服务的参数。管理UI也可以管理一个或者多个处于运行状态的服务。这种界面化管理方式的一个弊端是所有在运行时修改的参数没有办法保存，因为在重启动之后，你所做的修改就会全部失效。Axis2允许自己作为独立的应用来发布Web Service，并提供了大量的功能和一个很好的模型，这个模型可以通过它本身的架构（modular architecture）不断添加新的功能。有些开发人员认为这种方式对于他们的需求太过于繁琐。这些开发人员会更喜欢CXF。&lt;br /&gt;
CXF更注重开发人员的工效（ergonomics）和嵌入能力（embeddability）。大多数配置都可以API来完成，替代了比较繁琐的XML配置文件， Spring的集成性经常的被提及，CXF支持Spring2.0和CXF&amp;rsquo;s API和Spring的配置文件可以非常好的对应。CXF强调代码优先的设计方式（code-first design)，使用了简单的API使得从现有的应用开发服务变得方便。&lt;br /&gt;
不过你选择Axis2还是CXF，你都可以从开源社区得到大量的帮助。这两个框架都有商业公司提供服务，WSO2提供AXIS2的支持，Iona提供CXF的支持。这两公司都有很活跃的开发者社区。&lt;/p&gt;

&lt;h3 id=&#34;如何选择&#34;&gt;如何选择？&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;如果应用程序需要多语言的支持，Axis2 应当是首选了；&lt;/li&gt;
&lt;li&gt;如果应用程序侧重JAVA并希望和Spring集，Apache CXF 是一种更好的选择，特别对嵌入式的 Web Services 来说；&lt;/li&gt;
&lt;li&gt;如果应用程序没有新的特性需要的话，就仍用原来项目所用的框架，比如 Axis1，XFire，Celtrix或 BEA 等等厂家自己的 Web Services 实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/growup/archive/2011/03/06/1972464.html&#34; target=&#34;blank&#34;&gt;每天进步一点点~&lt;/a&gt;&lt;br/&gt;
&lt;a href=&#34;https://www.cnblogs.com/xdp-gacl/p/4048937.html&#34; target=&#34;blank&#34;&gt;孤傲苍狼&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>SpringMVC的九大组件</title>
      <link>https://ianeiu.github.io/2018/08/30/springmvc%E7%9A%84%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Thu, 30 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/30/springmvc%E7%9A%84%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/</guid>
      
        <description>

&lt;h1 id=&#34;springmvc的九大组件&#34;&gt;SpringMVC的九大组件&lt;/h1&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;建议先阅读 &lt;a href=&#34;https://ianeiu.github.io/2018/08/30/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/&#34;&gt;SpringMVC的运行流程&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;组件&#34;&gt;组件&lt;/h2&gt;

&lt;h3 id=&#34;handlermapping&#34;&gt;HandlerMapping&lt;/h3&gt;

&lt;p&gt;处理器映射器:根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet&lt;/p&gt;

&lt;h3 id=&#34;handleradapter&#34;&gt;HandlerAdapter&lt;/h3&gt;

&lt;p&gt;适配器。因为SpringMVC中的Handler可以是任意的形式,但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。HandlerAdapter的作用就是让固定的Servlet处理方法调用Handler（Controller）来进行处理。&lt;/p&gt;

&lt;p&gt;有篇文章总结的很好：Handler是用来干活的工具；HandlerMapping用于根据需要干的活找到相应的工具；HandlerAdapter是使用工具干活的人。&lt;/p&gt;

&lt;h3 id=&#34;handlerexceptionresolver&#34;&gt;HandlerExceptionResolver&lt;/h3&gt;

&lt;p&gt;异常处理:自定义异常处理类继承此类或其子类，实现resolveException方法。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component
public class GlobalExceptionResolver implements HandlerExceptionResolver {
	...
	/**
	 * 针对请求处理异常
	 */
	@Override
	public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
			Exception ex) {
		boolean isHttpApi = isHttpApi(handler);
		HandleResult result = handleException(ex);
		if (isReturnReponseBody(handler) || isHttpApi) {
			if(isHttpApi){
				result =  apiHandleException(ex);
			}
			
			ModelAndView modelAndView = new ModelAndView();
			//处理异常
			response.setContentType(&amp;quot;application/json;charset=UTF-8&amp;quot;);
			byte[] bytes = JSON.toJSONBytes(Result.fail(result.getCode(), result.getMessage()), SerializerFeature.DisableCircularReferenceDetect, SerializerFeature.WriteMapNullValue);
			try {
				response.getOutputStream().write(bytes);
				response.getOutputStream().flush();
			} catch (IOException e) {
				log.error(&amp;quot;打印错误信息出错!&amp;quot;, e);
			}
			modelAndView.clear();
			return modelAndView;
		}else {
			Map&amp;lt;String, String&amp;gt; model = Maps.newHashMap();
			model.put(&amp;quot;code&amp;quot;, result.getCode());
			model.put(&amp;quot;message&amp;quot;, result.getMessage());
			return new ModelAndView(&amp;quot;500&amp;quot;, model);
		}
	}
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;viewresolver&#34;&gt;ViewResolver&lt;/h3&gt;

&lt;p&gt;视图解析器：当Controller将请求处理结果放入到ModelAndView中以后，DispatcherServlet会根据ModelAndView选择合适的视图进行渲染。ViewResolver接口有众多实现类，根据viewName创建合适类型的View实现。配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bean class=&amp;quot;org.Springframework.web.servlet.view.InternalResourceViewResolve&amp;quot;&amp;gt;
	&amp;lt;property name=&amp;quot;prefix&amp;quot; value=&amp;quot;/WEB-INF/views/&amp;quot; /&amp;gt;
	&amp;lt;property name=&amp;quot;suffix&amp;quot; value=&amp;quot;.jsp&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;requesttoviewnametranslator&#34;&gt;RequestToViewNameTranslator&lt;/h3&gt;

&lt;p&gt;当Controller处理器方法没有返回一个View对象或逻辑视图名称，并且在该方法中没有直接往response的输出流里面写数据的时候，Spring就会采用约定好的方式提供一个逻辑视图名称。可通过实现接口org.Springframework.web.servlet.RequestToViewNameTranslator接口的getViewName方法来实现。&lt;/p&gt;

&lt;h3 id=&#34;localeresolver&#34;&gt;LocaleResolver&lt;/h3&gt;

&lt;p&gt;国际化配置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Spring的国际化配置三种方式

&lt;ul&gt;
&lt;li&gt;基于URL参数的配置：通过URL参数来控制国际化

&lt;ol&gt;
&lt;li&gt;页面： &lt;code&gt;&amp;lt;a href=&amp;quot;myTest.jsp?locale=zh_CN&amp;quot;&amp;gt;简体中文&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置文件：&lt;code&gt;&amp;lt;bean id=&amp;quot;localeResolver&amp;quot; class=&amp;quot;org.Springframework.web.servlet.i18n.AcceptHeaderLocaleResolver&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;基于session的配置：通过检验用户会话中预置的属性来解析区域，最常用的是根据用户本次会话过程中的语言设定决定语言种类，如果该会话不存在，它会根据accept-language HTTP头部确定默认区域。配置&lt;br/&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;localeResolver&amp;quot; class=&amp;quot;org.Springframework.web.servlet.i18n.SessionLocaleResolver&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基于Cookie的国际化配置：用于通过浏览器的cookie设置取得Locale对象，这种策略在应用程序不支持会话或者状态必须保存在客户端时有用。&lt;br/&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;localeResolver&amp;quot; class=&amp;quot;org.Springframework.web.servlet.i18n.CookieLocaleResolver&amp;quot;/&amp;gt;&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;themeresolver&#34;&gt;ThemeResolver&lt;/h3&gt;

&lt;p&gt;解析主题。一个主题就是一组静态资源（比如样式表、图片等），它们可以影响应用程序的视觉效果。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SpringMVC中跟主题相关的类

&lt;ul&gt;
&lt;li&gt;ThemeResolver:主题解析器&lt;/li&gt;
&lt;li&gt;ThemeSource:主题资源&lt;/li&gt;
&lt;li&gt;Theme:主题接口&lt;/li&gt;
&lt;li&gt;ThemeChangeInterceptor:根据用户请求来改变主题(需要在handlerMapping中配置拦截器&lt;br/&gt;&lt;code&gt;&amp;lt;property name=&amp;quot;interceptors&amp;quot;&amp;gt;&amp;lt;list&amp;gt;&amp;lt;ref local=&amp;quot;themeChangeInterceptor&amp;quot; /&amp;gt;&amp;lt;/list&amp;gt;&amp;lt;/property&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ThemeResolver子类

&lt;ul&gt;
&lt;li&gt;AbstractThemeResolver:SessionThemeResolver和FixedThemeResolver继承的抽象类&lt;/li&gt;
&lt;li&gt;SessionThemeResolver:用户的主题保存在HTTP session中&lt;/li&gt;
&lt;li&gt;CookieThemeResolver:用于实现用户所选的主题，以cookie的形式存放在客户端的机器上&lt;/li&gt;
&lt;li&gt;FixedThemeResolver:用于选择一个固定的主题
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;multipartresolver&#34;&gt;MultipartResolver&lt;/h3&gt;

&lt;p&gt;MultipartResolver 用于处理文件上传，当收到请求时 DispatcherServlet 的 checkMultipart() 方法会调用 MultipartResolver 的 isMultipart() 方法判断请求中是否包含文件。如果请求数据中包含文件，则调用 MultipartResolver 的 resolveMultipart() 方法对请求的数据进行解析，然后将文件数据解析成 MultipartFile 并封装在 MultipartHttpServletRequest (继承了 HttpServletRequest) 对象中，最后传递给 Controller.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MultipartResolver子类

&lt;ul&gt;
&lt;li&gt;CommonsMultipartResolver：使用 commons Fileupload来处理 multipart请求，所以在使用时，必须要引入相应的jar包。而像SpringBoot是不支持CommonsMultipartResolver&lt;/li&gt;
&lt;li&gt;StandardServletMultipartResolver：基于Servlet3.0来处理multipart请求的，所以不需要引用其他jar包，从Tomcat7.0.x的版本开始就支持 Servlet 3.0了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>SpringMVC的运行流程</title>
      <link>https://ianeiu.github.io/2018/08/30/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Thu, 30 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/30/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid>
      
        <description>

&lt;h2 id=&#34;springmvc的运行流程&#34;&gt;SpringMVC的运行流程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ianeiu.github.io/resouce/SpringMVC的运行流程.png&#34;  alt=&#34;SpringMVC的运行流程&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户发送请求至前置控制器DispatcherServlet&lt;/li&gt;
&lt;li&gt;DispatcherServlet收到请求调用HandlerMapping处理器映射器。&lt;/li&gt;
&lt;li&gt;处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。&lt;/li&gt;
&lt;li&gt;DispatcherServlet通过HandlerAdapter处理器适配器调用处理器&lt;/li&gt;
&lt;li&gt;执行处理器/后端控制器Controller&lt;/li&gt;
&lt;li&gt;Controller执行完成返回ModelAndView&lt;/li&gt;
&lt;li&gt;HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet&lt;/li&gt;
&lt;li&gt;DispatcherServlet将ModelAndView传给视图解析器ViewReslover&lt;/li&gt;
&lt;li&gt;ViewReslover解析后返回具体View&lt;/li&gt;
&lt;li&gt;DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。&lt;/li&gt;
&lt;li&gt;DispatcherServlet响应用户。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从上面可以看出，DispatcherServlet有接收请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java基础题（Integer）</title>
      <link>https://ianeiu.github.io/2018/08/29/java%E5%9F%BA%E7%A1%80%E9%A2%98integer/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/29/java%E5%9F%BA%E7%A1%80%E9%A2%98integer/</guid>
      
        <description>&lt;p&gt;翻了翻之前收藏的文章，找到一段比较有意思的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Integer a = 1000,b=1000;
Integer c = 100,d=100;    
@Test
public void testIntegerDD(){
    System.out.println(a==b);//false  
    System.out.println(c==d);//true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行代码，我们会得到 false  true。这道题笔试用经常出现，原理也很简单
,可看Integer源码valueOf(int i)方法&lt;br /&gt;
    public static Integer valueOf(int i) {
        if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }&lt;/p&gt;

&lt;p&gt;接下来，简单的扩展几个Integer的关系运算符==的比较。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void testIntegerDD(){

    Integer a = 1000,b=1000;
    Integer c = 100,d=100;   
    Integer e = new Integer(100);
    Integer f = new Integer(100);
    int g = 1000;
    Integer h = new Integer(1000);  


    //1、进行自动装箱操作；2、Integer中把-128-127 缓存了下来
    System.out.println(a==b);//false  
    System.out.println(c==d);//true

    //这里并不是用的缓存，而是new创建的对象存放在堆内存中，俩个变量指向不同引用，所以结果是false
    System.out.println(e==f);//false
    //当int和Integer进行==比较的时候，Java会把Integer进行自动拆箱为int类型的值
    System.out.println(g==h);//true

    //进行自动装箱操作
    System.out.println(c==e);//false
    System.out.println(a==h);//false
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Java基础题（String）</title>
      <link>https://ianeiu.github.io/2018/08/29/java%E5%9F%BA%E7%A1%80%E9%A2%98string/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/29/java%E5%9F%BA%E7%A1%80%E9%A2%98string/</guid>
      
        <description>&lt;p&gt;翻了翻之前收藏的文章，又找到一段比较有意思的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void testStringDD() {
    String s1 = &amp;quot;hello&amp;quot;;
    String s2 = &amp;quot;hello&amp;quot;;
    String s3 = new String(&amp;quot;hello&amp;quot;);

    System.out.println(s1==s2); // true
    System.out.println(s1==s3); // false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章解释：&lt;br /&gt;
一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，而堆内存中则存放new出来的对象和数组。然而除此之外还有一块区域叫做常量池。&lt;br /&gt;
像我们通常想String s1 = &amp;ldquo;hello&amp;rdquo;; 这样申明的字符串对象，其值就是存储在常量池中。&lt;br /&gt;
当我们创建String s1 =&amp;ldquo;hello&amp;rdquo;这样一个对象之后，&amp;rdquo;hello&amp;rdquo;就存储到了常量池（也可叫做字符串池）中，当我们创建引用String s2  = &amp;ldquo;hello&amp;rdquo; 的时候，Java底层会优先在常量池中查找是否存在&amp;rdquo;hello&amp;rdquo;，如果存在则让s2指向这个值，不会重新创建，如果常量池中没有则创建并添加的池中。这就是为什么答案是true 和false的原因。&lt;/p&gt;

&lt;p&gt;接下来，还是简单的扩展几个String的关系运算符==的比较。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void testStringDD() {
    String s1 = &amp;quot;hello&amp;quot;;
    String s2 = &amp;quot;hello&amp;quot;;
    String s3 = new String(&amp;quot;hello&amp;quot;);

    //都存储在常量池中,指向同一常量
    System.out.println(s1==s2); // true
    //存储在常量池中,存储在堆内存中
    System.out.println(s1==s3); // false

    String s4 = &amp;quot;helloo&amp;quot;;
    /**
     * 会重新在常量池创建常量（String不可变属性）
     */
    String s5 = s1+&amp;quot;o&amp;quot;;
    //都存储在常量池中,指向不同常量
    System.out.println(s4 == s5); // false

    //hello
    String s6 = s4.substring(0, s4.length() - 1);
    //substring返回的也是new出来的String对象
    System.out.println(s1 == s6); // false
    System.out.println(s3 == s6); // false
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Java基础题（内部类与final）</title>
      <link>https://ianeiu.github.io/2018/08/29/java%E5%9F%BA%E7%A1%80%E9%A2%98%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8Efinal/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/29/java%E5%9F%BA%E7%A1%80%E9%A2%98%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8Efinal/</guid>
      
        <description>&lt;p&gt;翻了翻之前收藏的文章，又又找到一段比较有意思的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void mRun(final String name){
    new Runnable() {
        public void run() {
            try {
              Thread.sleep(1000);
           } catch (InterruptedException e) {
             // TODO Auto-generated catch block
            e.printStackTrace();
           }  
           System.out.println(name);
        }
    }.start();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章解释：&lt;br /&gt;
这种代码相信大家写过很多，当内部类访问局部变量的时候，需要在局部变量前加final修饰符，不然编译器就会报错。通常我们也是这么干的。&lt;br /&gt;
为什么要加final修饰符？&lt;br /&gt;
首先内部类的生命周期是成员级别的，而局部变量的生命周期实在方法体之类。也就是说会出现这样一种情况，当mRun方法执行，new 的线程运行，新线程里面会睡一秒。&lt;br /&gt;
主线程会继续执行，mRun执行完毕，name属性生命周期结束。1秒之后，Syetem.out.printh(name)执行。然而此时name已经寿终正寝，不在内存中了。&lt;br /&gt;
Java就是为了杜绝这种错误，严格要求内部类中方位局部变量，必须使用final关键字修饰。&lt;br /&gt;
局部变量被final修饰之后，此时会在内存中保有一份局部变得的复制品，当内部类访问的时候其实访问的是这个复制品。这就好像是把局部变量的生命周期变长了。&lt;br /&gt;
说到底还是Java工程师提前把这个坑给我们填了，不然不知道又会有多少小伙伴会为了内部类局部变量而发愁了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Spring常用注解</title>
      <link>https://ianeiu.github.io/2018/08/29/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/29/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</guid>
      
        <description>

&lt;h2 id=&#34;属性注入&#34;&gt;属性注入&lt;/h2&gt;

&lt;h3 id=&#34;autowired&#34;&gt;@Autowired&lt;/h3&gt;

&lt;p&gt;自动装配，可消除代码里的getter/setter与bean属性中的property&lt;/p&gt;

&lt;p&gt;如果不使用注解自动注入，必须通过代码手动注入,如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot; /&amp;gt;
    &amp;lt;property name=&amp;quot;student&amp;quot; ref=&amp;quot;student&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;xxx.Student&amp;quot; /&amp;gt;
...

@Test
public void test(){
    //读取配置文件
    ApplicationContext ctx=new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);
    User user=(User) ctx.getBean(&amp;quot;user&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而使用注解@Autowired大大减少了代码量，提高可读性。&lt;br /&gt;
使用前配置文件要添加扫描器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;context:component-scan base-package=&amp;quot;xxx.vo&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;xxx.Student&amp;quot; /&amp;gt;
...

class User{
    @Autowired
    private Student student;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当xml配置了user的属性时，Spring会按照xml优先的原则去User.java中寻找这两个属性的getter/setter，导致的结果就是初始化bean报错&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&amp;quot;xxx.vo&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;student&amp;quot; ref=&amp;quot;student&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;xxx.Student&amp;quot; /&amp;gt;

class User{
    @Autowired
    private Student student;
    //无getter/setter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当xml未配置了student的bean时会抛出找不到bean的异常，可将@Autowired注解的required设置为false，默认student为null&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&amp;quot;xxx.vo&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot; /&amp;gt;

class User{
    @Autowired(required=false)
    private Student student;
    //无getter/setter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qualifier&#34;&gt;Qualifier&lt;/h3&gt;

&lt;p&gt;指定注入Bean的名称&lt;/p&gt;

&lt;h3 id=&#34;resource&#34;&gt;@Resource&lt;/h3&gt;

&lt;p&gt;@Resource注解与@Autowired注解作用相似&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class User{
    @Resource(name=&amp;quot;student&amp;quot;)
    private Student student;

    //@Resource(type=&amp;quot;Student.class&amp;quot;)
    //private Student student;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@Resource的装配顺序：
(1)、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配
(2)、指定了name或者type则根据指定的类型去匹配bean，任何一个不匹配都将报错&lt;/p&gt;

&lt;p&gt;@Autowired和@Resource两个注解的区别：
(1)、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配
(2)、@Autowired是Spring的注解，@Resource是J2EE的注解&lt;/p&gt;

&lt;h2 id=&#34;获取参数&#34;&gt;获取参数&lt;/h2&gt;

&lt;h3 id=&#34;requestparam&#34;&gt;@RequestParam&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20&#34;&gt;http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20&lt;/a&gt;&lt;br /&gt;
根据上面的这个URL，你可以用这样的方式来进行获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String getDetails(
    @RequestParam(value=&amp;quot;param1&amp;quot;, required=true) String param1,
    @RequestParam(value=&amp;quot;param2&amp;quot;, required=false) String param2){
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@RequestParam 支持下面四种参数
    defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值
    name 绑定本次参数的名称，要跟URL上面的一样
    required 这个参数是不是必须的
    value 跟name一样的作用，是name属性的一个别名&lt;/p&gt;

&lt;h3 id=&#34;pathvariable&#34;&gt;@PathVariable&lt;/h3&gt;

&lt;p&gt;这个注解能够识别URL里面的一个模板，我们看下面的一个URL
&lt;a href=&#34;http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20&#34;&gt;http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20&lt;/a&gt;
上面的一个url你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String getDetails(
    @RequestMapping(&amp;quot;/hello/{id}&amp;quot;)
    public String getDetails(@PathVariable(value=&amp;quot;id&amp;quot;) String id,
    @RequestParam(value=&amp;quot;param1&amp;quot;, required=true) String param1,
    @RequestParam(value=&amp;quot;param2&amp;quot;, required=false) String param2){
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;区别很明显了&lt;/p&gt;

&lt;h2 id=&#34;常用注解&#34;&gt;常用注解&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;注解&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Component&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;泛指组件，类似在xml中配置bean &lt;bean id=&#34;beanId&#34; class=&#34;包名.类名&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Configuration&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;把类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Repository&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于标注数据访问组件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Service&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于标注业务层组件,默认bean的id为类名且首字母小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Controller&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于标注控制层组件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@RestController&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;spring4.0之后，@controller和@responsebody的结合&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Scope&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作用域 表示将Action的范围声明为原型，可以利用容器的scope=&amp;ldquo;prototype&amp;rdquo;来保证每一个请求有一个单独的Action来处理，避免struts中Action的线程安全问题。spring默认scope是单例模式(scope=&amp;ldquo;singleton&amp;rdquo;)，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2是要求每次次访问都对应不同的Action，scope=&amp;ldquo;prototype&amp;rdquo;可以保证当有请求的时候都创建一个Action对象。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Lazy(true)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;延迟初始化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@RequestMapping&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。value：指定请求的实际地址；method：指定请求的method类型，GET、POST、PUT、DELETE等（Spring4.3中引进了｛@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping｝，来帮助简化常用的HTTP方法的映射）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@ResponseBody&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，效果等同于通过response对象输出指定格式的数据 效果等同于如下代码：@RequestMapping(&amp;ldquo;/login&amp;rdquo;)   public void login(User user, HttpServletResponse response){  response.getWriter.write(JSONObject.fromObject(user).toString());  }&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@PostConstruct&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;初始化注解,用于指定初始化方法（用在方法上）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@PreDestory&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于指定销毁方法（用在方法上）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@DependsOn&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;定义Bean初始化及销毁时的顺序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Primary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Autowired&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Resource&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认按名称装配,当找不到与名称匹配的bean才会按类型装配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Async&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;异步方法调用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@RequestParam&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;接收参数,从request里面拿取值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@PathVariable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;接收参数,从一个URI模板里面来填充&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@PathParam&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@QueryParam&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;JAX-RS 提供的，和Spring的RequestParam作用一致&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@RequestBody&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;一般是post请求的时候才会使用这个请求，把参数丢在requestbody里面&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
    <item>
      <title>外网无法内网FTP（200 Type set to A）</title>
      <link>https://ianeiu.github.io/2018/08/23/%E5%A4%96%E7%BD%91%E6%97%A0%E6%B3%95%E5%86%85%E7%BD%91ftp200-type-set-to-a/</link>
      <pubDate>Thu, 23 Aug 2018 16:01:23 +0800</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/23/%E5%A4%96%E7%BD%91%E6%97%A0%E6%B3%95%E5%86%85%E7%BD%91ftp200-type-set-to-a/</guid>
      
        <description>&lt;p&gt;FTP 搭建好后在外网访问出想以下错误：&lt;br /&gt;
在Windows 资源管理器访问FTP站点弹出 FTP文件夹错误&lt;br /&gt;
            打开FTP 服务器上的文件夹时发生错误。请检查是否有权限范围该文件夹。&lt;br /&gt;
            详细信息：&lt;br /&gt;
    200 Type set to A.&lt;br /&gt;
    227 Entering Passive Mode (192,168,1,100,192,81)&lt;br /&gt;
解决方法：&lt;br /&gt;
      打开IE 浏览器 &amp;ndash; 工具 &amp;ndash; Internet 选项 &amp;ndash; 高级 &amp;ndash; 设置 &amp;ndash; 浏览 &amp;ndash; 把 使用被动FTP （用于防火墙和 DSL 调制解调器的兼容） 前面的勾去掉&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>常见状态码简介</title>
      <link>https://ianeiu.github.io/2018/08/23/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 23 Aug 2018 16:01:23 +0800</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/23/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E4%BB%8B/</guid>
      
        <description>

&lt;h2 id=&#34;部分状态码简介&#34;&gt;部分状态码简介&lt;/h2&gt;

&lt;h1 id=&#34;200&#34;&gt;200&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;b&gt;200&lt;b&gt;—&lt;code&gt;请求成功&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;30x&#34;&gt;30X&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;301—&lt;code&gt;永久移动。被请求的资源已被永久移动位置&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;302&lt;b&gt;—&lt;code&gt;请求的资源现在临时从不同的 URI 响应请求（请求重定向）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;305—&lt;code&gt;使用代理。被请求的资源必须通过指定的代理才能被访问&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;304—&lt;code&gt;请求资源没有改变&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;307—&lt;code&gt;临时跳转。被请求的资源在临时从不同的URL响应请求&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;4xx&#34;&gt;4XX&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;400—&lt;code&gt;错误请求&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;402—&lt;code&gt;需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;403—&lt;code&gt;禁止访问。服务器已经理解请求，但是拒绝执行它&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;404&lt;b&gt;—&lt;code&gt;找不到对象。请求失败，资源不存在&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;406—&lt;code&gt;不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;408—&lt;code&gt;请求超时&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;409—&lt;code&gt;冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;410—&lt;code&gt;遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;413—&lt;code&gt;响应实体太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;417—&lt;code&gt;期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;418—&lt;code&gt;我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;420—&lt;code&gt;方法失效&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;422—&lt;code&gt;不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;500&#34;&gt;500&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;b&gt;500&lt;b&gt;—&lt;code&gt;服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Eclipse 修复 弹窗License activation报this license BIG3CLIK6F has been cancelled</title>
      <link>https://ianeiu.github.io/2018/08/23/eclipse-%E4%BF%AE%E5%A4%8D-%E5%BC%B9%E7%AA%97license-activation%E6%8A%A5this-license-big3clik6f-has-been-cancelled/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/23/eclipse-%E4%BF%AE%E5%A4%8D-%E5%BC%B9%E7%AA%97license-activation%E6%8A%A5this-license-big3clik6f-has-been-cancelled/</guid>
      
        <description>&lt;p&gt;修改系统配置&lt;/p&gt;

&lt;p&gt;Linux在/etc/hosts中添加 0.0.0.0 account.jetbrains.com&lt;br /&gt;
windows在C:\Windows\System32\drivers\etc\hosts，将“0.0.0.0 account.jetbrains.com”添加到hosts文件中&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>IllegalStateException</title>
      <link>https://ianeiu.github.io/2018/08/23/illegalstateexception/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/23/illegalstateexception/</guid>
      
        <description>&lt;p&gt;做开发的时候，有时候报错：&lt;/p&gt;

&lt;p&gt;java.lang.IllegalStateException: Cannot call sendError() after the response has been committed&lt;/p&gt;

&lt;p&gt;字面上是参数异常， 在response已经提交之后 不能发送错误请求。&lt;/p&gt;

&lt;p&gt;下面看个例子就一目了然了：&lt;/p&gt;

&lt;p&gt;response.setContentType(&amp;ldquo;text/html;charset=UTF-8&amp;rdquo;);&lt;br /&gt;
PrintWriter out = response.getWriter();&lt;br /&gt;
out.print(&amp;ldquo;上传成功！上传文件为:&amp;ldquo;+fileName+&amp;rdquo;&lt;br/&gt;保存的地址为&amp;rdquo;+filePath+ &amp;ldquo;！！&amp;rdquo;);&lt;br /&gt;
out.close();&lt;/p&gt;

&lt;p&gt;response.sendRedirect(&amp;ldquo;index.jsp&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;首先，利用reponse.getWrite()获得输出流对象，close()之后，这里reponse其实已经提交了。注释下面的sendRedirect代码，执行之后发现response已经进行已经跳转了，只不过url没有发生改变，并且页面上已经有输出上面指定的字符串。&lt;/p&gt;

&lt;p&gt;所以当执行上面代码之后 ，reponse 会提交两次，服务器就不知道该怎么办了，所以抛出异常。&lt;/p&gt;

&lt;p&gt;解决方案： 去掉out.close()  这里不会因为PrintWriter 输出对象没有关闭而占用资源的。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>form表单使用注意点</title>
      <link>https://ianeiu.github.io/2018/08/23/form%E8%A1%A8%E5%8D%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/23/form%E8%A1%A8%E5%8D%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查询页面，有绑定回车事件提交表单的，要在form中加上onsubmit=&amp;ldquo;return false;&amp;ldquo;，不然会出现回车查询时页面直接显示JSON数据了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接在form标签中加入属性accept-charset=&amp;lsquo;UTF-8&amp;rsquo;,防止中文乱码&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>svn 提示不是内部或者外部命令</title>
      <link>https://ianeiu.github.io/2018/08/23/svn-%E6%8F%90%E7%A4%BA%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E8%80%85%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/23/svn-%E6%8F%90%E7%A4%BA%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E8%80%85%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4/</guid>
      
        <description>&lt;p&gt;windows安装svn的时候默认是不安装 svn comand line这个东西的，&lt;br /&gt;
你重装下svn客户端，注意在选择安装项目那里点上 svn comand line 就好了&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>tomcat修改startup.bat启动窗口名</title>
      <link>https://ianeiu.github.io/2018/08/23/tomcat%E4%BF%AE%E6%94%B9startup.bat%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%90%8D/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/08/23/tomcat%E4%BF%AE%E6%94%B9startup.bat%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%90%8D/</guid>
      
        <description>&lt;dl&gt;
&lt;dt&gt;打开 catlina.bat 文件，修改灰色区域&lt;/dt&gt;
&lt;/dl&gt;

&lt;p&gt;:doStart&lt;br /&gt;
shift&lt;br /&gt;
if &amp;ldquo;%TITLE%&amp;rdquo; == &amp;ldquo;&amp;rdquo; set TITLE=&lt;code&gt;zsyx_8232&lt;/code&gt;&lt;br /&gt;
set _EXECJAVA=start &amp;ldquo;%TITLE%&amp;rdquo; %_RUNJAVA%&lt;br /&gt;
if not &amp;ldquo;&amp;rdquo;%1&amp;rdquo;&amp;rdquo; == &amp;ldquo;&amp;rdquo;-security&amp;rdquo;&amp;rdquo; goto execCmd&lt;br /&gt;
shift&lt;br /&gt;
echo Using Security Manager&lt;br /&gt;
set &amp;ldquo;SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy&amp;rdquo;&lt;br /&gt;
goto execCmd&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>