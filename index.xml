<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0">
  <channel>
    <title>ianeiu</title>
    <link>https://ianeiu.github.io/</link>
    <description>Recent content on ianeiu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>WuWeiMian</copyright>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://ianeiu.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://ianeiu.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://ianeiu.github.io/about/</guid>
      
        <description>

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;吴炜棉&lt;/li&gt;
&lt;li&gt;weimianwu@foxmail.com&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span style=&#34;display:none&#34;&gt;### 友链&lt;/span&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>贪婪模式与懒惰模式</title>
      <link>https://ianeiu.github.io/2020/03/20/%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/03/20/%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;p&gt;&lt;strong&gt;知识点：正则表达式中表示字符串重复个数的元字符，如 &lt;code&gt;?,+,*,{}&lt;/code&gt;  默认贪婪模式匹配最大长度匹配字符串。
在元字符后加个&lt;code&gt;?&lt;/code&gt;即可切换为懒惰模式&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;之前做过一个短信模版的配置功能，需要用到正则判断完成预览方法，踩了个小坑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 部分代码 --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;//libs.baidu.com/jquery/1.10.2/jquery.min.js&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
$(document).ready(function () {
	createContentPreview()
});


function createContentPreview(){
        //遍历获取所有input标签值
	var vals=[];
	$(&amp;quot;#tExaDiv&amp;quot;).find(&amp;quot;input&amp;quot;).each(function(){
		var val=$(this).val();
		vals.push(val);
	})
	
        // 含有&amp;lt;input type=&amp;quot;..&amp;quot; /&amp;gt;标签
	var html=$(&amp;quot;#tExaDiv&amp;quot;).html();

        //遍历替换
	var reg=/&amp;lt;input[^]*?&amp;gt;/;
	for(var i=0;i&amp;lt;vals.length;i++){
		html=html.replace(reg,vals[i]);
	}

        //渲染
	$(&amp;quot;#contentPreview&amp;quot;).html(html);
}
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;tExaDiv&amp;quot;&amp;gt;
	如果我是&amp;lt;input =&amp;quot;text&amp;quot; value=&amp;quot;dj&amp;quot;/&amp;gt;,你会&amp;lt;input =&amp;quot;text&amp;quot; value=&amp;quot;爱&amp;quot;/&amp;gt;我吗？
&amp;lt;/div&amp;gt;

&amp;lt;div id=&amp;quot;contentPreview&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contentPreview内容：如果我是dj,你会爱我吗？&lt;br /&gt;
如果未加?，则是贪婪模式。contentPreview显示错误内容：如果我是dj我吗？&lt;/p&gt;

&lt;h2 id=&#34;懒惰模式&#34;&gt;懒惰模式&lt;/h2&gt;

&lt;p&gt;对字符串进行最小长度匹配&lt;/p&gt;

&lt;p&gt;字符串：&lt;code&gt;&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br /&gt;
正则表达式：&lt;code&gt;&amp;lt;span&amp;gt;.*?&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br /&gt;
匹配结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;共找到 2 处匹配：  
	&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt; 
	&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;贪婪模式&#34;&gt;贪婪模式&lt;/h2&gt;

&lt;p&gt;对字符串进行最大长度匹配&lt;/p&gt;

&lt;p&gt;字符串：&lt;code&gt;&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br /&gt;
正则表达式：&lt;code&gt;&amp;lt;span&amp;gt;.*&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br /&gt;
匹配结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;共找到 1 处匹配：
&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常见元字符及其含义&#34;&gt;常见元字符及其含义&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;符号               含义
————————————————————————————————————————————————————
.                  匹配除换行符之外的任意字符
^                  匹配字符的开始位置
$                  匹配字符的结束位置
*                  匹配0次，1次或多次前面的原子
?                  匹配0次或1次前面的原子
+                  匹配1次或多次前面的原子
{n}                前面的原子恰好出现n次
{n,}               前面的原子至少出现n次
{n,m}              前面的原子至少出现n次，至多出现m次
|                  模式选择符
()                 模式单元符   
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Java面试之并发</title>
      <link>https://ianeiu.github.io/2020/03/05/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/03/05/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/</guid>
      
        <description>

&lt;h2 id=&#34;synchronized-底层如何实现-什么是锁的升级-降级&#34;&gt;synchronized 底层如何实现？什么是锁的升级、降级？&lt;/h2&gt;

&lt;p&gt;synchronized 代码块是由 monitorenter/monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。&lt;/p&gt;

&lt;p&gt;在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。&lt;/p&gt;

&lt;p&gt;现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，
也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。&lt;/p&gt;

&lt;p&gt;所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，
当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。&lt;/p&gt;

&lt;p&gt;当没有竞争出现时，默认会使用偏斜锁。
JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。
这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。&lt;/p&gt;

&lt;p&gt;如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。
轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。&lt;/p&gt;

&lt;p&gt;当JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。&lt;/p&gt;

&lt;p&gt;偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，
只有当存在较多不会真正竞争的 synchronized 块儿时，才能体现出明显改善。
实践中对于偏斜锁的一直是有争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。
还有一方面是，偏斜锁会延缓 JIT 预热的进程，所以很多性能测试中会显式地关闭偏斜锁，命令：&lt;code&gt;-XX:-UseBiasedLocking&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;自旋锁-是做什么的吗-它的使用场景是什么&#34;&gt;“自旋锁”是做什么的吗？它的使用场景是什么？&lt;/h2&gt;

&lt;p&gt;自旋锁:&lt;br /&gt;
竞争锁失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，
在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。&lt;/p&gt;

&lt;p&gt;适用场景:&lt;br /&gt;
自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，
因为自旋的消耗会小于线程阻塞挂起操作的消耗。
如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁了，
因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费。&lt;/p&gt;

&lt;h2 id=&#34;一个线程两次调用-start-方法会出现什么情况-谈谈线程的生命周期和状态转移&#34;&gt;一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。&lt;/h2&gt;

&lt;p&gt;Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException。&lt;br /&gt;
在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。&lt;/p&gt;

&lt;p&gt;线程的生命周期和状态转移 详见java笔记基础篇&lt;/p&gt;

&lt;p&gt;线程是系统调度的最小单元，一个进程可以包含多个线程，
作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（ThreadLocal）等，
但是会和进程内其他线程共享文件描述符、虚拟地址空间等。&lt;/p&gt;

&lt;h2 id=&#34;虚假唤醒&#34;&gt;虚假唤醒&lt;/h2&gt;

&lt;p&gt;在多核处理器下，pthread_cond_signal可能会激活多于一个线程（阻塞在条件变量上的线程）。
结果就是，当一个线程调用pthread_cond_signal()后，多个调用pthread_cond_wait()或pthread_cond_timedwait()的线程返回。这种效应就称为“虚假唤醒”。&lt;/p&gt;

&lt;p&gt;举个例子，我们现在有一个生产者-消费者队列和三个线程。&lt;/p&gt;

&lt;p&gt;1） 1号线程从队列中获取了一个元素，此时队列变为空。&lt;/p&gt;

&lt;p&gt;2） 2号线程也想从队列中获取一个元素，但此时队列为空，2号线程便只能进入阻塞(cond.wait())，等待队列非空。&lt;/p&gt;

&lt;p&gt;3） 这时，3号线程将一个元素入队，并调用cond.notify()唤醒条件变量。&lt;/p&gt;

&lt;p&gt;4） 处于等待状态的2号线程接收到3号线程的唤醒信号，便准备解除阻塞状态，执行接下来的任务(获取队列中的元素)。&lt;/p&gt;

&lt;p&gt;5） 然而可能出现这样的情况：当2号线程准备获得队列的锁，去获取队列中的元素时，此时1号线程刚好执行完之前的元素操作，返回再去请求队列中的元素，1号线程便获得队列的锁，检查到队列非空，就获取到了3号线程刚刚入队的元素，然后释放队列锁。&lt;/p&gt;

&lt;p&gt;6） 等到2号线程获得队列锁，判断发现队列仍为空，1号线程“偷走了”这个元素，所以对于2号线程而言，这次唤醒就是“虚假”的，它需要再次等待队列非空。&lt;/p&gt;

&lt;p&gt;如果用if判断，多个等待线程在满足if条件时都会被唤醒(虚假的)，但实际上条件并不满足，生产者生产出来的消费品已经被第一个线程消费了。
这就是我们使用while去做判断而不是使用if的原因：因为等待在条件变量上的线程被唤醒有可能不是因为条件满足而是由于虚假唤醒。
所以，我们需要对条件变量的状态进行不断检查直到其满足条件，不仅要在pthread_cond_wait前检查条件是否成立，在pthread_cond_wait之后也要检查。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while ( isCondition()) {
    waitForAConfition(...);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;慎用threadlocal&#34;&gt;慎用ThreadLocal&lt;/h2&gt;

&lt;p&gt;慎用ThreadLocal，这是 Java 提供的一种保存线程私有信息的机制，
因为其在整个线程生命周期内有效，所以可以方便地在一个线程关联的不同业务模块之间传递信息，比如事务 ID、Cookie 等上下文相关信息。&lt;/p&gt;

&lt;p&gt;它的实现结构，可以参考源码，数据存储于线程相关的 ThreadLocalMap，其内部条目是弱引用，如下面片段。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static class ThreadLocalMap {
    static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
        /** The value associated with this ThreadLocal. */
        Object value;
        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
            super(k);
            value = v;
        }
    }
    // …
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 Key 为 null 时，该条目就变成“废弃条目”，相关“value”的回收，往往依赖于几个关键点，即 set、remove、rehash。&lt;/p&gt;

&lt;p&gt;下面是 set 的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void set(ThreadLocal&amp;lt;?&amp;gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp;amp; (len-1);
    for (Entry e = tab[i];; …) {
        //…
        if (k == null) {
            // 替换废弃条目
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    tab[i] = new Entry(key, value);
    int sz = ++size;
    // 扫描并清理发现的废弃条目，并检查容量是否超限
    if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)
        rehash();// 清理废弃条目，如果仍然超限，则扩容（加倍）
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常弱引用都会和引用队列配合清理机制使用，但是 ThreadLocal 是个例外，它并没有这么做。&lt;/p&gt;

&lt;p&gt;这意味着，废弃项目的回收依赖于显式地触发，否则就要等待线程结束，进而回收相应ThreadLocalMap！
这就是很多 OOM 的来源，所以通常都会建议，应用一定要自己负责remove，并且不要和线程池配合，因为 worker 线程往往是不会退出的。&lt;/p&gt;

&lt;h2 id=&#34;jvm-启动-hello-world的线程分析&#34;&gt;JVM 启动 Hello World的线程分析&lt;/h2&gt;

&lt;p&gt;检测获得
Thread[Reference Handler,10,system]&lt;br /&gt;
Thread[Finalizer,8,system]&lt;br /&gt;
Thread[main,5,main]&lt;br /&gt;
Thread[Signal Dispatcher,9,system]&lt;br /&gt;
Hello World!&lt;/p&gt;

&lt;p&gt;其中：&lt;br /&gt;
Reference Handler：处理引用对象本身的垃圾回收&lt;br /&gt;
Finalizer：处理用户的Finalizer方法&lt;br /&gt;
Signal Dispatcher：外部jvm命令的转发器&lt;br /&gt;
在jdk6环境中,还有一个Attach Listener的线程是负责接收外部命令的，如jmap、jstack&lt;/p&gt;

&lt;h2 id=&#34;什么情况下-java-程序会产生死锁-如何定位-修复&#34;&gt;什么情况下 Java 程序会产生死锁？如何定位、修复？&lt;/h2&gt;

&lt;p&gt;死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。
死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。
通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。&lt;/p&gt;

&lt;p&gt;定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。
如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。&lt;/p&gt;

&lt;p&gt;如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。
所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。&lt;/p&gt;

&lt;p&gt;基本上死锁的发生是因为：
* 互斥条件，类似 Java 中 Monitor 都是独占的，要么是我用，要么是你用。
* 互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。
* 循环依赖关系，两个或者多个个体之间出现了锁的链条环。&lt;/p&gt;

&lt;p&gt;如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁；&lt;br /&gt;
如果必须使用多个锁，尽量设计好锁的获取顺序（根据对象之间组合、调用的关系对比和组合，考虑可能调用时序）；&lt;br /&gt;
使用带超时的方法，为程序带来更多可控性；&lt;br /&gt;
业界也有一些其他方面的尝试，比如通过静态代码分析（如 FindBugs）去查找固定的模式，进而定位可能的死锁或者竞争情况&lt;/p&gt;

&lt;p&gt;死循环死锁可以认为是自旋锁死锁的一种，其他线程因为等待不到具体的信号提示。导致线程一直饥饿。&lt;br /&gt;
这种情况下可以查看线程 cpu 使用情况，排查出使用 cpu 时间片最高的线程，再打出该线程的堆栈信息，排查代码。&lt;br /&gt;
比如Linux上，可以使用top命令配合grep Java之类，找到忙的pid；然后，转换成16进制，就是jstack输出中的格式；再定位代码&lt;/p&gt;

&lt;h2 id=&#34;java-并发包提供了哪些并发工具类&#34;&gt;Java 并发包提供了哪些并发工具类？&lt;/h2&gt;

&lt;p&gt;我们通常所说的并发包也就是 java.util.concurrent 及其子包，集中了 Java 并发的各种基础工具类，具体主要包括几个方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Sempahore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。&lt;/li&gt;
&lt;li&gt;各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的ConcunrrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList 等。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;各种并发队列实现，如各种 BlockedQueue 实现，比较典型的 ArrayBlockingQueue、SynchorousQueue 或针对特定场景的 PriorityBlockingQueue 等。&lt;/li&gt;
&lt;li&gt;强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CountDownLatch，允许一个或多个线程等待某些操作完成。&lt;br /&gt;
CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障。&lt;br /&gt;
Semaphore，Java 版本的信号量实现。&lt;/p&gt;

&lt;p&gt;两个应用并发工具的场景:&lt;br /&gt;
1. 请求熔断器，使用 Semaphore 熔断某些请求线程，待系统恢复以后再逐步释放信号量。
2. Worker 搜索停止标志。使用 countdownlatch 标记 Worker 找到的结果个数，达到结果后其他线程不再继续执行。&lt;/p&gt;

&lt;p&gt;Java 并发类库还提供了Phaser，功能与 CountDownLatch 很接近，但是它允许线程动态地注册到 Phaser 上面，而 CountDownLatch 显然是不能动态设置的。
Phaser 的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动。&lt;/p&gt;

&lt;p&gt;并发包里提供的线程安全 Map、List 和 Set，总体上种类和结构还是比较简单的。&lt;br /&gt;
如果我们的应用侧重于 Map 放入或者获取的速度，而不在乎顺序，大多推荐使用 ConcurrentHashMap，
反之则使用ConcurrentSkipListMap；如果我们需要对大量数据进行非常频繁地修改，ConcurrentSkipListMap 也可能表现出优势。&lt;/p&gt;

&lt;p&gt;关于两个 CopyOnWrite 容器，其实 CopyOnWriteArraySet 是通过包装了CopyOnWriteArrayList 来实现的
首先，CopyOnWrite 到底是什么意思呢？它的原理是，任何修改操作，如 add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean add (E e){
    synchronized (lock) {
        Object[] elements = getArray();
        int len = elements.length;
        // 拷贝
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        // 替换
        setArray(newElements);
        return true;
    }
}
final void setArray (Object[]a){
    array = a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;并发包中的-concurrentlinkedqueue-和-linkedblockingqueue-有什么区别&#34;&gt;并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue 内部则是基于锁，并提供了 BlockingQueue 的等待性方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;java.util.concurrent 包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为 Concurrent、CopyOnWrite和 Blocking* 等三类，同样是线程安全容，可以简单认为：
* Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。
* Concurrent 往往提供了较低的遍历一致性（弱一致性）。例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。size 等操作准确性是有限的。读取的性能具有一定的不确定性。
* 与弱一致性对应的，就是我介绍过的同步容器常见的行为“fast-fail”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。&lt;/p&gt;

&lt;h2 id=&#34;哪些队列是有界的-哪些是无界的&#34;&gt;哪些队列是有界的，哪些是无界的？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ianeiu.github.io/resouce/java/mianshi/Queue.png&#34;  alt=&#34;Queue&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以从不同的角度进行分类，从基本的数据结构的角度分析，有两个特别的Deque实现，ConcurrentLinkedDeque 和 LinkedBlockingDeque。Deque 的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如:
* 尾部插入时需要的addLast(e)、offerLast(e)。
* 尾部删除所需要的removeLast()、pollLast()。&lt;/p&gt;

&lt;p&gt;从行为特征来看，绝大部分 Queue 都是实现了 BlockingQueue 接口。
在常规队列操作基础上，Blocking 意味着其提供了特定的等待性操作，获取时（take）等待元素进队，或者插入时（put）等待队列出现空位。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* 获取并移除队列头结点，如果必要，其会等待直到队列出现元素
…
*/
E take() throws InterruptedException;
/**
* 插入元素，如果队列已满，则等待直到队列出现空闲空间
…
*/
void put(E e) throws InterruptedException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个 BlockingQueue 经常被考察的点，就是是否有界（Bounded、Unbounded），这一点也往往会影响我们在应用开发中的选择。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ArrayBlockingQueue 是最典型的的有界队列，其内部以 final 的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建 ArrayBlockingQueue 时，都要指定容量，如
&lt;code&gt;
public ArrayBlockingQueue(int capacity, boolean fair)
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue，容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为Integer.MAX_VALUE，成为了无界队列。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SynchronousQueue，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PriorityBlockingQueue 是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DelayedQueue 和 LinkedTransferQueue 同样是无边界的队列。对于无边界的队列，有一个自然的结果，就是 put 操作永远也不会发生其他 BlockingQueue 的那种等待情况。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分析不同队列的底层实现，BlockingQueue 基本都是基于锁实现，一起来看看典型的LinkedBlockingQueue。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** Lock held by take, poll, etc */
private final ReentrantLock takeLock = new ReentrantLock();

/** Wait queue for waiting takes */
private final Condition notEmpty = takeLock.newCondition();

/** Lock held by put, offer, etc */
private final ReentrantLock putLock = new ReentrantLock();

/** Wait queue for waiting puts */
private final Condition notFull = putLock.newCondition();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayBlockingQueue，其条件变量与 LinkedBlockingQueue 版本的实现是有区别的，notEmpty、notFull都是同一个再入锁的条件变量，
而 LinkedBlockingQueue 则改进了锁操作的粒度，头、尾操作使用不同的锁，所以在通用场景下，它的吞吐量相对要更好一些。&lt;/p&gt;

&lt;p&gt;LinkedBlockingQueue 的 take 方法与 ArrayBlockingQueue 中的实现，也是有不同的，由于其内部结构是链表，需要自己维护元素数量值。&lt;/p&gt;

&lt;p&gt;类似 ConcurrentLinkedQueue 等，则是基于 CAS 的无锁技术，不需要在每个操作时使用锁，所以扩展性表现要更加优异。&lt;/p&gt;

&lt;p&gt;相对比较另类的 SynchronousQueue，在 Java 6 中，其实现发生了非常大的变化，利用 CAS
替换掉了原本基于锁的逻辑，同步开销比较小。它是 Executors.newCachedThreadPool() 的
默认队列。&lt;/p&gt;

&lt;h2 id=&#34;队列使用场景与典型用例&#34;&gt;队列使用场景与典型用例&lt;/h2&gt;

&lt;p&gt;在实际开发中，我提到过 Queue 被广泛使用在生产者 - 消费者场景，比如利用BlockingQueue 来实现，由于其提供的等待机制，我们可以少操心很多协调工作。&lt;/p&gt;

&lt;p&gt;在日常的应用开发中，如何进行选择呢？&lt;br /&gt;
以 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue 为例&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;考虑应用场景中对队列边界的要求。ArrayBlockingQueue 是有明确的容量限制的，而LinkedBlockingQueue 则取决于我们是否在创建时指定，SynchronousQueue 则干脆不能缓存任何元素。&lt;/li&gt;
&lt;li&gt;从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。&lt;/li&gt;
&lt;li&gt;通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。&lt;/li&gt;
&lt;li&gt;ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。&lt;/li&gt;
&lt;li&gt;如果我们需要实现的是两个线程之间接力性（handoff）的场景，可选择 CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。&lt;/li&gt;
&lt;li&gt;可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;java-并发类库提供的线程池有哪几种-分别有什么特点&#34;&gt;Java 并发类库提供的线程池有哪几种？ 分别有什么特点？&lt;/h2&gt;

&lt;p&gt;通常开发者都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。&lt;/p&gt;

&lt;p&gt;Executors 目前提供了 5 种不同的线程池创建配置：
* newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。
* newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。
* newSingleThreadExecutor()，它创建的是个 ScheduledExecutorService，也就是可以进行定时或周期性的工作调度。工作线程数目被限制为 1，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。
* newScheduledThreadPool(int corePoolSize)，同样是 ScheduledExecutorService，区别在于它会保持 corePoolSize 个工作线程。
* newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ianeiu.github.io/resouce/java/mianshi/Executor.png&#34;  alt=&#34;Executor&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Executor 是一个基础的接口，其初衷是将任务提交和任务执行细节解耦，这一点可以体会其定义的唯一方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void execute(Runnable command);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ExecutorService 则更加完善，不仅提供 service 的管理功能，比如 shutdown 等方法，也提供了更加全面的提交任务机制，如返回Future而不是 void 的 submit 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这个例子输入的可是Callable，它解决了 Runnable 无法返回结果的困扰。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java 标准类库提供了几种基础实现，比如ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool。这些线程池的设计特点在于其高度的可调节性和灵活性，以尽量满足复杂多变的实际应用场景。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Executors 则从简化使用的角度，为我们提供了各种方便的静态工厂方法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;threadpoolexecutor&#34;&gt;ThreadPoolExecutor&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ianeiu.github.io/resouce/java/mianshi/ThreadPoolExecutor.png&#34;  alt=&#34;ThreadPoolExecutor&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工作队列负责存储用户提交的各个任务，这个工作队列，可以是容量为 0 的 SynchronousQueue（使用 newCachedThreadPool），也可以是像固定大小线程池（newFixedThreadPool）那样使用 LinkedBlockingQueue
&lt;code&gt;
private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内部的“线程池”，这是指保持工作线程的集合，线程池需要在运行过程中管理线程创建、销毁。例如，对于带缓存的线程池，当任务压力较大时，线程池会创建新的工作线程；当业务压力退去，线程池会在闲置一段时间（默认 60 秒）后结束线程。
&lt;code&gt;
private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ThreadFactory 提供上面所需要的创建线程逻辑。&lt;/li&gt;
&lt;li&gt;如果任务提交时被拒绝，比如线程池已经处于 SHUTDOWN 状态，需要为其提供处理逻辑，Java 标准库提供了类似ThreadPoolExecutor.AbortPolicy等默认实现，也可以按照实际需求自定义。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程池的几个基本组成部分，一起都体现在线程池的构造函数中：
* corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目（除非设置了allowCoreThreadTimeOut）。对于不同的线程池，这个值可能会有很大区别，比如newFixedThreadPool 会将其设置为 nThreads，而对于 newCachedThreadPool 则是为0。
* maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数。同样进行对比，对于 newFixedThreadPool，当然就是 nThreads，因为其要求是固定大小，而newCachedThreadPool 则是 Integer.MAX_VALUE。
* keepAliveTime 和 TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。
* workQueue，工作队列，必须是 BlockingQueue。&lt;/p&gt;

&lt;p&gt;通过配置不同的参数，我们就可以创建出行为大相径庭的线程池，这就是线程池高度灵活性的基础。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
        int maximumPoolSize,
        long keepAliveTime,
        TimeUnit unit,
        BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
        ThreadFactory threadFactory,
        RejectedExecutionHandler handler)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;线程池实践&#34;&gt;线程池实践&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;避免任务堆积。newFixedThreadPool 是创建指定数目的线程，但是其工作队列是无界的，如果工作线程数目太少，导致处理跟不上入队的速度，这就很有可能占用大量统内存，甚至是出现 OOM。诊断时，你可以使用 jmap 之类的工具，查看是否有大量的任务对象入队。&lt;/li&gt;
&lt;li&gt;避免过度扩展线程。我们通常在处理大量短时任务时，使用缓存的线程池，比如在最新的HTTP/2 client API 中，目前的默认实现就是如此。我们在创建线程池的时候，并不能准确预计任务压力有多大、数据特征是什么样子（大部分请求是 1K 、100K 还是 1M 以上？），所以很难明确设定一个线程数目。&lt;/li&gt;
&lt;li&gt;如果线程数目不断增长（可以使用 jstack 等工具检查），也需要警惕另外一种可能性，就是线程泄漏，这种情况往往是因为任务逻辑有问题，导致工作线程迟迟不能被释放。建议你排查下线程栈，很有可能多个线程都是卡在近似的代码处。&lt;/li&gt;
&lt;li&gt;避免死锁等同步问题，对于死锁的场景和排查&lt;/li&gt;
&lt;li&gt;尽量避免在使用线程池时操作 ThreadLocal。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;线程池大小的选择策略&#34;&gt;线程池大小的选择策略&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果我们的任务主要是进行计算，那么就意味着 CPU 的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照 CPU 核的数目 N 或者 N+1。&lt;/li&gt;
&lt;li&gt;如果是需要较多等待的任务，例如 I/O 操作比较多，可以参考 Brain Goetz 推荐的计算方法：线程数 = CPU 核数 × （1 + 平均等待时间 / 平均工作时间）&lt;/li&gt;
&lt;li&gt;上面是仅仅考虑了 CPU 等限制，实际还可能受各种系统资源（文件句柄、内存）限制影响&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;atomicinteger-底层实现原理是什么-如何在自己的代码中应用cas-操作&#34;&gt;AtomicInteger 底层实现原理是什么？如何在自己的代码中应用CAS 操作？&lt;/h2&gt;

&lt;p&gt;AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术&lt;/p&gt;

&lt;p&gt;CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。
如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。&lt;/p&gt;

&lt;p&gt;从 AtomicInteger 的内部属性可以看出，它依赖于 Unsafe 提供的一些底层能力，进行底层操作；以 volatile 的 value 字段，记录数值，以保证可见性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();
private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &amp;quot;value&amp;quot;);
private volatile int value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的原子操作细节，可以参考任意一个原子更新方法，比如下面的 getAndIncrement。Unsafe 会利用 value 字段的内存地址偏移，直接完成操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final int getAndIncrement() {
    return U.getAndAddInt(this, VALUE, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 getAndIncrement 需要返归数值，所以需要添加失败重试逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而类似 compareAndSet 这种返回 boolean 类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final boolean compareAndSet(int expectedValue, int newValue)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CAS 是 Java 并发中所谓 lock-free 机制的基础。&lt;/p&gt;

&lt;p&gt;Java 9 中移除了 Unsafe.moniterEnter()/moniterExit()，导致无法平滑升级到新的 JDK 版本。
目前 Java 提供了两种公共 API，可以实现这种 CAS 操作，比如使用 java.util.concurrent.atomic.AtomicLongFieldUpdater，它是基于反射机制创建，我们需要保证类型和字段名称正确。&lt;/p&gt;

&lt;p&gt;Atomic 包提供了最常用的原子性数据类型，甚至是引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选。&lt;br /&gt;
atomic 包提供的LongAdder，在高度竞争环境下，可能就是比 AtomicLong 更佳的选择，尽管它的本质是空间换时间。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java面试题</title>
      <link>https://ianeiu.github.io/2020/02/15/java%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/02/15/java%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      
        <description>

&lt;h2 id=&#34;java平台理解及java是解释执行吗&#34;&gt;Java平台理解及Java是解释执行吗？&lt;/h2&gt;

&lt;p&gt;首先Java是一种面向对象的语言，本身具有两个特性：一个是跨平台能力（一次编写，到处运行），屏蔽了操作系统和硬件的细节；
第二个就是垃圾自动回收机制（GC）。&lt;/p&gt;

&lt;p&gt;我们日常接触到的jre（Java runtime environment）和jdk（Java development kit），
jre是Java运行时环境，包含了JVM和java类库；
jdk则是Java开发工具，里面提供了许多开发工具如；编译器(javac)、诊断和监控(jconsole)工具等。&lt;/p&gt;

&lt;p&gt;java生态：spring，spark，elasticsearch，maven&lt;/p&gt;

&lt;p&gt;不完全正确，Java是通过对源文件进行编译成字节码文件（.class），然后jvm（Java虚拟机）对字节码文件逐条进行解释运行。
但是往往有一部分热点代码（hot spot）会占有大部分时间解释，所以Java中会有jit（Just-In-Time）。即时编译器将该部分直接编译成机器代码直接运行，大大提高效率。
这部分热点代码就是编译执行了而不是解释执行。&lt;/p&gt;

&lt;p&gt;在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。
主流 Java 版本中，如 JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。
通常运行在 server 模式的 JVM，会进行上万次调用以收集足够的信息进行高效的编译，client 模式这个门限是 1500 次。
Oracle Hotspot JVM 内置了两个不同的 JIT compiler，
C1 对应前面说的 client 模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用；
C2 对应 server 模式，它的优化是为长时间运行的服务器端应用设计的，默认是采用所谓的分层编译（TieredCompilation）。&lt;/p&gt;

&lt;p&gt;除了我们日常最常见的 Java 使用模式，其实还有一种新的编译方式，
即所谓的 AOT（Aheadof-Time Compilation），直接将字节码编译成机器代码，
这样就避免了 JIT 预热等各方面的开销，
比如 Oracle JDK 9 就引入了实验性的 AOT 特性，并且增加了新的 jaotc 工具。&lt;/p&gt;

&lt;h2 id=&#34;java创建对象的方式&#34;&gt;java创建对象的方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;使用new关键字创建对象&lt;/li&gt;
&lt;li&gt;使用Class类的newInstance方法(反射机制)&lt;/li&gt;
&lt;li&gt;使用Constructor类的newInstance方法(反射机制)&lt;/li&gt;
&lt;li&gt;使用Clone方法创建对象&lt;/li&gt;
&lt;li&gt;使用(反)序列化机制创建对象&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;java的多态表现在哪里&#34;&gt;java的多态表现在哪里&lt;/h2&gt;

&lt;p&gt;主要有两种表现形式：重载和重写&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重载：发生在同一类中，具有相同的方法名，主要是看参数的个数，类型，顺序不同实现方法的重载的，返回值的类型可以不同。&lt;/li&gt;
&lt;li&gt;重写：发生在两个类中（父类和子类），具有相同的方法名，主要看方法中参数，个数，类型必须相同，返回值的类型必须相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exception和error有什么区别&#34;&gt;Exception和Error有什么区别&lt;/h2&gt;

&lt;p&gt;Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。&lt;/p&gt;

&lt;p&gt;Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。&lt;/p&gt;

&lt;p&gt;Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM自身）处于非正常的、不可恢复状态。
既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。&lt;/p&gt;

&lt;p&gt;Exception 又分为可检查（checked）异常和不检查（unchecked）异常。
可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。
不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。&lt;/p&gt;

&lt;p&gt;扩展:&lt;br /&gt;
1. NoClassDefFoundError 和 ClassNotFoundException 有什么区别，这也是个经典的入门题目。
2. 理解 Java 语言中操作 Throwable 的元素和实践。掌握最基本的语法是必须的，如 trycatch-finally 块，throw、throws 关键字等。
3. 与此同时，也要懂得如何处理典型场景。&lt;/p&gt;

&lt;p&gt;异常处理原则
1. 尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常。
进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。
2. 不要生吞（swallow）异常&lt;/p&gt;

&lt;p&gt;try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，
所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码。&lt;/p&gt;

&lt;p&gt;请勿在try代码块中调用return、break或continue语句。万一无法避免，一定要确保finally的存在不会改变函数的返回值（不要在finally代码块中处理返回值）。&lt;/p&gt;

&lt;h2 id=&#34;noclassdeffounderror-和-classnotfoundexception-有什么区别&#34;&gt;NoClassDefFoundError 和 ClassNotFoundException 有什么区别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;ClassNotFoundException&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;NoClassDefFoundError&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;从java.lang.Exception继承，是一个Exception类型&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从java.lang.Error继承，是一个Error类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;当动态加载Class的时候找不到类会抛出该异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当编译成功以后执行过程中Class找不到导致抛出该错误&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;一般在执行Class.forName()、ClassLoader.loadClass()或ClassLoader.findSystemClass()的时候抛出&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;由JVM的运行时系统抛出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;final-finally-finalize有什么不同&#34;&gt;final、finally、 finalize有什么不同&lt;/h2&gt;

&lt;p&gt;final 可以用来修饰类（不可继承扩展）、方法（不能重写）、变量（字段值不能修改。&lt;/p&gt;

&lt;p&gt;finally 异常处理理机制的关键字，表示最后执⾏行行。来进行类似关闭 JDBC 连接、保证 unlock 锁、释放资源等动作。&lt;/p&gt;

&lt;p&gt;finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。
finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为deprecated。
Java 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。&lt;/p&gt;

&lt;h2 id=&#34;不可变-immutable&#34;&gt;不可变 Immutable&lt;/h2&gt;

&lt;p&gt;Immutable 在很多场景是非常棒的选择，某种意义上说，Java 语言目前并没有原生的不可变支持，&lt;/p&gt;

&lt;p&gt;如果要实现 immutable 的类，我们需要做到：
1. 将 class 自身声明为 final，这样别人就不能扩展来绕过限制了。
2. 将所有成员变量定义为 private 和 final，并且不要实现 setter 方法。
3. 通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。
4. 如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，使用 copy-on-write原则，创建私有的 copy。&lt;/p&gt;

&lt;h2 id=&#34;string-stringbuffer-stringbuilder-有什么区别&#34;&gt;String、StringBuffer、StringBuilder 有什么区别？&lt;/h2&gt;

&lt;p&gt;String是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性类似拼接、裁剪字符串等动作，都会产生新的 String 对象。&lt;/p&gt;

&lt;p&gt;原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。&lt;/p&gt;

&lt;p&gt;StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是StringBuilder。&lt;/p&gt;

&lt;p&gt;为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。&lt;br /&gt;
另外，这个内部数组应该创建成多大的呢？如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。
目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。
我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。
扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy&lt;/p&gt;

&lt;h4 id=&#34;字符串缓存&#34;&gt;字符串缓存&lt;/h4&gt;

&lt;p&gt;String 在 Java 6 以后提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。
在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。
一般来说，JVM 会将所有的类似“abc”这样的文本字符串，或者字符串常量之类缓存起来。&lt;/p&gt;

&lt;p&gt;看起来很不错是吧？但实际情况估计会让你大跌眼镜。一般使用 Java 6 这种历史版本，并不推荐大量使用 intern，为什么呢？
魔鬼存在于细节中，被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。
所以，如果使用不当，OOM 就会光顾。&lt;/p&gt;

&lt;p&gt;在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在JDK 8 中被 MetaSpace（元数据区）替代了。
而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用参数直接打印具体数字 &lt;code&gt;-XX:+PrintStringTableStatistics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;手动调整大小 &lt;code&gt;-XX:StringTableSize=N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intern 是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；
另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。&lt;br /&gt;
幸好在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。
它是通过将相同数据的字符串指向同一份数据来做到的，是 JVM 底层的改变，并不需要 Java 类库做什么修改。
这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用 G1 GC：&lt;br /&gt;
&lt;code&gt;-XX:+UseStringDeduplication&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;动态代理是基于什么原理&#34;&gt;动态代理是基于什么原理？&lt;/h2&gt;

&lt;p&gt;通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。&lt;/p&gt;

&lt;p&gt;Java 发射机制的常见应用：动态代理（AOP、RPC）、提供第三方开发者扩展能力（Servlet容器，JDBC连接）、第三方组件创建对象（DI）……&lt;/p&gt;

&lt;p&gt;动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，
比如用来包装 RPC 调用、面向切面的编程（AOP）。&lt;/p&gt;

&lt;p&gt;实现动态代理的方式很多，
比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。
还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。&lt;/p&gt;

&lt;p&gt;JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。新版本也开始结合ASM机制。
cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。&lt;/p&gt;

&lt;p&gt;JDK Proxy 的优势：
* 最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。
* 平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。
* 代码实现简单。&lt;/p&gt;

&lt;p&gt;基于类似 cglib 框架的优势：
*  有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。
*  只操作我们关心的类，而不必为其他相关类增加工作量。
*  高性能。&lt;/p&gt;

&lt;h2 id=&#34;有哪些方法可以在运行时动态生成一个-java-类&#34;&gt;有哪些方法可以在运行时动态生成一个 Java 类&lt;/h2&gt;

&lt;p&gt;直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。本质上还是在当前程序进程之外编译的。&lt;/p&gt;

&lt;p&gt;使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能。&lt;/p&gt;

&lt;p&gt;直接生成相应的字节码，然后交给类加载器去加载。通常我们可以利用 Java 字节码操纵工具和类库 ASM、Javassist、cglib 等 来实现。&lt;/p&gt;

&lt;h2 id=&#34;字节码和类加载到底是怎么无缝进行转换的-发生在整个类加载过程的哪一步&#34;&gt;字节码和类加载到底是怎么无缝进行转换的？发生在整个类加载过程的哪一步？&lt;/h2&gt;

&lt;p&gt;类从字节码到 Class 对象的转换，在类加载过程中，这一步是通过下面的方法提供的功能，或者 defineClass 的其他本地对等实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//只选取了最基础的两个典型的 defineClass 实现
protected final Class&amp;lt;?&amp;gt; defineClass(String name, byte[] b, int off, int len,
            ProtectionDomain protectionDomain)
protected final Class&amp;lt;?&amp;gt; defineClass(String name, java.nio.ByteBuffer b,
            ProtectionDomain protectionDomain)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要能够生成出规范的字节码，不管是作为 byte 数组的形式，还是放到 ByteBuffer里，都可以平滑地完成字节码到 Java 对象的转换过程。&lt;br /&gt;
JDK 提供的 defineClass 方法，最终都是本地代码实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private native Class&amp;lt;?&amp;gt; defineClass0(String name, byte[] b, int off, int len,
                                     ProtectionDomain pd);

private native Class&amp;lt;?&amp;gt; defineClass1(String name, byte[] b, int off, int len,
                                     ProtectionDomain pd, String source);

private native Class&amp;lt;?&amp;gt; defineClass2(String name, java.nio.ByteBuffer b,
                                     int off, int len, ProtectionDomain pd,
                                     String source);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;相关的字节码操纵逻辑&#34;&gt;相关的字节码操纵逻辑&lt;/h4&gt;

&lt;p&gt;JDK dynamic proxy （1.8） 的实现代码，对应逻辑是实现在 Proxy类中的 ProxyClassFactory 这个静态内部类，
通过 ProxyGenerator 生成字节码，并以 byte 数组的形式保存，然后调用 本地 的 defineClass0 入口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * Generate the specified proxy class.
 */
byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
    proxyName, interfaces, accessFlags);
try {
    return defineClass0(loader, proxyName,
                        proxyClassFile, 0, proxyClassFile.length);
} catch (ClassFormatError e) {
    /*
     * A ClassFormatError here means that (barring bugs in the
     * proxy class generation code) there was some other
     * invalid aspect of the arguments supplied to the proxy
     * class creation (such as virtual machine limitations
     * exceeded).
     */
    throw new IllegalArgumentException(e.toString());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JDK 内部动态代理的逻辑，可以参考java.lang.reflect.ProxyGenerator的内部实现。
可以认为这是种另类的字节码操纵技术，这种实现方式的好处是没有太多依赖关系，但是前提是需要懂各种JVM 指令，知道怎么处理那些偏移地址等，实际门槛非常高，所以并不适合大多数的普通开发场景。&lt;/p&gt;

&lt;p&gt;Java 社区专家提供了各种从底层到更高抽象水平的字节码操作类库。JDK 内部也集成了 ASM 类库。&lt;/p&gt;

&lt;h2 id=&#34;如何利用字节码操纵技术-实现基本的动态代理逻辑&#34;&gt;如何利用字节码操纵技术，实现基本的动态代理逻辑？&lt;/h2&gt;

&lt;p&gt;对于一个普通的 Java 动态代理，其实现过程可以简化成为：
* 提供一个基础的接口，作为被调用类型（com.mycorp.HelloImpl）和代理类之间的统一入口，如 com.mycorp.Hello。
* 实现InvocationHandler，对代理对象方法的调用，会被分派到其 invoke 方法来真正实现动作。
* 通过 Proxy 类，调用其 newProxyInstance 方法，生成一个实现了相应基础接口的代理类实例，可以看下面的方法签名。
    &lt;code&gt;
    public static Object newProxyInstance(ClassLoader loader,
    Class&amp;lt;?&amp;gt;[] interfaces,
    InvocationHandler h)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用 ASM 实现的简要过程:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
cw.visit(V1_8, // 指定 Java 版本
        ACC_PUBLIC, // 说明是 public 类型
        &amp;quot;com/mycorp/HelloProxy&amp;quot;, // 指定包和类的名称
        null, // 签名，null 表示不是泛型
        &amp;quot;java/lang/Object&amp;quot;, // 指定父类
        new String[]{ &amp;quot;com/mycorp/Hello&amp;quot; }); // 指定需要实现的接口

MethodVisitor mv = cw.visitMethod(
                ACC_PUBLIC, // 声明公共方法
                &amp;quot;sayHello&amp;quot;, // 方法名称
                &amp;quot;()Ljava/lang/Object;&amp;quot;, // 描述符
                null, // 签名，null 表示不是泛型
                null); // 可能抛出的异常，如果有，则指定字符串数组
mv.visitCode();
// 省略代码逻辑实现细节
cw.visitEnd(); // 结束类字节码生成
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同的 visitX 方法提供了创建类型，创建各种方法等逻辑。ASM API，广泛的使用了Visitor模式。
按照前面的分析，字节码操作最后大都应该是生成 byte 数组，ClassWriter 提供了一个简便的方法。&lt;code&gt;cw.toByteArray();&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;除了动态代理-字节码操纵技术还有那些应用场景&#34;&gt;除了动态代理，字节码操纵技术还有那些应用场景？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;各种 Mock 框架&lt;/li&gt;
&lt;li&gt;ORM 框架&lt;/li&gt;
&lt;li&gt;IOC 容器&lt;/li&gt;
&lt;li&gt;部分 Profiler 工具，或者运行时诊断工具等&lt;/li&gt;
&lt;li&gt;生成形式化代码的工具&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;假如我们有这样一个需求-需要添加某个功能-例如对某类型资源如网络通信的消耗进行统计-重点要求是-不开启时必须是零开销-而不是低开销&#34;&gt;假如我们有这样一个需求，需要添加某个功能，例如对某类型资源如网络通信的消耗进行统计，重点要求是，不开启时必须是零开销，而不是低开销&lt;/h2&gt;

&lt;p&gt;将资源消耗的这个实例，用动态代理的方式创建这个实例动态代理对象，在动态代理的invoke中添加新的需求。
开始使用代理对象，不开启则使用原来的方法，因为动态代理是在运行时创建。所以是零消耗。&lt;/p&gt;

&lt;h2 id=&#34;设计模式应用例子&#34;&gt;设计模式应用例子&lt;/h2&gt;

&lt;p&gt;装饰模式：BufferedInputStream 经过包装，为输入流过程增加缓存，类似这种装饰器还可以多次嵌套，不断地增加不同层次的功能。
&lt;code&gt;public BufferedInputStream(InputStream in)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;构建器模式：，JDK 最新版本中 HTTP/2 Client API，下面这个创建 HttpRequest的过程就是典型的构建器模式（Builder），
通常会被实现成fluent 风格的 API，也有人叫它方法链。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HttpRequest request = HttpRequest.newBuilder(new URI(uri))
                        .header(headerAlice, valueAlice)
                        .headers(headerBob, value1Bob,
                        headerCarl, valueCarl,
                       headerBob, value2Bob)
                        .GET()
                        .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Spring&lt;br /&gt;
* BeanFactory和ApplicationContext应用了工厂模式。
* 在 Bean 的创建中，Spring 也为不同 scope 定义的对象，提供了单例和原型等模式实现。
* AOP 领域则是使用了代理模式、装饰器模式、适配器模式等。
* 各种事件监听器，是观察者模式的典型应用。
* 类似 JdbcTemplate 等则是应用了模板模式。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java开发之命名规范</title>
      <link>https://ianeiu.github.io/2020/01/15/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/01/15/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</guid>
      
        <description>

&lt;p&gt;原文： &lt;a href = &#34;https://mp.weixin.qq.com/s/q_C9daCZTq1SR0zwkrwyag&#34; target =&#34;_blank&#34;&gt;编码5分钟，命名2小时？史上最全的Java命名规范参考！&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-java中的命名规范&#34;&gt;一、Java中的命名规范&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;类型(名)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;约束&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;项目&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;全部小写&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;多个单词用中划线分隔‘-’  spring-cloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;包&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;全部小写&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;com.alibaba.fastjson&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;类&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;单词首字母大写&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Feature,FieldDeserializer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;变量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;首字母小写多个单词组成时，除首个单词其他单词首字母都要大写&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;password, userName&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;常量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;全部大写，多个单词，用&amp;rsquo;_&amp;lsquo;分隔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CACHEEXPIREDTIME&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同变量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;read(), getById(Long id)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;二-包命名&#34;&gt;二、包命名&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;前缀&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;indi或onem&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;indi.发起者名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;个体项目&lt;br/&gt;个人发起，但非自己独自完成&lt;br/&gt;可公开或私有项目，copyright主要属于发起者。&lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pers&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pers.个人名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;个人项目&lt;br/&gt;指个人发起，独自完成，&lt;br/&gt;可分享的项目,copyright主要属于个人&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;priv&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;priv.个人名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;私有项目，指个人发起，独自完成&lt;br/&gt;非公开的私人使用的项目，copyright属于个人。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;team&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;team.团队名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;团队项目，指由团队发起&lt;br/&gt;并由该团队开发的项目,copyright属于该团队所有&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;顶级域名&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;com.公司名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;公司项目，copyright由项目发起的公司所有&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;三-类命名&#34;&gt;三、类命名&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;属性&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;约束&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;抽象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Abstract 或 Base 开头&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BaseUserService&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;枚举&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Enum 作为后缀&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OSType&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;工具&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Utils作为后缀&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;StringUtils&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Exception结尾&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;RuntimeException&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;接口实现&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;接口名+ Impl&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;UserServiceImpl&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;领域模型相&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/DO/DTO/VO/DAO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;正例：UserDAO 反例：UserDao&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;设计模式相关&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Builder，Factory等&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当使用到设计模式时要使用对应的设计模式作为后缀，如ThreadFactory&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;处理特定功能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Handler，Predicate，Validator&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;表示处理器，校验器，断言&lt;br/&gt;这些类工厂还有配套的方法名，如handle，predicate，validate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;测试&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Test后缀&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;UserServiceTest，表示用来测试UserService类的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;MVC分层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Controller，Service，ServiceImpl，DAO后缀&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;UserManageController，UserManageDAO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;四-方法&#34;&gt;四、方法&lt;/h2&gt;

&lt;p&gt;注：pre- prefix前缀，suf- suffix后缀，alo-alone 单独使用&lt;/p&gt;

&lt;h4 id=&#34;4-1-返回真伪值的方法-pre&#34;&gt;4.1 返回真伪值的方法（pre）&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;is&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对象是否符合期待的状态&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;isValid&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;can&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对象能否执行所期待的动作&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;canRemove&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;should&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;调用方执行某个命令或方法是好还是不好、应不应该，&lt;br/&gt;或者说推荐还是不推荐&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;shouldMigrate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;has&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对象是否持有所期待的数据和属性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;hasObservers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;needs&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;调用方是否需要执行某个命令或方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;needsMigrate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-2-用来检查的方法&#34;&gt;4.2 用来检查的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ensure&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;检查是否为期待的状态，不是则抛出异常或返回error code&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ensureCapacity&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;validate&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;检查是否为正确的状态，不是则抛出异常或返回error code&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;validateInputs&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-3-按需求才执行的方法&#34;&gt;4.3 按需求才执行的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;位置&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;IfNeeded&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要的时候执行，不需要则什么都不做&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;drawIfNeeded&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;might&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;mightCreate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;try&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;尝试执行，失败时抛出异常，或是返回errorcode&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;tryCreate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OrDefault&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;尝试执行，失败时返回默认值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;getOrDefault&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OrElse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;尝试执行，失败时返回，实际参数中指定的值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;getOrElse&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;force&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;强制尝试执行，error抛出异常或是返回值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;forceCreate, forceStop&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-4-异步相关方法&#34;&gt;4.4 异步相关方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;位置&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;blocking&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;线程阻塞方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;blockingGetUser&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;InBackground&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;执行在后台线程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;doInBackground&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Async&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;异步方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sendAsync&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sync&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同步方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sendSync&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;schedule&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Job和Task放入队列&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;schedule, scheduleJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;post&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;postJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;execute&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;执行异步或同步方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;execute,executeTask&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;start&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;star,startJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;cancel&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;停止异步方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;cancel,cancelJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;stop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;stop,stopJob&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-5-回调方法&#34;&gt;4.5 回调方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;位置&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;on&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事件发生时执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;onCompleted&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;before&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事件发生前执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;beforeUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;preUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;will&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;willUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;after&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事件发生后执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;afterUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;post&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;postUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;did&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;didUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;should&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;确认事件是否可以执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;shouldUpdate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-6-操作对象生命周期的方法&#34;&gt;4.6 操作对象生命周期的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;initialize&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;初始化或延迟初始化使用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;initialize&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pause&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;暂停&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;onPause,pause&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;stop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;停止&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;onStop,stop&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;abandon&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;销毁的替代&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;abandon&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;destroy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;destroy&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dispose&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dispose&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-7-与集合操作相关的方法&#34;&gt;4.7 与集合操作相关的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;contains&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是包含指定对象相同的对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;contains&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;add&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;addJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;append&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;appendJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;insert&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;插入到下标n&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;insertJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;put&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加与key对应的元素&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;putJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;remove&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;移除元素&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;removeJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;enqueue&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加到队列的最末位&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;enqueueJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dequeue&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从队列中头部取出并移除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dequeueJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;push&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加到栈头&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pushJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从栈头取出并移除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;popJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;peek&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从栈头取出但不移除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;peekJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;find&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;寻找符合条件的某物&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;findById&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-8-与数据相关的方法&#34;&gt;4.8 与数据相关的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;create&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;新创建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;createAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;new&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;新创建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;newAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;from&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从既有的某物新建或是从其他的数据新建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;fromConfig&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;to&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;转换&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;toString&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;update&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;更新既有某物&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;updateAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;load&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;读取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;loadAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;fetch&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;远程读取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;fetchAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;delete&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;deleteAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;remove&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;removeAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;save&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;saveAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;store&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;storeAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;commit&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;commitChange&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;apply&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保存或应用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;applyChange&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;clear&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;清除或是恢复到初始状态&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;clearAll&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;reset&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;清除或是恢复到初始状态&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;resetAll&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-9-成对出现的动词&#34;&gt;4.9 成对出现的动词&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词/意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;单词/意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;get获取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;set 设置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;add 增加&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;remove 删除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;create 创建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;destory 移除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;start 启动&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;stop 停止&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;open 打开&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;close 关闭&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;read 读取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;write 写入&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;load 载入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;save 保存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;create 创建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;destroy 销毁&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;begin 开始&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;end 结束&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;backup 备份&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;restore 恢复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;import 导入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;export 导出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;split 分割&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;merge 合并&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;inject 注入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;extract 提取&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;attach 附着&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;detach 脱离&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;bind 绑定&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;separate 分离&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;view 查看&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;browse 浏览&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;edit 编辑&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;modify 修改&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;select 选取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;mark 标记&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;copy 复制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;paste 粘贴&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;undo 撤销&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;redo 重做&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;insert 插入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;delete 移除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;add 加入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;append 添加&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;clean 清理&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;clear 清除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;index 索引&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sort 排序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;find 查找&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search 搜索&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;increase 增加&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;decrease 减少&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;play 播放&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pause 暂停&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;launch 启动&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;run 运行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;compile 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;execute 执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;debug 调试&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;trace 跟踪&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;observe 观察&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;listen 监听&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;build 构建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;publish 发布&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;input 输入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;output 输出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;encode 编码&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;decode 解码&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;encrypt 加密&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;decrypt 解密&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;compress 压缩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;decompress 解压缩&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pack 打包&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;unpack 解包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;parse 解析&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;emit 生成&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;connect 连接&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;disconnect 断开&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;send 发送&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;receive 接收&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;download 下载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;upload 上传&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;refresh 刷新&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;synchronize 同步&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;update 更新&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;revert 复原&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;lock 锁定&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;unlock 解锁&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;check out 签出&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;check in 签入&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;submit 提交&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;commit 交付&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;push 推&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pull 拉&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;expand 展开&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;collapse 折叠&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;begin 起始&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;end 结束&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;start 开始&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;finish 完成&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;enter 进入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;exit 退出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;abort 放弃&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;quit 离开&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;obsolete 废弃&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;depreciate 废旧&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;collect 收集&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;aggregate 聚集&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;五-变量-常量命名&#34;&gt;五，变量&amp;amp;常量命名&lt;/h2&gt;

&lt;h4 id=&#34;5-1-变量命名&#34;&gt;5.1 变量命名&lt;/h4&gt;

&lt;p&gt;变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 computedValues，index、变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。&lt;/p&gt;

&lt;p&gt;变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo中的布尔变量，都不要加is(数据库中的布尔字段全都要加 is_ 前缀)。&lt;/p&gt;

&lt;h4 id=&#34;5-2-常量命名&#34;&gt;5.2 常量命名&lt;/h4&gt;

&lt;p&gt;常量命名CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。那么什么是常量呢？&lt;/p&gt;

&lt;p&gt;常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，全局常量（public static final修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。&lt;/p&gt;

&lt;p&gt;常量一般都有自己的业务含义,不要害怕长度过长而进行省略或者缩写。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。&lt;/p&gt;

&lt;h4 id=&#34;通用命名规则&#34;&gt;通用命名规则&lt;/h4&gt;

&lt;p&gt;尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。正例：BeiJing， HangZhou 反例：validateCanShu&lt;/p&gt;

&lt;p&gt;命名过程中尽量不要出现特殊的字符，常量除外。&lt;/p&gt;

&lt;p&gt;尽量不要和jdk或者框架中已存在的类重名，也不能使用java中的关键字命名。&lt;/p&gt;

&lt;p&gt;妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。&lt;/p&gt;

&lt;h4 id=&#34;六-代码注解&#34;&gt;六，代码注解&lt;/h4&gt;

&lt;h4 id=&#34;6-1-注解的原则&#34;&gt;6.1 注解的原则&lt;/h4&gt;

&lt;p&gt;好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。&lt;/p&gt;

&lt;p&gt;优雅的注解通常要满足三要素。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nothing is strange 没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。&lt;/li&gt;
&lt;li&gt;Less is more 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。
&lt;code&gt;
// 根据id获取信息【废话注解】
getMessageById(id)
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Advance with the time 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;6-2-注解格式&#34;&gt;6.2 注解格式&lt;/h4&gt;

&lt;p&gt;注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。&lt;/p&gt;

&lt;p&gt;javadoc注解可以生成JavaAPI为外部用户提供有效的支持javadoc注解通常在使用IDEA或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。&lt;/p&gt;

&lt;p&gt;a. 包注解&lt;br /&gt;
包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 落地也质量检测
 * 1. 用来解决什么问题
 * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等; 模拟不同的网络：2G，3G，4G，wifi等
 *
 * 2. 如何实现
 * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络，OS参数，获取到浏览器返回结果。
 *
 * 注意：网络环境配置信息{@link cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum}目前使用是常规速度，可以根据实际情况进行调整
 *
 * @author cruder
 * @time 2019/12/7 20:3 下午
 */
package.cn.mycookies.landingpagecheck;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b. 类注接&lt;br /&gt;
javadoc注解中，每个类都必须有注解。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* Copyright (C), 2019-2020, Jann  balabala...
*
* 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....
*
* @author   类创建者姓名 保持对齐
* @date     创建日期 保持对齐
* @version  版本号 保持对齐
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c. 属性注解&lt;br /&gt;
在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** 提示信息 */
private String userName;
/**
 * 密码
 */
private String password;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;d. 方法注释&lt;br /&gt;
在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
  * 方法的详细说明，能干嘛，怎么实现的，注意事项...
  *
  * @param xxx      参数1的使用说明， 能否为null
  * @return 返回结果的说明， 不同情况下会返回怎样的结果
  * @throws 异常类型   注明从此类方法中抛出异常的说明
  */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;e. 构造方法注释&lt;br /&gt;
在每个构造方法前面必须加上注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
  * 构造方法的详细说明
  *
  * @param xxx      参数1的使用说明， 能否为null
  * @throws 异常类型   注明从此类方法中抛出异常的说明
  */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而简单注解往往是需要工程师字节定义，在使用注解时应该注意一下几点：&lt;/p&gt;

&lt;p&gt;枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。&lt;/p&gt;

&lt;p&gt;保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用1个空格分隔。&lt;/p&gt;

&lt;p&gt;对于不同的逻辑说明，可以用空行分隔&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;无论是命名和注解，他们的目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优秀的代码往往能够见名知意，注解往往是对命名的补充和完善。命名太南了！&lt;/p&gt;

&lt;p&gt;参考文献：&lt;br /&gt;
《码出高效》&lt;br /&gt;
&lt;code&gt;https://www.cnblogs.com/wangcp-2014/p/10215620.html&lt;/code&gt;
&lt;code&gt;https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6&lt;/code&gt;
&lt;code&gt;https://google.github.io/styleguide/javaguide.html#s2.1-file-name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;原文： &lt;a href = &#34;https://mp.weixin.qq.com/s/q_C9daCZTq1SR0zwkrwyag&#34; target =&#34;_blank&#34;&gt;编码5分钟，命名2小时？史上最全的Java命名规范参考！&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JVM之volatile关键字</title>
      <link>https://ianeiu.github.io/2019/07/25/jvm%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2019/07/25/jvm%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      
        <description>

&lt;h2 id=&#34;引入&#34;&gt;引入&lt;/h2&gt;

&lt;p&gt;Java内存模型简称JMM（Java Memory Model），是Java虚拟机所定义的一种抽象规范，
用来屏蔽不同硬件和操作系统的内存访问差异，让java程序在各种平台下都能达到一致的内存访问效果。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;主内存（Main Memory）&lt;br /&gt;
主内存可以简单理解为计算机当中的内存，但又不完全等同。&lt;br /&gt;
主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;工作内存（Working Memory）&lt;br /&gt;
工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。&lt;br /&gt;
每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。&lt;br /&gt;
线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。&lt;br /&gt;
不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于一个静态变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int s = 0；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程A执行如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = 3；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过一系列内存读写的操作指令，线程A把静态变量 s=0 从主内存读到工作内存，再把 s=3 的更新结果同步到主内存当中。&lt;/p&gt;

&lt;p&gt;从单线程的角度来看，这个过程没有任何问题。这时候我们引入线程B，执行如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(&amp;quot;s=&amp;quot; + s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有可能输出 0 或 3&lt;/p&gt;

&lt;p&gt;可以使用synchronized同步锁（影响性能）或者使用volatile关键字修饰（轻量）&lt;/p&gt;

&lt;h2 id=&#34;volatile-之-可见性&#34;&gt;volatile 之 可见性&lt;/h2&gt;

&lt;p&gt;volatile关键字具有许多特性，其中最重要的特性就是保证了用volatile修饰的变量对所有线程的可见性[当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值]。&lt;/p&gt;

&lt;p&gt;但volatile不能保证变量的原子性即无法保证线程安全。&lt;/p&gt;

&lt;h4 id=&#34;什么时候适合用&#34;&gt;什么时候适合用&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class VolatileTest {
    public volatile static int count = 0;
    
    public static void main(String[] args) {
        //开启 10个线程
        for (int i = 0; i &amp;lt; 10; i++) {
            new Thread(
                    new Runnable() {
                        public void run() {
                            try {
                                Thread.sleep(1);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            //每个线程当中让count值自增 100次
                            for (int j = 0; j &amp;lt; 100; j++) {
                                count++;
                            }
                        }
                    }
            ).start();
        }
        try {
            Thread.Weep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System, out.print(&amp;quot;count&amp;quot; + count);
        //最终count的结果值未必是1000，有可能小于1000。
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量不需要与其他的状态变量共同参与不变约束。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;volatile static int start = 3;
volatile static int end = 6;
    
线程A执行如下代码：
while (start &amp;lt; end){
  //do something
}
    
线程B执行如下代码：
start+=3;
end+=3;
    
//这种情况下，一旦在线程A的循环中执行了线程B，start有可能先更新成6，
//造成了一瞬间 start == end，从而跳出while循环的可能性。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;volatile-之-阻止指令重排&#34;&gt;volatile 之  阻止指令重排&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton2 {
    private static Singleton2 instance;

    public static Singleton2 getInstance() {
    	//双重检测机制
        if (instance == null) {
        	//同步锁
            synchronized (Singleton2.class) {
            	//双重检测机制
                if (instance == null) {
                    instance = new Singleton2();
                }
            }
        }
        return instance;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;已上代码存在问题，可能会得到一个没有初始化完成的对象&lt;/p&gt;

&lt;p&gt;JVM编译器的指令重排，可能会得到一个没有初始化的对象&lt;/p&gt;

&lt;p&gt;java中简单的一句 &lt;code&gt;instance = new Singleton&lt;/code&gt;，会被编译器编译成如下JVM指令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;memory =allocate();    //1：分配对象的内存空间 
ctorInstance(memory);  //2：初始化对象 
instance =memory;     //3：设置instance指向刚分配的内存地址 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;memory =allocate();    //1：分配对象的内存空间 
instance =memory;     //3：设置instance指向刚分配的内存地址 
ctorInstance(memory);  //2：初始化对象 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当线程A执行完1,3,时，instance对象还未完成初始化，但已经不再指向null。&lt;br /&gt;
此时如果线程B抢占到CPU资源，执行  if（instance == null）的结果会是false，从而返回一个没有初始化完成的instance对象。&lt;/p&gt;

&lt;p&gt;如何避免这一情况呢？我们需要在instance对象前面增加一个修饰符volatile。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java笔记之基础篇</title>
      <link>https://ianeiu.github.io/2019/02/13/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2019/02/13/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      
        <description>

&lt;p&gt;Java基础笔记整理&lt;/p&gt;

&lt;h2 id=&#34;关键字&#34;&gt;关键字&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用于定义数据类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;class interface  【引用数据类型：类、接口、数组】&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;boolean(1) char(2) byte(1) short(2) int(4) long(8) float(4) double(8) 【8个内置数据类型】&lt;br /&gt;
类型转换：&lt;br /&gt;
byte→short→int→→(可能丢失精度)float→→(可能丢失精度)long→→(可能丢失精度)double&lt;br /&gt;
char→int&lt;br /&gt;
int→long&lt;br /&gt;
int→double&lt;br /&gt;
float→double&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;void&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用于定义数据类型值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;true false null&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用于定义流程控制&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if else switch case default【选择】&lt;br /&gt;
【switch jdk5前：case byte\short\int\char。jdk5：case：enum。jdk7：case String】&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;while do for【循环】&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;break continue return【流程跳转】
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&#34;border:1px solid red;padding:10px 10px&#34;&gt;
    直接for循环效率最高，其次是迭代器和 ForEach操作。作为语法糖，ForEach底层是使用迭代器实现，反编译后testForEach方法如下，可以看到，只比迭代器遍历多了生成中间变量这一步，因为性能也略微下降了一些。&lt;/div&gt;
    

&lt;pre&gt;&lt;code&gt;```
public static void testForEach(List list) {  
    for (Iterator iterator = list.iterator(); iterator.hasNext();) {  
        Object t = iterator.next();  
        Object obj = t;  
    }  
}  
```
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用于定义访问权限修饰符

&lt;ul&gt;
&lt;li&gt;private public protected&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用于定义类、函数、变量

&lt;ul&gt;
&lt;li&gt;abstract final static synchronized&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类与类之间的关系

&lt;ul&gt;
&lt;li&gt;extends implements&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;建立实例、引用实例、判断实例

&lt;ul&gt;
&lt;li&gt;new this super instanceof&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;异常处理

&lt;ul&gt;
&lt;li&gt;try catch throw throws finally&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;包

&lt;ul&gt;
&lt;li&gt;package import&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;其它

&lt;ul&gt;
&lt;li&gt;native strictfp transient volatile assert&lt;/li&gt;
&lt;li&gt;goto const 【保留字】&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;标识符&#34;&gt;标识符&lt;/h2&gt;

&lt;p&gt;类、接口、方法、变量的名字&lt;br /&gt;
合法字符组成：英文字母、数字、$、_【不能以数字开头】&lt;/p&gt;

&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;单行 //&lt;/li&gt;
&lt;li&gt;多行 /**/&lt;/li&gt;
&lt;li&gt;文档 /**  */&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;字面值 &amp;ldquo;hello&amp;rdquo;,10.true&lt;/li&gt;
&lt;li&gt;自定义 final int LINK_CODE = 0;

&lt;ul&gt;
&lt;li&gt;final 修饰变量（基本类型值不变，引用类型地址值不变）（只能在构造方法执行之前赋值一次）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;类变量（静态变量）&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;实例变量（成员变量）&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;局部变量（本地变量）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;位置（代码）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;类中&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;类中方法外&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法定义中、方法声明上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;位置（内存）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法区中静态区&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;堆&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;栈&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;生命周期&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;随类加载而加载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;随对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;随方法&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;this无法存在静态中；&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;静态方法只能访问静态变量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;运算符&#34;&gt;运算符&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;算术运算符&lt;br /&gt;
&lt;code&gt;
% + - * / ++  --
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;br /&gt;
&lt;code&gt;
= += -= *= /= %=
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;比较运算符&lt;br /&gt;
&lt;code&gt;
== != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;= 
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;逻辑运算符&lt;br /&gt;
&lt;code&gt;
&amp;amp; | ^(异或) ! &amp;amp;&amp;amp; || 【&amp;amp;&amp;amp; || 有短路效果】
&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;位运算符&lt;br /&gt;
&lt;code&gt;
&amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt;(无符号右移) &amp;amp; | ^ ~(按位取反)
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三元运算符&lt;br /&gt;
&lt;code&gt;
max = a &amp;gt; b ? a : b
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码块&#34;&gt;代码块&lt;/h2&gt;

&lt;p&gt;代码块加载顺序： 静态代码块（类初始化）&amp;ndash;&amp;gt; 局部代码块 &amp;ndash;&amp;gt; 构造代码块（对象初始化）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Importtant06Code {
    static { System.out.println(&amp;quot;Importtant06Code静态代码块&amp;quot;);}

    public static void main(String[] args) {
        System.out.println(&amp;quot;main&amp;quot;);
        User user = new User();
        User user2 = new User();
    }
}

class User{
    static { System.out.println(&amp;quot;User静态代码块&amp;quot;);}
    {System.out.println(&amp;quot;User局部代码块&amp;quot;);}
    public User() {System.out.println(&amp;quot;User构造代码块&amp;quot;);}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Importtant06Code静态代码块
main
User静态代码块
User局部代码块
User构造代码块
User局部代码块
User构造代码块
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;java面向对象三大特性&#34;&gt;Java面向对象三大特性&lt;/h2&gt;

&lt;p&gt;封装、继承、多态&lt;/p&gt;

&lt;h2 id=&#34;类与对象&#34;&gt;类与对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;类：一组相关属性和行为的集合（抽象）&lt;/li&gt;
&lt;li&gt;对象：改类事物的具体表现形式（具体存在的个体）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;封装&#34;&gt;封装&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口&lt;br /&gt;
好处：隐藏实现细节,提供公共访问方式，复用性，安全性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关键字：private、this、static、new&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;userName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;wm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Demo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象构造过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将User.class文件加载到内存&lt;/li&gt;
&lt;li&gt;栈内存放置user，堆内存放置对象&lt;/li&gt;
&lt;li&gt;给成员变量进行初始化

&lt;ul&gt;
&lt;li&gt;默认初始化 name:null  age:0&lt;/li&gt;
&lt;li&gt;显示初始化 name:wm    age:18&lt;/li&gt;
&lt;li&gt;构造初始化 name:sg    age:25&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将地址值赋给变量user&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;从已有类得到继承信息创建新类的过程&lt;br /&gt;
好处：复用、维护、多态前提&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关键字：extends、this、super&lt;/p&gt;

&lt;h4 id=&#34;重载与重写&#34;&gt;重载与重写&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;重写（Override） 子类重写父类方法,多态的条件之一&lt;/li&gt;
&lt;li&gt;重载（Overload） 同一个类中不同参数的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;子类初始化之前会先进行父类的初始化&lt;/li&gt;
&lt;li&gt;父类没有无参构造，编译会报错&lt;/li&gt;
&lt;li&gt;子类重写父类方法，方法访问权限不能比之更低&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;多态&#34;&gt;多态&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;允许不同子类型的对象对同一消息作出不同的响应&lt;br /&gt;
好处： 维护、扩展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;父类接口指向子类对象，主要体现在抽象类&lt;/p&gt;

&lt;p&gt;Fu f = new Zi();&lt;br /&gt;
成员方法：编译看父类，运行看子类。&lt;br /&gt;
静态方法：编译看父类，运行看子类。&lt;br /&gt;
成员变量：编译看父类，运行看子类。&lt;br /&gt;
构造方法：编译看父类，运行看父子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;learn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d1tod4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Fu&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;new Fu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;show Fu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;function Fu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Zi&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;new Zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;show Zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;method zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;function Zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Demo04DuoTai&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nd&#34;&gt;@SuppressWarnings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;static-access&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;父类引用指向子类对象&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;父&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;子&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;找不到符号&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		
		&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;找不到符号&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		
		&lt;span class=&#34;o&#34;&gt;/*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;
		&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*/&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;kbd&gt;java多态的实现原理&lt;/kbd&gt;&lt;/p&gt;

&lt;p&gt;当JVM执行Java字节码时，类型信息会存储在方法区中，为了优化对象的调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。&lt;/p&gt;

&lt;p&gt;方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。
方法区的内存回收目标是针对常量池的回收及对类型的卸载。&lt;/p&gt;

&lt;p&gt;方法表的构造&lt;/p&gt;

&lt;p&gt;由于java的单继承机制，一个类只能继承一个父类，而所有的类又都继承Object类，方法表中最先存放的是Object的方法，接下来是父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。&lt;/p&gt;

&lt;p&gt;由于这样的特性，使得方法表的偏移量总是固定的，例如，对于任何类来说，其方法表的equals方法的偏移量总是一个定值，所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。&lt;/p&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;p&gt;假设Class A是Class B的子类，并且A改写了B的方法的method()，那么B来说，method方法的指针指向B的method方法入口；对于A来说，A的方法表的method项指向自身的method而非父类的。&lt;/p&gt;

&lt;p&gt;流程：调用方法时，虚拟机通过对象引用得到方法区中类型信息的方法表的指针入口，查询类的方法表 ，根据实例方法的符号引用解析出该方法在方法表的偏移量，子类对象声明为父类类型时，形式上调用的是父类的方法，此时虚拟机会从实际的方法表中找到方法地址，从而定位到实际类的方法。&lt;br /&gt;
注：所有引用为父类，但方法区的类型信息中存放的是子类的信息，所以调用的是子类的方法表。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;抽象类与接口&#34;&gt;抽象类与接口&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;抽象类&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;接口&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;特点&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1.抽象类与方法需用abstract修饰&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1.接口用interface修饰&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2.抽象类不一定有抽象方法，有则为抽象类&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2.类实现接口用implements&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3.不能直接实例化（通过多态可实例化）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3.不能被实例化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;成员特点-属性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;变量、常量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;常量（任何成员属性都隐含着 public static final）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;成员特点-构造方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;有&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;成员特点-成员方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;抽象、非抽象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;抽象、【JDK8有 default、static方法】&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;关键字&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不能与private、final、static(无意义)共存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java.util.AbstractList&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java.util.List&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;内部类&#34;&gt;内部类&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;成员内部类&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;99&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        
    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
            &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;
                
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Inner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;局部内部类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Outer{
    static int num0 = 99;
    public int num = 10;
        
    public void method(){
        final int num2 = 100;//存放于堆内存
        int num3 = 101;//随调用产生，随结束消失
        class Inner{
            Outer o = new Outer();
            system.out.println(o.num0);
            system.out.println(o.num1);
            system.out.println(o.num2);
            //system.out.println(o.num3);//无法访问，编译报错
        }
    }
}
    
class Test{
    public static void main(String[] args){
        Outer o = new Outer();
        o.method();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;匿名内部类&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;study&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();}&lt;/span&gt;
    
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;PersonDemo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;study&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;PersonDemo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PersonDemo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;study&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
                &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dosomething&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;静态内部类（访问外部数据必须用static修饰）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Outer{
    static int num0 = 99;
    public int num = 10;
        
    static class Inner{
        public int num = 20;
        public void show(){
            int num = 30;
            system.out.println(num);//30
            system.out.println(this.num);//20
            system.out.println(Outer.this.num);//10
                
        }
    }
}
    
class Test{
    public static void main(String[] args){
        Outer.Inner oi = new Outer().Inner();
        oi.show();
            
        Outer.Inner.show();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/679904/201510/679904-20151025210813989-921927916.jpg&#34; alt=&#34;yc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Throwable
Throwable是 Java 语言中所有错误或异常的超类。
Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。
Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exception
Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RuntimeException
RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。
编译器不会检查RuntimeException异常。如NullPointerException、IndexOutOfBoundsException,ArithmeticException(除数为零时)，也能通过编译。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非RuntimeException
Exception类本身，以及Exception的子类中除了&amp;rdquo;运行时异常&amp;rdquo;之外的其它子类都属于被检查异常。 如IOException、SQLException，Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Error
和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。如StackOverflowError、OutOfMemoryError，和RuntimeException一样， 编译器也不会检查Error,。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;hashocode的作用&#34;&gt;hashoCode的作用&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;hashCode的存在主要是用于查找的快捷性，作用于像散列集合Hashtable，HashMap等确定对象的存储地址的；&lt;/li&gt;
&lt;li&gt;如果两个对象相同，就是适⽤于equals(java.lang.Object)⽅方法，那么这两个对象的hashCode⼀定要相同；&lt;/li&gt;
&lt;li&gt;如果对象的equals⽅方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals⽅方法中使用的一致，否则就会违反上面提到的第2点；&lt;/li&gt;
&lt;li&gt;两个对象的hashCode相同，并不一定表示两个对象就相同（equals不一定为true），只能够说明这两个对象在散列列存储结构中，它们存放在同一个桶里面。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;collection概述&#34;&gt;Collection概述&lt;/h2&gt;

&lt;p&gt;Collection 是对象集合，继承了超级接口Iterable，使用Iterator迭代器实现遍历。 Collection 有两个子接口 List 和 Set。&lt;/p&gt;

&lt;p&gt;List 可以通过下标 (1,2..) 来取得值，值是有序重复，有自己的迭代器ListIterator，可以通过这个迭代器进行逆序的迭代。&lt;/p&gt;

&lt;p&gt;ArrayList、Vector、LinkedList 是List的实现类。&lt;/p&gt;

&lt;p&gt;ArrayList 是线程不安全的，底层采用数组实现（并且该数组的类型是Object类型的），默认长度为10。&lt;br /&gt;
扩容的步长是0.5倍原容量，扩容⽅方式是利用数组的复制，因此有一定的开销。&lt;/p&gt;

&lt;p&gt;Vector 是线程安全的，底层采用数组实现。&lt;/p&gt;

&lt;p&gt;LinkedList 是线程不安全的，底层是由（双向循环Deque）链表实现的。&lt;br /&gt;
LinkedList 有一个内部类作为存放元素的单元，⾥里里⾯面有三个属性，⽤用来存放元素本身以及前后2个单元的引用，另外LinkedList内部还有一个header属性，用来标识起始位置，第一个单元和最后一个单元都会指向header，因此形成了一个双向循环链表结构。&lt;/p&gt;

&lt;p&gt;Stack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。&lt;br /&gt;
Queue接口：提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList（实现双端队列Deque）、PriorityQueue等。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Set 只能通过游标来取值，并且值是不能重复的。Set中的元素类必须有一个有效的equals方法。&lt;/p&gt;

&lt;p&gt;Set子接口有NavigableSet、SortedSet；Set子类有EnumSet、HashSet、LinkedHashSet、TreeSet、AbstractSet等。&lt;/p&gt;

&lt;p&gt;HashSet 底层是哈希表（元素为链表的数组）实现（方法代码使用了HashMap），由hashcode()和equals()方法保证元素唯一。&lt;br /&gt;
TreeSet 底层是红黑树（自平衡的二叉树）实现，元素是可排序的。&lt;/p&gt;

&lt;p&gt;LinkedHashSet 底层由链表和哈希表实现，保证元素有序且唯一。&lt;/p&gt;

&lt;p&gt;TreeSet有两种排序实现。自然排序(内比较器)，类实现Comparable；比较器排序，使用匿名内部方式实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//比较器排序
TreeSet&amp;lt;User&amp;gt; userSet = new TreeSet&amp;lt;&amp;gt;(
	new Comparator&amp;lt;User&amp;gt;(){
		public int compare(User user1, User user2){
			if (user1.getAge() &amp;gt; user2.getAge()) return 1;
			else if (user1.getAge() = user2.getAge()) return 0;
			else  return -1;
		}
	}
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用迭代器Iterator遍历集合时修改添加元素会报并发修改异常，而用ListIterator则不会。&lt;/li&gt;
&lt;li&gt;使用size()获取集合长度&lt;/li&gt;
&lt;li&gt;toString()实现：AbstractColletion使用iterator()迭代器方法得到迭代器，之后使用StringBuilder拼接遍历的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;arraylist-linkedlist-vector的底层实现和区别&#34;&gt;ArrayList、LinkedList、Vector的底层实现和区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从同步性来看，ArrayList和LinkedList是不同步的，而Vector是的。所以线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList、LinkedList，使我们也达到同步，但效率可能会有所降低。&lt;/li&gt;
&lt;li&gt;从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。如果你要在集合中保存大量的数据，那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。&lt;/li&gt;
&lt;li&gt;ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或者删除元素那么花费的时间会呈线性增长O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置，因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList底层是由双向循环链表实现的，LinkedList在插入、删除集合中任何位置的元素所花费的时间都是一样的O(1)，但它在索引一个元素的时候比较慢，为O(i)，其中i是索引的位置，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;map概述&#34;&gt;Map概述&lt;/h2&gt;

&lt;p&gt;Map 是键值对集合。HashTable和HashMap是Map的实现类。&lt;/p&gt;

&lt;p&gt;HashMap不是线程安全的，键唯一（哈希表实现），可以存储null值。&lt;br /&gt;
HashTable是线程安全的，键唯一，不能存储null值。&lt;/p&gt;

&lt;p&gt;LinkedHashMap键是唯一有序的（哈希表和链表实现）&lt;br /&gt;
TreeMap键是可排序的（红黑树实现）&lt;/p&gt;

&lt;h2 id=&#34;常用容器初始值大小&#34;&gt;常用容器初始值大小&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;StringBuffer和StringBuilder初始化默认大小为16个字符&lt;/li&gt;
&lt;li&gt;HashMap初始化默认大小16，自增为2n.&lt;/li&gt;
&lt;li&gt;HashTable默认初始值为11，加载因子为0.75，自增为2n+1&lt;/li&gt;
&lt;li&gt;ArrayList初始化默认值为10，自增为1.5n&lt;/li&gt;
&lt;li&gt;Vector初始化默认值为10，自增为2n&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;io流&#34;&gt;IO流&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;字节流

&lt;ul&gt;
&lt;li&gt;输入

&lt;ul&gt;
&lt;li&gt;InputSream

&lt;ul&gt;
&lt;li&gt;FileInputStream&lt;/li&gt;
&lt;li&gt;BufferedInputStream&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输出

&lt;ul&gt;
&lt;li&gt;OutputStream

&lt;ul&gt;
&lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;li&gt;BufferedOutputStream&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;字符流

&lt;ul&gt;
&lt;li&gt;输入

&lt;ul&gt;
&lt;li&gt;Reader

&lt;ul&gt;
&lt;li&gt;InputStreamReader

&lt;ul&gt;
&lt;li&gt;FileReader&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BufferedReader

&lt;ul&gt;
&lt;li&gt;LineNumberReader&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输出

&lt;ul&gt;
&lt;li&gt;Writer

&lt;ul&gt;
&lt;li&gt;OutputStreamWriter

&lt;ul&gt;
&lt;li&gt;FileWirter&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BufferedWriter&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;close()与flush()：&lt;br /&gt;
    close() 关闭流对象，但会先刷新一次流缓冲区，关闭之后不可使用。&lt;br /&gt;
    flush() 仅仅刷新缓冲区，刷新之后，流对象还可以继续使用。&lt;/p&gt;

&lt;h2 id=&#34;线程状态&#34;&gt;线程状态&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;新建（New）:创建后尚未启动的线程处于这种状态。线程启动start()。&lt;/li&gt;
&lt;li&gt;运行(Runnable)：Runnable包括了操作系统状态中的 &lt;strong&gt;就绪&lt;/strong&gt; Ready和 &lt;strong&gt;运行&lt;/strong&gt; Running，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间。&lt;/li&gt;
&lt;li&gt;无限期等待（Waiting）:处于这种状态的进程不会被分配CPU执行时间，它们要等待被其他线程显示的唤醒。以下方法会让线程陷入无限期的等待状态：

&lt;ul&gt;
&lt;li&gt;没有设置Timeout参数的Object.wait()方法&lt;/li&gt;
&lt;li&gt;没有设置Timeout参数的Thread.join()方法&lt;/li&gt;
&lt;li&gt;LockSupport.park()方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;限期等待（Timed Waiting）:处于这种状态的进程不会被分配CPU执行时间，不过无需等待被其他线程显示的唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：

&lt;ul&gt;
&lt;li&gt;Thread.sleep()方法&lt;/li&gt;
&lt;li&gt;设置了Timeout参数的Object.wait()方法&lt;/li&gt;
&lt;li&gt;设置了Timeout参数的Thread.join()方法&lt;/li&gt;
&lt;li&gt;LockSupport.parkNanos()方法&lt;/li&gt;
&lt;li&gt;LockSupport.parkUnitil()方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;阻塞（Blocked）:进程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获取到一个排它锁，这个事件将在另一个线程放弃这个锁的时候发生；而等待状态则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。&lt;/li&gt;
&lt;li&gt;结束（Terminated）:已终止线程的线程状态，线程已经结束执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;线程的控制&#34;&gt;线程的控制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;获取线程的名称 &lt;code&gt;public final String getName()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置线程的名称 &lt;code&gt;public final void setName(String name)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回当前正在执行的线程对象(名称) &lt;code&gt;public static Thread currentThread()&lt;/code&gt; -&amp;gt; &lt;code&gt;Thread.currentThread().getName()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;获取线程对象的优先级     &lt;code&gt;public final int getPriority()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置线程对象的优先级     &lt;code&gt;public final void setPriority(int newPriority)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;线程默认优先级是5。&lt;/li&gt;
&lt;li&gt;线程优先级的范围是：1-10。&lt;/li&gt;
&lt;li&gt;线程优先级高仅仅表示线程获取的 CPU时间片的几率高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将该线程标记为守护线程或用户线程 &lt;code&gt;public final void setDaemon(boolean on)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;线程休眠  &lt;code&gt;public static void sleep(long millis)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加入线程  &lt;code&gt;public final void join()&lt;/code&gt;:等待该线程终止。&lt;/li&gt;
&lt;li&gt;礼让线程  &lt;code&gt;public static void yield()&lt;/code&gt;:暂停当前正在执行的线程对象，并执行其他线程。&lt;/li&gt;
&lt;li&gt;后台线程&lt;/li&gt;
&lt;li&gt;终止线程(掌握)&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public final void stop()&lt;/code&gt;:让线程停止，过时了，但是还可以使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void interrupt()&lt;/code&gt;:中断线程。 把线程的状态终止，并抛出一个InterruptedException。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;多线程相关&#34;&gt;多线程相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;多线程实现方案：

&lt;ul&gt;
&lt;li&gt;继承Thread类

&lt;ul&gt;
&lt;li&gt;自定义线程类继承Thread类，重写run()&lt;/li&gt;
&lt;li&gt;调用类 创建自定义线程类对象，启动线程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实现Runnable接口

&lt;ul&gt;
&lt;li&gt;自定义线程类实现Runable接口，重写run()&lt;/li&gt;
&lt;li&gt;调用类 创建自定义线程类对象&lt;/li&gt;
&lt;li&gt;调用类 以自定义线程类对象作为参数构造创建Thread对象，启动线程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实现Callable接口结合线程池

&lt;ul&gt;
&lt;li&gt;自定义线程类实现Callable接口，重写call方法

&lt;ul&gt;
&lt;li&gt;1

&lt;ul&gt;
&lt;li&gt;调用类 创建ExecutorService线程池对象,调用submit(Callable&lt;T&gt; task)&lt;/li&gt;
&lt;li&gt;调用类 创建Future&lt;T&gt;对象，接收上一步返回值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2

&lt;ul&gt;
&lt;li&gt;调用类 创建ExecutorService线程池对象,调用 submit(Runnable task)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;pool.shutdown()结束;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;线程安全问题产生条件

&lt;ul&gt;
&lt;li&gt;多线程环境&lt;/li&gt;
&lt;li&gt;有共享数据&lt;/li&gt;
&lt;li&gt;有多条语句操作共享数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;同步的方式：

&lt;ul&gt;
&lt;li&gt;同步代码块 &lt;code&gt;synchronized(对象){//doSomething}&lt;/code&gt; 或 同步锁 Lock

&lt;ul&gt;
&lt;li&gt;当线程访问较多时，每个线程都会去判断同步上的锁，非常消耗资源，降低程序运行效率，而且容易产生死锁。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;同步方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;run()与start()

&lt;ul&gt;
&lt;li&gt;run():封装了被线程执行的代码,直接调用仅仅是普通方法的调用&lt;/li&gt;
&lt;li&gt;start():启动线程，并由JVM自动调用run()方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sleep()与wait()&lt;br /&gt;
sleep()是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时会自动恢复（线程回到就绪（ready）状态），调用sleep 不会释放对象锁。&lt;br/&gt;&lt;br/&gt;
wait()是Object 类的方法，对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;死锁：两个或两个异常的线程争夺资源过程中，发生的一种互相等待的现象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;锁的等级：方法锁、对象锁、类锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实现Runnable接口相比继承Thread类有如下优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以避免由于Java的单继承特性而带来的局限&lt;/li&gt;
&lt;li&gt;增强程序的健壮性，代码能够被多个程序共享，代码与数据是独立的&lt;/li&gt;
&lt;li&gt;适合多个相同程序代码的线程区处理同一资源的情况&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程安全需要保证几个基本特性：&lt;br /&gt;
* 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
* 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
* 有序性，是保证线程内串行语义，避免指令重排等。&lt;/p&gt;

&lt;h2 id=&#34;osi与-tcp-ip&#34;&gt;OSI与&lt;code&gt;TCP/IP&lt;/code&gt;&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;OSI&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;TCP/IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;应用层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;应用层&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;表示层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;会话层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;传输层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;传输层&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;网络层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;网际层&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;数据链路层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;主机至网络层&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;物理层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;socket编程&#34;&gt;Socket编程&lt;/h2&gt;

&lt;p&gt;网络编程三要素： IP、端口、协议&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UDP

&lt;ul&gt;
&lt;li&gt;发送数据

&lt;ul&gt;
&lt;li&gt;创建发送端口DatagramSocket对象&lt;/li&gt;
&lt;li&gt;创建数据，并打开数据包&lt;/li&gt;
&lt;li&gt;调用DatagramSocket对象发送方法，发送数据包&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;接手数据

&lt;ul&gt;
&lt;li&gt;创建DatagramSocket对象&lt;/li&gt;
&lt;li&gt;创建一个数据包（接收容器）&lt;/li&gt;
&lt;li&gt;调用容器接手数据&lt;/li&gt;
&lt;li&gt;解析数据包&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TCP

&lt;ul&gt;
&lt;li&gt;发送数据

&lt;ul&gt;
&lt;li&gt;创建发送端的Socket对象&lt;/li&gt;
&lt;li&gt;获取输出流，写数据&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;接手数据

&lt;ul&gt;
&lt;li&gt;创建接手端的Socket&lt;/li&gt;
&lt;li&gt;监听客户端连接&lt;/li&gt;
&lt;li&gt;获取输入流&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;反射机制&#34;&gt;反射机制&lt;/h2&gt;

&lt;p&gt;反射技术：动态加载一个指定的类，并获取该类中所有的内容。并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;好处：大大增强了程序的扩展性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;反射的基本步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获得Class对象，就是获得指定的名称的字节码文件对象&lt;/li&gt;
&lt;li&gt;实例化对象，获得类的属性、方法或者构造函数&lt;/li&gt;
&lt;li&gt;访问属性、调用方法、调用构造函数创建对象&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Java笔记之web篇</title>
      <link>https://ianeiu.github.io/2018/12/22/java%E7%AC%94%E8%AE%B0%E4%B9%8Bweb%E7%AF%87/</link>
      <pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/12/22/java%E7%AC%94%E8%AE%B0%E4%B9%8Bweb%E7%AF%87/</guid>
      
        <description>

&lt;p&gt;JavaWeb笔记整理&lt;/p&gt;

&lt;h2 id=&#34;xml&#34;&gt;XML&lt;/h2&gt;

&lt;p&gt;XML(EXtensible Markup Language):可扩展标记型语言，主要是为了存储数据（程序配置文件）、数据交换&lt;/p&gt;

&lt;p&gt;格式：&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;XML两种文档约束类型： &lt;code&gt;dtd&lt;/code&gt; （file_name.dtd）和&lt;code&gt;schema&lt;/code&gt;（file_name.xsd 可被XML解析器解析）&lt;/p&gt;

&lt;p&gt;XML存储结构化信息，使用&lt;code&gt;DOM&lt;/code&gt;或&lt;code&gt;SAX&lt;/code&gt;（边读边解析）方式解析&lt;br /&gt;
Properties存储平面信息，使用Properties类解析&lt;/p&gt;

&lt;p&gt;常见的XML解析器实现：JDOM、DOM4J（首选）、SAX&lt;/p&gt;

&lt;p&gt;XPath:XML路径语言，用来确定XML文档中某部分位置&lt;/p&gt;

&lt;h2 id=&#34;web服务器&#34;&gt;Web服务器&lt;/h2&gt;

&lt;p&gt;Tomcat（Apache）、JBOSS（Redhat）、WebLogic（Oracle）、WebSphere（IBM）等等&lt;/p&gt;

&lt;h2 id=&#34;javaweb三大组件&#34;&gt;JavaWeb三大组件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Servlet&lt;/li&gt;
&lt;li&gt;Filter&lt;/li&gt;
&lt;li&gt;Listener&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;servlet&#34;&gt;Servlet&lt;/h2&gt;

&lt;p&gt;Servlet是多线程、单实例。&lt;br /&gt;
继承关系：MyServlet &amp;ndash;extends&amp;ndash;&amp;gt; HttpServlet &amp;ndash;extends&amp;ndash;&amp;gt; QenericServlet  &amp;ndash;implements&amp;ndash;&amp;gt; Servlet、ServletConfig&lt;/p&gt;

&lt;h4 id=&#34;servlet生命周期&#34;&gt;Servlet生命周期&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;初始化：服务器在Servlet第一次被访问时或在服务器启动时创建Servlet。创建后，调用init()方法；&lt;/li&gt;
&lt;li&gt;提供服务：当服务器每次接收到请求时，会调用service()方法处理请求；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;销毁：当服务器关闭时，服务器会去销毁Servlet。销毁前会调用destroy()方法。&lt;/p&gt;

&lt;h4 id=&#34;在web-xml中配置&#34;&gt;在web.xml中配置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;servlet&amp;gt;
	&amp;lt;servlet-name&amp;gt;myServlet&amp;lt;/servlet-name&amp;gt;
	&amp;lt;servlet-class&amp;gt;com.ianeiu.web.MyServlet&amp;lt;/servlet-class&amp;gt;
	&amp;lt;!-- 通过ServletConfig获取 --&amp;gt;
	&amp;lt;init-param&amp;gt;
		&amp;lt;param-name&amp;gt;key&amp;lt;/param-name&amp;gt;
		&amp;lt;param-value&amp;gt;value&amp;lt;/param-value&amp;gt;
	&amp;lt;/init-param&amp;gt;
	&amp;lt;!-- 值越小，优先级越大 --&amp;gt;
	&amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
	&amp;lt;servlet-name&amp;gt;myServlet&amp;lt;/servlet-name&amp;gt;
	&amp;lt;url-pattren&amp;gt;/my/*&amp;lt;/url-pattren&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问路径可以使用通配符 &lt;code&gt;* /* /myName/* *.do&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;httpservlet&#34;&gt;HttpServlet&lt;/h4&gt;

&lt;p&gt;实现了service(..,..),重写service(HttpServletRequest ..,HttpServletResponse &amp;hellip;),子类只需调用doGet() doPost()。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;请求request&#34;&gt;请求request&lt;/h2&gt;

&lt;p&gt;URL相关：&lt;br /&gt;
&lt;code&gt;http://127.0.0.1:8080/myproject/myServlet?name=admin&lt;/code&gt;&lt;br /&gt;
 .getRequestURL()+&amp;ldquo;?&amp;rdquo;+ .getQueryString&lt;br /&gt;
 或者&lt;br /&gt;
 .getScheme() +&amp;rdquo;://&amp;ldquo;+ .getServerName() +&amp;rdquo;:&amp;ldquo;+.getServerPort() +&amp;rdquo;/&amp;ldquo;+ .getContextPath +&amp;rdquo;/&amp;ldquo;+ .getServerPath +&amp;rdquo;?&amp;ldquo;+ .getQueryString&lt;br /&gt;
 /myproject/myServlet 可用 .getRequestURI() 获取&lt;/p&gt;

&lt;h4 id=&#34;get和post&#34;&gt;get和post&lt;/h4&gt;

&lt;p&gt;get：没有请求体，参数在url中显示，长度理论限制1K之内&lt;br /&gt;
post: 参数在请求体中，长度无限制&lt;/p&gt;

&lt;h4 id=&#34;请求转发和请求包含&#34;&gt;请求转发和请求包含&lt;/h4&gt;

&lt;p&gt;都是一个请求跨多个Servlet（可以共享request的域属性）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AServlet extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		RequestDispacter rd = request.getRequestDispacter(&amp;quot;/BServlet&amp;quot;);
		rd.forward(request,response);//A不能输响应体，可设置响应头，最后由B处理
		rd.include(request,response);//无限制，共同处理请求
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;响应response&#34;&gt;响应response&lt;/h2&gt;

&lt;p&gt;可设置响应信息、发送状态码、设置响应正文、重定向（response.sendRedirect(&amp;ldquo;/myProject/BServlet&amp;rdquo;)）&lt;/p&gt;

&lt;h4 id=&#34;响应编码&#34;&gt;响应编码&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;response.setCharacterEncoding(&amp;ldquo;utf-8&amp;rdquo;); response.getWriter(&amp;ldquo;..&amp;rdquo;);&lt;/li&gt;
&lt;li&gt;response.setHeader(&amp;ldquo;content-type&amp;rdquo;,&amp;ldquo;text/html;charset=utf-8&amp;rdquo;);&lt;/li&gt;

&lt;li&gt;&lt;p&gt;response.setContentType(&amp;ldquo;text/html;charset=utf-8&amp;rdquo;);&lt;/p&gt;

&lt;h4 id=&#34;请求转发和重定向-302&#34;&gt;请求转发和重定向（302）&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求转发是一个请求，但是重定向是两个请求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求转发只能是一种请求方式，要么是Get要么是Post ,但是重定向的第二个请求一定是Get。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求转发的地址栏并不会发生变化(服务器请求资源)，但是重定向的会变化，因为它是两个请求(浏览器重新请求地址)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求转发只能在本应用下的资源，但是重定向却可以跨应用，比如重定向到百度的主页。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;javaweb四大域对象&#34;&gt;JavaWeb四大域对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PageContext - page    （jsp）&lt;/li&gt;
&lt;li&gt;ServletRequest - request     （servlet、jsp）&lt;/li&gt;
&lt;li&gt;HttpSession - session     （servlet、jsp）&lt;/li&gt;
&lt;li&gt;ServletContext - application     （servlet、jsp）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;servletcontext&#34;&gt;ServletContext&lt;/h2&gt;

&lt;p&gt;ServletContext是Servlet域三大对象之一。&lt;br /&gt;
在服务器启动时创建，关闭时销毁，单实例。&lt;br /&gt;
用来存取数据、读取web.xml中初始化参数、读取应用资源（文件名、输入流、文件路径集合）&lt;/p&gt;

&lt;h3 id=&#34;响应头&#34;&gt;响应头&lt;/h3&gt;

&lt;p&gt;防盗链：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Referer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;禁用浏览器缓存：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Expies:-1&lt;/li&gt;
&lt;li&gt;Cache-Control:no-cache&lt;/li&gt;
&lt;li&gt;Pragma:no-cache&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三秒后跳转至百度&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;Refresh&amp;quot; content=&amp;quot;3;url=http://www.baidu.com&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jsp九大内置对象&#34;&gt;JSP九大内置对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;request - HttpServletRequest&lt;/li&gt;
&lt;li&gt;response - HttpServletResponse&lt;/li&gt;
&lt;li&gt;session - HttpSession&lt;/li&gt;
&lt;li&gt;application - ServletContext&lt;/li&gt;
&lt;li&gt;config - ServletConfig&lt;/li&gt;
&lt;li&gt;exception - 只有在错误页面才可使用&lt;/li&gt;
&lt;li&gt;page - 作用本JSP页面中&lt;/li&gt;
&lt;li&gt;out - JSPWriter&lt;/li&gt;
&lt;li&gt;pageContext - 页面上下文对象（作用域最小）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jsp中的java脚本&#34;&gt;JSP中的Java脚本&amp;lt;%%&amp;gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;脚本

&lt;ul&gt;
&lt;li&gt;&amp;lt;% .. %&amp;gt; 脚本片段&lt;/li&gt;
&lt;li&gt;&amp;lt;%= ..%&amp;gt; 表达式&lt;/li&gt;
&lt;li&gt;&amp;lt;%! ..%&amp;gt; 声明，定义成员&lt;/li&gt;
&lt;li&gt;示例：&lt;code&gt;&amp;lt;% int a=10; %&amp;gt; &amp;lt;%= a %&amp;gt; &amp;lt;%! private String hello=&amp;quot;hello&amp;quot;;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注释

&lt;ul&gt;
&lt;li&gt;&amp;lt;%&amp;ndash; ..  &amp;ndash;%&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;指令

&lt;ul&gt;
&lt;li&gt;&amp;lt;%@ .. %&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jsp原理&#34;&gt;JSP原理&lt;/h2&gt;

&lt;p&gt;客户端 访问 index.jsp,服务器将jsp文件编译成java文件，JVM将java文件编译成class文件。&lt;br /&gt;
服务器初始化jsp实例，创建该类对象，调用service()。&lt;br /&gt;
客户端再次访问则直接调用service()。&lt;/p&gt;

&lt;h2 id=&#34;jsp三大指令&#34;&gt;JSP三大指令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;page

&lt;ul&gt;
&lt;li&gt;错误页面配置 &lt;code&gt;&amp;lt;%@ page language=&amp;quot;java&amp;quot; contentType=&amp;quot;text/html; charset=UTF-8&amp;quot;  pageEncoding=&amp;quot;UTF-8&amp;quot; isErrorPage=&amp;quot;true&amp;quot;%&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;脚本获取错误 &lt;code&gt;&amp;lt;%= exception.getMessage()%&amp;gt;&lt;/code&gt; [exception为jsp内置对象，error页面独有]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;include

&lt;ul&gt;
&lt;li&gt;静态包含&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;taglib

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;%@ taglib uri=&amp;quot;&amp;quot; prefix=&amp;quot;c&amp;quot;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在web-xml中配置错误页面&#34;&gt;在web.xml中配置错误页面&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 默认的错误处理页面 --&amp;gt;  
&amp;lt;error-page&amp;gt;  
	&amp;lt;error-code&amp;gt;403&amp;lt;/error-code&amp;gt;  
	&amp;lt;location&amp;gt;/403.html&amp;lt;/location&amp;gt;  
&amp;lt;/error-page&amp;gt;  
&amp;lt;error-page&amp;gt;  
	&amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;  
	&amp;lt;location&amp;gt;/404.html&amp;lt;/location&amp;gt;  
&amp;lt;/error-page&amp;gt;  
&amp;lt;!-- 仅仅在调试的时候注视掉,在正式部署的时候不能注释 --&amp;gt;  
&amp;lt;!-- 这样配置也是可以的，表示发生500错误的时候，转到500.jsp页面处理。 --&amp;gt;  
&amp;lt;error-page&amp;gt;   
	&amp;lt;error-code&amp;gt;500&amp;lt;/error-code&amp;gt;   
	&amp;lt;location&amp;gt;/500.html&amp;lt;/location&amp;gt;   
&amp;lt;/error-page&amp;gt;
&amp;lt;!-- 这样的配置表示如果jsp页面或者servlet发生java.lang.Exception类型（当然包含子类）的异常就会转到500.jsp页面处理。 --&amp;gt;  
&amp;lt;error-page&amp;gt;   
	&amp;lt;exception-type&amp;gt;java.lang.Exception&amp;lt;/exception-type&amp;gt;   
	&amp;lt;location&amp;gt;/500.jsp&amp;lt;/location&amp;gt;   
&amp;lt;/error-page&amp;gt;   
  
&amp;lt;error-page&amp;gt;   
	&amp;lt;exception-type&amp;gt;java.lang.Throwable&amp;lt;/exception-type&amp;gt;   
	&amp;lt;location&amp;gt;/500.jsp&amp;lt;/location&amp;gt;   
&amp;lt;/error-page&amp;gt;  
&amp;lt;!--   
当error-code和exception-type都配置时，exception-type配置的页面优先级高  
及出现500错误，发生异常Exception时会跳转到500.jsp  
 --&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;在web-xml中配置jstl&#34;&gt;在web.xml中配置jstl&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;...  
&amp;lt;jsp-config&amp;gt;  
   &amp;lt;taglib&amp;gt;  
	   &amp;lt;taglib-uri&amp;gt;myjstl&amp;lt;/taglib-uri&amp;gt;  
	   &amp;lt;taglib-location&amp;gt;/WEB-INF/tld/c.tld&amp;lt;/taglib-location&amp;gt;  
   &amp;lt;/taglib&amp;gt;  
&amp;lt;/jsp-config&amp;gt;  
...  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jsp基本动作&#34;&gt;JSP基本动作&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;include&lt;/li&gt;
&lt;li&gt;useBean&lt;/li&gt;
&lt;li&gt;setProperty&lt;/li&gt;
&lt;li&gt;getProperty&lt;/li&gt;
&lt;li&gt;forward&lt;/li&gt;
&lt;li&gt;plugin&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;动态包含和静态包含&#34;&gt;动态包含和静态包含&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;动态包含

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;jsp:include page=&amp;quot;navigation.jsp&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求处理阶段执行&lt;/li&gt;
&lt;li&gt;会检查所含文件变化，用于动态页面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;静态包含

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;%@ include file=&amp;quot;resource.html&amp;quot;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;翻译阶段执行（合并再编译）&lt;/li&gt;
&lt;li&gt;不检查所含文件变化，用于静态页面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cookie&#34;&gt;Cookie&lt;/h2&gt;

&lt;p&gt;Cookie是Http协议的规范之一，是服务端和客户端之间传输的小数据。
特点:&lt;br /&gt;
1. 大小4KB（实际上不止）
2. 服务器最多在客户端浏览器上保存20个
3. 浏览器最多保存300个&lt;/p&gt;

&lt;h2 id=&#34;httpsession&#34;&gt;HttpSession&lt;/h2&gt;

&lt;p&gt;用来会话跟踪的类。session是服务端对象，保存在服务端。&lt;br /&gt;
HttpSession底层依赖Cookie或是URL重写。&lt;/p&gt;

&lt;p&gt;会话的实现依赖于容器，大多数容器采用基于Cookie的实现机制，使用名字为JSESSIONID的cookie作为session的唯一标识。&lt;/p&gt;

&lt;h4 id=&#34;url重写&#34;&gt;URL重写&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href =&amp;quot;/myproject/myjsp.jsp;jsessionid=&amp;lt;%=session.getId()%&amp;gt;&amp;quot;&amp;gt;跳转&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href =&amp;quot;&amp;lt;response.encodeURL(&#39;/myproject/myjsp.jsp&#39;)&amp;gt;&amp;quot;&amp;gt;跳转&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;el表达式&#34;&gt;EL表达式&lt;/h2&gt;

&lt;p&gt;EL表达式主要是用来替代JSP页面中的脚本表达式，获取JavaBean、Map、List、数组及域内置对象属性。也可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算。&lt;/p&gt;

&lt;p&gt;语法：&lt;code&gt;${标识符}&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;获取数据

&lt;ul&gt;
&lt;li&gt;List/数组 &lt;code&gt;${userList[0]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Bean &lt;code&gt;${user.userName}&lt;/code&gt;或&lt;code&gt;${user[&#39;userName&#39;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Map &lt;code&gt;${paramMap.key}&lt;/code&gt;或&lt;code&gt;${paramMap[&#39;key&#39;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内置对象 &lt;code&gt;${sessionScope.userName}&lt;/code&gt;、&lt;code&gt;${initParam[&#39;maxNum&#39;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果Map的键或Bean的属性名中包含&lt;code&gt;_&lt;/code&gt;或&lt;code&gt;-&lt;/code&gt;时，只有${initParam[&amp;lsquo;max_num&amp;rsquo;]}&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;运算

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${1+2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${3&amp;gt;5}&lt;/code&gt;或&lt;code&gt;${3 gt 5}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${isSuccess &amp;amp;&amp;amp; length&amp;gt;0}&lt;/code&gt; 或&lt;code&gt;${isSuccess and length&amp;gt;0}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${!isSuccess}&lt;/code&gt; 或&lt;code&gt;${not isSuccess}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;empty判断字符串、数组、集合的长度是否为0(可与not或!连用)   &lt;code&gt;${empty &amp;quot;&amp;quot;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;el-11个内置对象&#34;&gt;EL 11个内置对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;pageScope：获取pageContext域属性，相当于pageContext.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;requestScope：获取request域属性，相当于request.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;sessionScope：获取session域属性，相当于session.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;applicationScope：获取application域属性，相当于application.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;param：对应参数，它是一个Map，其中key是参数，value是参数值，适用于单值的参数，相当于request.getParameter(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;paramValues：对应参数，她是一个Map，其中key是参数，value是多个参数值，适用于多值的参数，相当于request.getParameterValues(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;header：对应请求头，它是一个Map，其中key表示头名称，value是单个头值，适用于单值的请求头，相当于request.getHeader(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;headerValues：对应请求头，它是一个Map，其中key表示头名称，value是多个头值，适用于多值的请求头，相当于request.getHeaders(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;initParam：获取web.xml中&lt;context-param&gt;内的参数，${ initParam.xxx}，xxx就是&lt;param-name&gt;标签内的值，进而得到&lt;param-value&gt;中的值&lt;/li&gt;
&lt;li&gt;cookie：用于获取cookie，Map&lt;String,Cookie&gt;，其中key是cookie的name，value是cookie对象，例如${cookie.JSESSIONID.value }就是获取sessionId&lt;/li&gt;
&lt;li&gt;pageContext：可以获取JSP九大内置对象，相当于使用该对象调用getxxx()方法，例如pageContext.getRequest()可以写为${pageContext.request)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jstl&#34;&gt;JSTL&lt;/h2&gt;

&lt;p&gt;JSTL是一个不断完善的开放源代码的JSP标签库，依赖于EL，使用需要导入jstl.jar。&lt;/p&gt;

&lt;p&gt;JSTL标签库可分为四种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;core&lt;/li&gt;
&lt;li&gt;fmt&lt;/li&gt;
&lt;li&gt;sql&lt;/li&gt;
&lt;li&gt;xml&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中sql标签库和xml标签库已过时。使用标签的JSP页面中使用taglib指令导入标签库，如下：&lt;br /&gt;
&lt;code&gt;&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot;uri=&amp;quot;http://java.sun.com/jstl/core&amp;quot; %&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prefix=&amp;quot;c&amp;quot;&lt;/code&gt;：指定标签库的前缀，这个前缀可以随便给值，但大家都会在使用core标签库时指定前缀为c；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uri=&amp;quot;http://java.sun.com/jstl/core&amp;quot;&lt;/code&gt;：指定标签库的uri，它不一定是真实存在的网址，但它可以让JSP找到标签库的描述文件；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;core标签库常用标签&#34;&gt;core标签库常用标签&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;out

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:out value=&amp;quot;aaa&amp;quot;/&amp;gt;&lt;/code&gt; 输出aaa字符串常量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:out value=&amp;quot;${aaa}&amp;quot;/&amp;gt;&lt;/code&gt;    与${aaa}相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:out value=&amp;quot;${aaa}&amp;quot; default=&amp;quot;xxx&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;set

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:set var=&amp;quot;a&amp;quot; value=&amp;quot;hello&amp;quot;/&amp;gt;&lt;/code&gt; 在pageContext中添加name为a，value为hello的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:set var=&amp;quot;a&amp;quot; value=&amp;quot;hello&amp;quot; scope=&amp;quot;session&amp;quot;/&amp;gt;&lt;/code&gt; 在session中添加name为a，value为hello的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;remove

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c: remove var=&amp;quot;a&amp;quot;/&amp;gt;&lt;/code&gt; 删除所有域中name为a的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:remove var=&amp;quot;a&amp;quot; scope=&amp;quot;page&amp;quot;/&amp;gt;&lt;/code&gt; 删除pageContext中name为a的数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;url

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/&amp;quot;/&amp;gt;&lt;/code&gt; 输出上下文路径：/项目名/&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/&amp;quot; var=&amp;quot;a&amp;quot; scope=&amp;quot;request&amp;quot;/&amp;gt;&lt;/code&gt; 把本该输出的结果赋给变量a。范围为request&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/AServlet&amp;quot;/&amp;gt;&lt;/code&gt;   输出：/项目名/AServlet&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/AServlet&amp;quot;&amp;gt;
&amp;lt;c:param name=&amp;quot;username&amp;quot; value=&amp;quot;abc&amp;quot;/&amp;gt;
&amp;lt;c:param name=&amp;quot;password&amp;quot; value=&amp;quot;123&amp;quot;/&amp;gt;&lt;/code&gt; 输出：/项目名/AServlet?username=abc&amp;amp;password=123。如果参数中包含中文，那么会自动使用URL编码！&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;if&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:if test=&amp;quot;条件&amp;quot;&amp;gt;满足条件执行的JSP代码&amp;lt;/c:if&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;choose&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:choose&amp;gt;
&amp;lt;c:when test=&amp;quot;条件&amp;quot;&amp;gt;处理&amp;lt;/c:when&amp;gt;
&amp;lt;c:when test=&amp;quot;条件&amp;quot;&amp;gt;处理&amp;lt;/c:when&amp;gt;
&amp;lt;c:otherwise&amp;gt;处理&amp;lt;/c:otherwise&amp;gt;
&amp;lt;/c:choose&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;forEach&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:forEach var=&amp;quot;名字(i)&amp;quot; begin=&amp;quot;开始数字(1)&amp;quot; end=&amp;quot;结束数字(5)&amp;quot;&amp;gt;
${i}
&amp;lt;/c:forEach&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:forEach var=&amp;quot;item&amp;quot; items=&amp;quot;数组/集合&amp;quot;&amp;gt;
${item}
&amp;lt;/c:forEach&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:forTokens&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:forTokens items=&amp;quot;google,runoob,taobao&amp;quot; delims=&amp;quot;,&amp;quot; var=&amp;quot;name&amp;quot;&amp;gt;
&amp;lt;c:out value=&amp;quot;${name}&amp;quot;/&amp;gt;&amp;lt;p&amp;gt;
&amp;lt;/c:forTokens&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;fmt标签库&#34;&gt;fmt标签库&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;fmt:formatNumber value=”被格式化的数据”[type=”number|currency|percent”]

                                               [pattern=”pattern”]

                                               [currencyCode=”code”]

                                               [currencySymbol=”symbol”]

                                               [groupingUsed=”true|false”]

                                               [maxIntergerDigits=”maxDigits”]

                                               [minIntergerDigits=”minDigits”]

                                               [maxFractionDigits=”maxDigits”]

                                               [minFractionDigits=”minDigits”]

                                               [var=”name”]

                                               [scope=page|request|session|application]

/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详见 &lt;a href=&#34;http://www.runoob.com/jsp/jstl-format-formatdate-tag.html&#34; target=&#34;blank&#34;&gt;fmt&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;jstl自定义标签&#34;&gt;JSTL自定义标签&lt;/h2&gt;

&lt;p&gt;JSP中使用自定义标签移除只需要完成以下两个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编写一个实现Tag接口的java类（标签处理类）；&lt;/li&gt;
&lt;li&gt;编写标签库描述符（tld）文件，在tld文件中对标签处理类进行描述。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;详见 &lt;a href=&#34;https://www.cnblogs.com/shanheyongmu/p/5940945.html&#34; target=&#34;blank&#34;&gt;JSTL自定义标签&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;jdbc&#34;&gt;JDBC&lt;/h2&gt;

&lt;p&gt;JDBC核心类:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DriverManager

&lt;ul&gt;
&lt;li&gt;注册驱动&lt;/li&gt;
&lt;li&gt;获取Connection&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Connection

&lt;ul&gt;
&lt;li&gt;与数据库通讯&lt;/li&gt;
&lt;li&gt;获取Statement&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Statement

&lt;ul&gt;
&lt;li&gt;向数据库发送SQL语句&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ResultSet

&lt;ul&gt;
&lt;li&gt;结果集&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JDBC编写顺序：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;注册驱动层序&lt;/li&gt;
&lt;li&gt;获取数据库连接&lt;/li&gt;
&lt;li&gt;创建Statement/PreparedStatement&lt;/li&gt;
&lt;li&gt;发送执行sql语句&lt;/li&gt;
&lt;li&gt;处理结果集（如果有）&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;statement&#34;&gt;Statement&lt;/h4&gt;

&lt;p&gt;con.createStatement()（结果集不滚动、不敏感、不可更新）&lt;br /&gt;
con.createStatement(int,int)&lt;/p&gt;

&lt;h2 id=&#34;jdbc之statement-preparedstatement-callablestatement&#34;&gt;JDBC之Statement,PreparedStatement,CallableStatement&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Statement、PreparedStatement和CallableStatement都是接口(interface)。&lt;/li&gt;
&lt;li&gt;Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。&lt;/li&gt;
&lt;li&gt;Statement接口提供了执行语句和获取结果的基本方法；&lt;br /&gt;
PreparedStatement接口添加了处理 IN 参数的方法；&lt;br /&gt;
CallableStatement接口添加了处理 OUT 参数的方法。&lt;/li&gt;
&lt;li&gt;特性

&lt;ul&gt;
&lt;li&gt;Statement

&lt;ul&gt;
&lt;li&gt;普通的不带参的查询SQL；&lt;/li&gt;
&lt;li&gt;支持批量更新,批量删除;&lt;/li&gt;
&lt;li&gt;Statement每次执行sql语句，数据库都要执行sql语句的编译;用于仅执行一次查询并返回结果的情形时，效率高于PreparedStatement。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PreparedStatement

&lt;ul&gt;
&lt;li&gt;可变参数的SQL,编译一次,执行多次,效率高;安全性好，有效防止Sql注入等问题&lt;/li&gt;
&lt;li&gt;支持批量更新,批量删除;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CallableStatement

&lt;ul&gt;
&lt;li&gt;继承自PreparedStatement,支持带参数的SQL操作;&lt;/li&gt;
&lt;li&gt;支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用PreparedStatement有几个好处&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。&lt;/li&gt;
&lt;li&gt;安全性好，有效防止Sql注入等问题。&lt;/li&gt;
&lt;li&gt;对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；&lt;/li&gt;
&lt;li&gt;代码的可读性和可维护性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;execute&#34;&gt;execute&amp;hellip;&lt;/h4&gt;

&lt;p&gt;executeQuery：返回结果集(ResultSet)。&lt;br /&gt;
executeUpdate: 执行给定SQL语句,该语句可能为 INSERT、UPDATE 或 DELETE 语句，或者不返回任何内容的SQL语句（如 SQL DDL 语句）。&lt;br /&gt;
execute: 可用于执行任何SQL语句，返回一个boolean值，表明执行该SQL语句是否返回了ResultSet。如果执行后第一个结果是ResultSet，则返回true，否则返回false。&lt;/p&gt;

&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/fjdingsd/p/5273008.html&#34; target=&#34;blank&#34;&gt;事务的四大特性及隔离级别&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;数据库连接池&#34;&gt;数据库连接池&lt;/h2&gt;

&lt;p&gt;DBCP（hibernate3不再支持）&lt;/p&gt;

&lt;p&gt;C3P0&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java面试之基础题（Integer、String、内部类与final）</title>
      <link>https://ianeiu.github.io/2018/11/18/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%A2%98integerstring%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8Efinal/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/11/18/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%A2%98integerstring%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8Efinal/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;翻了翻之前收藏的文章，找到几道有意思的题，这里整理汇总一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;integer&#34;&gt;Integer&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Integer a = 1000,b=1000;
Integer c = 100,d=100;    
@Test
public void testIntegerDD(){
    System.out.println(a==b);//false  
    System.out.println(c==d);//true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行代码，我们会得到 false  true。这道题笔试用经常出现，原理也很简单
,可看Integer源码valueOf(int i)方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static Integer valueOf(int i) {
	if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
	return IntegerCache.cache[i + (-IntegerCache.low)];
	return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Integer 的缓存范围虽然默认是 -128 到 127，但是在特别的应用场景，比如我们明确知道应用会频繁使用更大的数值，这时候应该怎么办呢？&lt;br /&gt;
缓存上限值实际是可以根据需要调整的，JVM 提供了参数设置：&lt;br /&gt;
&lt;code&gt;-XX:AutoBoxCacheMax=N&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接下来，简单的扩展几个Integer的关系运算符==的比较。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void testIntegerDD(){

    Integer a = 1000,b=1000;
    Integer c = 100,d=100;   
    Integer e = new Integer(100);
    Integer f = new Integer(100);
    int g = 1000;
    Integer h = new Integer(1000);  


    //1、进行自动装箱操作；2、Integer中把-128-127 缓存了下来
    System.out.println(a==b);//false  
    System.out.println(c==d);//true

    //这里并不是用的缓存，而是new创建的对象存放在堆内存中，俩个变量指向不同引用，所以结果是false
    System.out.println(e==f);//false
    //当int和Integer进行==比较的时候，Java会把Integer进行自动拆箱为int类型的值
    System.out.println(g==h);//true

    //进行自动装箱操作
    System.out.println(c==e);//false
    System.out.println(a==h);//false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string&#34;&gt;String&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;阅读前先要理解 ==，==如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void testStringDD() {
    String s1 = &amp;quot;hello&amp;quot;;
    String s2 = &amp;quot;hello&amp;quot;;
    String s3 = new String(&amp;quot;hello&amp;quot;);

    System.out.println(s1==s2); // true
    System.out.println(s1==s3); // false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章解释：&lt;br /&gt;
一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，而堆内存中则存放new出来的对象和数组。然而除此之外还有一块区域叫做常量池。&lt;br /&gt;
像我们通常想String s1 = &amp;ldquo;hello&amp;rdquo;; 这样申明的字符串对象，其值就是存储在常量池中。&lt;br /&gt;
当我们创建String s1 =&amp;ldquo;hello&amp;rdquo;这样一个对象之后，&amp;rdquo;hello&amp;rdquo;就存储到了常量池（也可叫做字符串池）中，当我们创建引用String s2  = &amp;ldquo;hello&amp;rdquo; 的时候，Java底层会优先在常量池中查找是否存在&amp;rdquo;hello&amp;rdquo;，如果存在则让s2指向这个值，不会重新创建，如果常量池中没有则创建并添加的池中。这就是为什么答案是true 和false的原因。&lt;/p&gt;

&lt;p&gt;接下来，还是简单的扩展几个String的关系运算符==的比较。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void testStringDD() {
    String s1 = &amp;quot;hello&amp;quot;;
    String s2 = &amp;quot;hello&amp;quot;;
    String s3 = new String(&amp;quot;hello&amp;quot;);

    //都存储在常量池中,指向同一常量
    System.out.println(s1==s2); // true
    //存储在常量池中,存储在堆内存中
    System.out.println(s1==s3); // false

    String s4 = &amp;quot;helloo&amp;quot;;
    /**
     * 会重新在常量池创建常量（String不可变属性）
     */
    String s5 = s1+&amp;quot;o&amp;quot;;
    //字符串拼接有变量参与，底层调用StringBuffer处理，相当于在堆内存中开辟了新空间
    System.out.println(s4 == s5); // false
    //常量相加，先在常量池找，找到即用
    System.out.println(s4 == &amp;quot;hello&amp;quot;+&amp;quot;o&amp;quot;);//true

    //hello
    String s6 = s4.substring(0, s4.length() - 1);
    //substring返回的也是new出来的String对象
    System.out.println(s1 == s6); // false
    //地址值不一样
    System.out.println(s3 == s6); // false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扩展：equals方法。equals方法不能作用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。&lt;/p&gt;

&lt;h2 id=&#34;内部类与final&#34;&gt;内部类与final&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public void mRun(final String name){
    new Runnable() {
        public void run() {
            try {
              Thread.sleep(1000);
           } catch (InterruptedException e) {
             // TODO Auto-generated catch block
            e.printStackTrace();
           }  
           System.out.println(name);
        }
    }.start();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章解释：&lt;br /&gt;
这种代码相信大家写过很多，当内部类访问局部变量的时候，需要在局部变量前加final修饰符，不然编译器就会报错。通常我们也是这么干的。&lt;/p&gt;

&lt;p&gt;为什么要加final修饰符？&lt;br /&gt;
首先内部类的生命周期是成员级别的，而局部变量的生命周期实在方法体之类。也就是说会出现这样一种情况，当mRun方法执行，new 的线程运行，新线程里面会睡一秒。&lt;br /&gt;
主线程会继续执行，mRun执行完毕，name属性生命周期结束。1秒之后，Syetem.out.printh(name)执行。然而此时name已经寿终正寝，不在内存中了。&lt;/p&gt;

&lt;p&gt;Java就是为了杜绝这种错误，严格要求内部类中方位局部变量，必须使用final关键字修饰。&lt;br /&gt;
局部变量被final修饰之后，此时会在内存中保有一份局部变得的复制品，当内部类访问的时候其实访问的是这个复制品。这就好像是把局部变量的生命周期变长了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JVM笔记之JVM类加载机制</title>
      <link>https://ianeiu.github.io/2018/10/19/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/10/19/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
      
        <description>

&lt;h1 id=&#34;虚拟机类加载机制&#34;&gt;虚拟机类加载机制&lt;/h1&gt;

&lt;p&gt;虚拟机把描述类的数据从Class文件&lt;strong&gt;加载&lt;/strong&gt;到内存，并对数据进行&lt;strong&gt;校验&lt;/strong&gt;、&lt;strong&gt;转换（准备）&lt;/strong&gt;、&lt;strong&gt;解析&lt;/strong&gt;和&lt;strong&gt;初始化&lt;/strong&gt;，最终形成可以被Java虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。&lt;/p&gt;

&lt;p&gt;类从被加载到虚拟内存中开始，到卸载内存为止，它的整个生命周期包括了：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)七个阶段。&lt;br /&gt;
其中，验证，准备和解析三个部分统称为连接(Linking)。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;类加载的过程&#34;&gt;类加载的过程&lt;/h3&gt;

&lt;p&gt;类加载的全过程，加载，验证，准备，解析和初始化这五个阶段。&lt;/p&gt;

&lt;h4 id=&#34;加载&#34;&gt;加载&lt;/h4&gt;

&lt;p&gt;在加载阶段，虚拟机需要完成以下三件事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过一个类的全限定名来获取定义此类的二进制字节流&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构&lt;/li&gt;
&lt;li&gt;在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等&lt;/p&gt;

&lt;h4 id=&#34;验证&#34;&gt;验证&lt;/h4&gt;

&lt;p&gt;这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能有所不同，但大致上都会完成下面四个阶段的检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件格式验证&lt;/strong&gt; 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元数据验证&lt;/strong&gt; 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节码验证&lt;/strong&gt; 整个验证过程中最复杂的一个阶段，主要工作是数据流和控制流的分析。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号引用验证&lt;/strong&gt; 发生在虚拟机将符号引用直接转化为直接引用的时候，这个转化动作将在连接的第三个阶段－解析阶段产生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;准备&#34;&gt;准备&lt;/h4&gt;

&lt;p&gt;正式为类变量分配内存并设置类变量初始值的阶段（创建类或接口中的静态变量，并初始化静态变量的初始值），这些内存都将在方法区进行分配。&lt;/p&gt;

&lt;h4 id=&#34;解析&#34;&gt;解析&lt;/h4&gt;

&lt;p&gt;解析阶段是虚拟机将常量池的符号引用转换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。&lt;/p&gt;

&lt;h4 id=&#34;初始化&#34;&gt;初始化&lt;/h4&gt;

&lt;p&gt;前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由Java虚拟机主导和控制。&lt;br /&gt;
到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。
在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者说初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。&lt;/p&gt;

&lt;p&gt;真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;准备阶段-常量和不同静态变量有什么区别&#34;&gt;准备阶段 常量和不同静态变量有什么区别&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class CLPreparation {
    public static int a = 100;
    public static final int INT_CONSTANT = 1000;
    public static final Integer INTEGER_CONSTANT = Integer.valueOf(10000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译并反编译一下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javac CLPreparation.java
javap –v CLPreparation.class
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;static {};
    descriptor: ()V
    flags: ACC_STATIC
    Code:
      stack=1, locals=0, args_size=0
         0: bipush        100
         2: putstatic     #2                  // Field a:I
         5: sipush        10000
         8: invokestatic  #3                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        11: putstatic     #4                  // Field INTEGER_CONSTANT:Ljava/lang/Integer;
        14: return
      LineNumberTable:
        line 2: 0
        line 4: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通原始类型静态变量和引用类型（即使是常量），是需要额外调用putstatic 等 JVM 指令的，
这些是在显式初始化阶段执行，而不是准备阶段调用；而原始类型常量，则不需要这样的步骤。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;类加载器&#34;&gt;类加载器&lt;/h3&gt;

&lt;h4 id=&#34;类与类加载器&#34;&gt;类与类加载器&lt;/h4&gt;

&lt;p&gt;虚拟机设计团队把类加载阶段中的&amp;rdquo;通过一个类的全限定名来获取描述此类的二进制字节流&amp;rdquo;这个动作放到Java虚拟机外部去实现，以便让程序自己决定如何去获取所需的类。实现这个动作的代码模块被称为&amp;rdquo;类加载器&amp;rdquo;。&lt;/p&gt;

&lt;h4 id=&#34;双亲委派模型&#34;&gt;双亲委派模型&lt;/h4&gt;

&lt;p&gt;站在Java虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。从Java开发人员的角度来看，类加载器还可以分得更细致一些，绝大部分Java程序都会使用到以下三种系统提供的类加载器：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;启动类加载器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;加载 jre/lib 下面的 jar 文件，如 rt.jar。&lt;/li&gt;
&lt;li&gt;即使是在开启了 Security Manager 的时候，JDK 仍赋予了它加载的程序AllPermission。&lt;/li&gt;
&lt;li&gt;通过 java -Xbootclasspath :(替换)、/a（追加）、/p（前置）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;扩展类加载器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;负责加载我们放到 jre/lib/ext/ 目录下面的 jar 包，这就是所谓的 extension 机制。&lt;/li&gt;
&lt;li&gt;可以通过设置 “java.ext.dirs”来覆盖，&lt;code&gt;java -Djava.ext.dirs=your_ext_dir HelloWorld&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;应用程序类加载器

&lt;ul&gt;
&lt;li&gt;也叫系统（System）类加载器，是加载我们最熟悉的 classpath 的内容。通常来说，其默认就是 JDK 内建的应用类加载器;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;它同样是可能修改的，比如：&lt;code&gt;java -Djava.system.class.loader=com.yourcorp.YourClassLoader HelloWorld&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果我们指定了这个参数，JDK 内建的应用类加载器就会成为定制加载器的父亲，这种方式通常用在类似需要改变双亲委派模式的场景。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;双亲委派模型（⾃底向上检查类是否已经加载、⾃顶向下尝试加载类），简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，尽量将这个任务代理给当前加载器的父加载器去做（除非父加载器找不到相应类型）。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常&lt;/p&gt;

&lt;p&gt;使用委派模型的目的是避免重复加载 Java类型；考虑到安全因素，避免自定义的类去替代系统类，如String。&lt;/p&gt;

&lt;h4 id=&#34;类加载机制有三个基本特征&#34;&gt;类加载机制有三个基本特征&lt;/h4&gt;

&lt;p&gt;双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的。&lt;br /&gt;
用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。&lt;br /&gt;
例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。&lt;/p&gt;

&lt;p&gt;可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许。&lt;/p&gt;

&lt;p&gt;单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。&lt;/p&gt;

&lt;p&gt;jvm如何判定两个class是否相同？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，⽽且要判断是否由同⼀一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。&lt;/p&gt;

&lt;h4 id=&#34;jdk9-模块化&#34;&gt;JDK9 模块化&lt;/h4&gt;

&lt;p&gt;在 JDK 9 中，由于 Jigsaw 项目引入了 Java 平台模块化系统（JPMS），JPMS），Java SE 的源代码被划分为一系列模块。-Xbootclasspath 参数不可用了。&lt;/p&gt;

&lt;p&gt;扩展类加载器被重命名为平台类加载器（Platform Class-Loader），而且 extension 机制则被移除。也就意味着，如果我们指定 java.ext.dirs 环境变量，或者 lib/ext 目录存在，JVM将直接返回错误！建议解决办法就是将其放入 classpath 里。&lt;/p&gt;

&lt;p&gt;rt.jar 和 tools.jar 同样是被移除了！JDK 的核心类库以及相关资源，被存储在 jimage 文件中，并通过新的 JRT 文件系统访问，而不是原有的 JAR 文件系统。虽然看起来很惊人，但幸好对于大部分软件的兼容性影响，其实是有限的，更直接地影响是 IDE 等软件，通常只要升级到新版本就可以了。&lt;/p&gt;

&lt;p&gt;增加了 Layer 的抽象， JVM 启动默认创建 BootLayer，开发者也可以自己去定义和实例化Layer，可以更加方便的实现类似容器一般的逻辑抽象。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JVM笔记之引用、GC及OOM</title>
      <link>https://ianeiu.github.io/2018/10/10/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%95%E7%94%A8gc%E5%8F%8Aoom/</link>
      <pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/10/10/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%95%E7%94%A8gc%E5%8F%8Aoom/</guid>
      
        <description>

&lt;h2 id=&#34;强引用-软引用-弱引用和虚引用&#34;&gt;强引用、软引用、弱引用和虚引用&lt;/h2&gt;

&lt;p&gt;&lt;kbd&gt;强引用（Strong Reference）&lt;/kbd&gt;
只有这个引用被释放之后，对象才会被释放掉。只要引用存在，垃圾回收器永远不会回收。&lt;/p&gt;

&lt;p&gt;我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。&lt;br /&gt;
当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。&lt;br /&gt;
对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，
具体回收时机还是要看垃圾收集策略。&lt;/p&gt;

&lt;p&gt;&lt;kbd&gt;软引用（Soft Reference）&lt;/kbd&gt;
内存溢出之前通过代码回收的引用。
通常用来实现内存敏感的缓存（图片缓存框架中，“内存缓存”中的图片是以这种引用来保存）。&lt;br /&gt;
软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；
当内存不足时，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象，自动删除这部分缓存数据，从真正的来源查询这些数据。&lt;/p&gt;

&lt;p&gt;&lt;kbd&gt;弱引用（Weak Reference）&lt;/kbd&gt;
第二次垃圾回收时回收的引用，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
同样可用于内存敏感的缓存（在静态内部类中，经常会使用虚引用。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏）&lt;br /&gt;
弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。&lt;/p&gt;

&lt;p&gt;&lt;kbd&gt;虚引用（Phantom Reference) &lt;/kbd&gt;
又称幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例的任何属性或函数。&lt;br /&gt;
可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。&lt;br /&gt;
当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。&lt;br /&gt;
虚引用和软引用弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有&lt;/p&gt;

&lt;h2 id=&#34;java内存回收机制&#34;&gt;Java内存回收机制&lt;/h2&gt;

&lt;p&gt;不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。&lt;/p&gt;

&lt;p&gt;Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。&lt;/p&gt;

&lt;p&gt;在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，另一个是给对象赋予了新值，这样重新分配了内存空间。&lt;/p&gt;

&lt;h2 id=&#34;gc算法分类&#34;&gt;GC算法分类&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;引⽤用计数法(没有被java采⽤用)&lt;/li&gt;
&lt;li&gt;标记清除法（通过根节点标记所有从根节点开始的可达对象，清除没标记过的对象，标记和清除两个过程效率不高，产生内存碎⽚）&lt;/li&gt;
&lt;li&gt;标记压缩法（压缩：将所有存活对象压缩到内存的一端，清除边界外所有的空间）&lt;/li&gt;
&lt;li&gt;复制算法（不适⽤用于存活对象比较多的场合，如老年代）&lt;/li&gt;
&lt;li&gt;分代回收法（根据对象存活周期的不同将内存划分几块，一般是新生代和老年代，新⽣代基本采用复制算法，老年代采⽤用标记整理算法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;minorgc-fullgc&#34;&gt;MinorGC &amp;amp; FullGC&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Minor GC通常发⽣生在新生代的Eden区，在这个区的对象生存期短，发生GC的频较高回收速度⽐比较快，一般采⽤用复制-回收算法。&lt;/li&gt;
&lt;li&gt;Full GC/Major GC 发⽣生在老年代，触发⽼老老年年代GC的时候不会触发Minor GC，所采用的是标记-清除算法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;内存泄漏&#34;&gt;内存泄漏&lt;/h2&gt;

&lt;p&gt;内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示Out of memory。&lt;/p&gt;

&lt;p&gt;Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：&lt;/p&gt;

&lt;p&gt;1、静态集合类引起内存泄漏&lt;/p&gt;

&lt;p&gt;像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static Vector v = new Vector(10);
for (int i = 1; i&amp;lt;100; i++){
	Object o = new Object();
	v.add(o);
	o = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，循环创建Object 对象，并将所创建的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。&lt;/p&gt;

&lt;p&gt;2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args){
	Set&amp;lt;Person&amp;gt; set = new HashSet&amp;lt;Person&amp;gt;();
	Person p1 = new Person(&amp;quot;唐僧&amp;quot;,&amp;quot;pwd1&amp;quot;,25);
	Person p2 = new Person(&amp;quot;孙悟空&amp;quot;,&amp;quot;pwd2&amp;quot;,26);
	Person p3 = new Person(&amp;quot;猪八戒&amp;quot;,&amp;quot;pwd3&amp;quot;,27);
	set.add(p1);
	set.add(p2);
	set.add(p3);
	System.out.println(&amp;quot;总共有:&amp;quot;+set.size()+&amp;quot; 个元素!&amp;quot;); //结果：总共有:3 个元素!
	p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变

	set.remove(p3); //此时remove不掉，造成内存泄漏

	set.add(p3); //重新添加，居然添加成功
	System.out.println(&amp;quot;总共有:&amp;quot;+set.size()+&amp;quot; 个元素!&amp;quot;); //结果：总共有:4 个元素!
	for (Person person : set){
		System.out.println(person);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、监听器&lt;/p&gt;

&lt;p&gt;在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。&lt;/p&gt;

&lt;p&gt;4、各种连接&lt;/p&gt;

&lt;p&gt;比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。&lt;/p&gt;

&lt;p&gt;5、内部类和外部模块的引用&lt;/p&gt;

&lt;p&gt;内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：
public void registerMsg(Object b);
这种调用就要小心，传入了一个对象，可能模块B就保持了对该对象的引用，需要注意模块B 是否提供相应的操作去除引用。&lt;/p&gt;

&lt;p&gt;6、单例模式&lt;/p&gt;

&lt;p&gt;不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A{
	public A(){
		B.getInstance().setA(this);
	}
	....
}
//B类采用单例模式
class B{
	private A a;
	private static B instance = new B();
	public B(){}
	public static B getInstance(){
		return instance;
	}
	public void setA(A a){
		this.a=a;
	}
	//getter...
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况&lt;/p&gt;

&lt;h2 id=&#34;其他oom&#34;&gt;其他OOM&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;OutOfMemoryError异常&lt;/p&gt;

&lt;p&gt;除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能，&lt;/p&gt;

&lt;p&gt;Java Heap 溢出，一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess&lt;/p&gt;

&lt;p&gt;java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。&lt;/p&gt;

&lt;p&gt;出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。&lt;/p&gt;

&lt;p&gt;如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。&lt;/p&gt;

&lt;p&gt;如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;虚拟机栈和本地方法栈溢出&lt;/p&gt;

&lt;p&gt;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如递归方法没有退出条件&lt;/p&gt;

&lt;p&gt;如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常&lt;/p&gt;

&lt;p&gt;这里需要注意当栈的大小越大可分配的线程数就越少。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行时常量池溢出&lt;/p&gt;

&lt;p&gt;异常信息：java.lang.OutOfMemoryError:PermGen space&lt;br /&gt;
如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。&lt;/p&gt;

&lt;p&gt;对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方法区溢出&lt;/p&gt;

&lt;p&gt;方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。&lt;/p&gt;

&lt;p&gt;异常信息：java.lang.OutOfMemoryError:PermGen space&lt;br /&gt;
方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。&lt;/p&gt;

&lt;p&gt;随着&lt;b&gt;元数据区&lt;/b&gt;的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;如何监控和诊断-jvm-堆内和堆外内存使用&#34;&gt;如何监控和诊断 JVM 堆内和堆外内存使用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用综合性的图形化工具，如 JConsole&lt;/li&gt;
&lt;li&gt;也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。&lt;/li&gt;
&lt;li&gt;使用 jmap 等提供的命令，生成堆转储（Heap Dump）文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。&lt;/li&gt;
&lt;li&gt;如果使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。&lt;/li&gt;
&lt;li&gt;另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Java笔记之名词简介</title>
      <link>https://ianeiu.github.io/2018/09/29/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 29 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/09/29/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E7%AE%80%E4%BB%8B/</guid>
      
        <description>

&lt;h2 id=&#34;web容器&#34;&gt;web容器&lt;/h2&gt;

&lt;p&gt;给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。&lt;/p&gt;

&lt;h2 id=&#34;ejb容器&#34;&gt;EJB容器&lt;/h2&gt;

&lt;p&gt;Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;jdbc&#34;&gt;JDBC&lt;/h2&gt;

&lt;p&gt;用来访问数据库的API（规范）&lt;/p&gt;

&lt;h2 id=&#34;jndi-java-naming-directory-interface&#34;&gt;JNDI：（Java Naming &amp;amp; Directory Interface）&lt;/h2&gt;

&lt;p&gt;JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。&lt;/p&gt;

&lt;h2 id=&#34;jms-java-message-service&#34;&gt;JMS：（Java Message Service）&lt;/h2&gt;

&lt;p&gt;JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。&lt;/p&gt;

&lt;h2 id=&#34;jta-java-transaction-api&#34;&gt;JTA：（Java Transaction API）&lt;/h2&gt;

&lt;p&gt;JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。&lt;/p&gt;

&lt;h2 id=&#34;jaf-java-action-framework&#34;&gt;JAF：（Java Action FrameWork）&lt;/h2&gt;

&lt;p&gt;JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。&lt;/p&gt;

&lt;h2 id=&#34;rmi-iiop-remote-method-invocation-internet对象请求中介协议&#34;&gt;RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）&lt;/h2&gt;

&lt;p&gt;他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。&lt;/p&gt;

&lt;h2 id=&#34;jsp&#34;&gt;JSP&lt;/h2&gt;

&lt;p&gt;Jsp页面由HTML和前去其中的Java代码组成，用来实现动态视图&lt;/p&gt;

&lt;h2 id=&#34;javamail&#34;&gt;JavaMail&lt;/h2&gt;

&lt;p&gt;JavaMail利用JAF来初拉力MIME编码的邮件附件&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;mvc&#34;&gt;MVC&lt;/h2&gt;

&lt;p&gt;标准主流现在的编程方式都是采用MVC综合设计模式，MVC本身不属于设计模式的一种，它描述的是一种结构，最终目的达到解耦（更改某一层代码不会影响我其他层代码）。&lt;br /&gt;
视图层如jsp调用控制层，控制层action调用业务层service，业务层调用数据dao访问层。&lt;/p&gt;

&lt;h2 id=&#34;dao层&#34;&gt;DAO层&lt;/h2&gt;

&lt;p&gt;DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，DAO层的设计首先是设计DAO的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。&lt;/p&gt;

&lt;h2 id=&#34;service层&#34;&gt;Service层&lt;/h2&gt;

&lt;p&gt;Service层主要负责业务模块的逻辑应用设计。同样是首先设计接口，再设计其实现的类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。&lt;/p&gt;

&lt;h2 id=&#34;controller层&#34;&gt;Controller层&lt;/h2&gt;

&lt;p&gt;Controller层负责具体的业务模块流程的控制，在此层里面要调用Serice层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;vo&#34;&gt;VO&lt;/h2&gt;

&lt;p&gt;即value object值对象。主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象。然后用一个VO对象在控制层与视图层进行传输交换。&lt;/p&gt;

&lt;h2 id=&#34;dto&#34;&gt;DTO&lt;/h2&gt;

&lt;p&gt;Data Transfer Object数据传输对象，经过处理后的PO，可能增加或者减少PO的属性，主要用于远程调用等需要大量传输对象的地方。&lt;/p&gt;

&lt;h2 id=&#34;pojo&#34;&gt;POJO&lt;/h2&gt;

&lt;p&gt;POJO（plain ordinary java object）即简单java对象，是一种概念或者接口，身份及作用随环境变化而变化。
它不包含业务逻辑或持久逻辑等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;springmvc&#34;&gt;SpringMVC&lt;/h2&gt;

&lt;p&gt;Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。&lt;/p&gt;

&lt;h2 id=&#34;ioc容器&#34;&gt;IOC容器&lt;/h2&gt;

&lt;p&gt;IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。在Spring中BeanFactory是IOC容器的实际代表者。&lt;/p&gt;

&lt;h2 id=&#34;aop-面向切面&#34;&gt;AOP (面向切面)&lt;/h2&gt;

&lt;p&gt;简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系&lt;/p&gt;

&lt;h2 id=&#34;mybatis&#34;&gt;Mybatis&lt;/h2&gt;

&lt;p&gt;MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。&lt;/p&gt;

&lt;h2 id=&#34;dubbo&#34;&gt;Dubbo&lt;/h2&gt;

&lt;p&gt;Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC（远程过程调用协议）远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。&lt;/p&gt;

&lt;h2 id=&#34;maven&#34;&gt;Maven&lt;/h2&gt;

&lt;p&gt;项目管理和构建自动化工具&lt;/p&gt;

&lt;h2 id=&#34;rabbitmq&#34;&gt;RabbitMQ&lt;/h2&gt;

&lt;p&gt;消息队列一般是在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。&lt;/p&gt;

&lt;h2 id=&#34;log4j-log4j2-logback&#34;&gt;Log4j、Log4j2、Logback&lt;/h2&gt;

&lt;p&gt;日志记录框架&lt;/p&gt;

&lt;h2 id=&#34;ehcache&#34;&gt;Ehcache&lt;/h2&gt;

&lt;p&gt;EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展，缓存异常处理程序，一个gzip缓存servlet过滤器，支持REST和SOAP api等特点。&lt;/p&gt;

&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;

&lt;p&gt;redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。Redis数据库完全在内存中，使用磁盘仅用于持久性。Redis可以将数据复制到任意数量的从服务器。&lt;/p&gt;

&lt;h2 id=&#34;shiro&#34;&gt;Shiro&lt;/h2&gt;

&lt;p&gt;Apache Shiro是Java的一个安全框架，旨在简化身份验证和授权。Shiro在JavaSE和JavaEE项目中都可以使用。它主要用来处理身份认证，授权，企业会话管理和加密等。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;分布式系统&#34;&gt;分布式系统&lt;/h2&gt;

&lt;p&gt;若干独立计算机（相关系统）的集合。
1. 应用可以按业务类型拆分成多个应用，再按结构分成接口层、服务层；我们也可以按访问入口分，如移动端、PC端等定义不同的接口应用；
2. 数据库可以按业务类型拆分成多个实例，还可以对单表进行分库分表；
3. 增加分布式缓存、搜索、文件、消息队列、非关系型数据库等中间件&lt;/p&gt;

&lt;p&gt;分布式系统虽好，也带来了系统的复杂性，如分布式事务、分布式锁、分布式session、数据一致性等都是现在分布式系统中需要解决的难题，虽然已经有很多成熟的方案，但都不完美。分布式系统也增加了开发测试运维成本，工作量增加，分布式系统管理不好反而会变成一种负担。&lt;/p&gt;

&lt;h2 id=&#34;cdn&#34;&gt;CDN&lt;/h2&gt;

&lt;p&gt;全称为Content Delivery Network，即内容分发网络。&lt;/p&gt;

&lt;p&gt;其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。&lt;/p&gt;

&lt;p&gt;现在CDN一般都以缓存网站的静态内容为主，如果静态网页页面、JS、CSS、图片等静态文件。如用户访问一个动态网站，首先从服务器请求到动态数据，再从CDN上请求下载静态数据的，因为CDN能就近网络取材，从而减少了下载静态数据的时间，加快了网页的显示速度。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可扩展性，能应对激增的大量用户请求的扩展能力。&lt;/li&gt;
&lt;li&gt;安全性，CDN可以减少DDOS攻击及其他恶意攻击行为，避免对网站业务造成中断。&lt;/li&gt;
&lt;li&gt;可靠性，CDN通过负载均衡能及时提供网络的容错机制能力。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;创建型模式：简单工厂模式（抽象工厂模式），工厂方法模式，建造者模式，原型模式，单例模式√。(5个)&lt;/li&gt;
&lt;li&gt;结构型模式：外观模式、适配器模式、代理模式、装饰模式、桥接模式、组合模式、享元模式。(7个)&lt;/li&gt;
&lt;li&gt;行为型模式：模版方法模式、观察者模式、状态模式、职责链模式、命令模式、访问者模式、策略模式、备忘录模式、迭代器模式、解释器模式、 中介者模式。(11个)&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Java面试之HashMap</title>
      <link>https://ianeiu.github.io/2018/09/13/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/09/13/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/</guid>
      
        <description>

&lt;h3 id=&#34;hashmap-数组-链表&#34;&gt;HashMap（数组+链表）&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;HashMap储存的是键值对&lt;/li&gt;
&lt;li&gt;HashMap可以接受null键值和值，而Hashtable则不能；&lt;/li&gt;
&lt;li&gt;HashMap是非synchronized&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;hashmap的工作原理&#34;&gt;HashMap的工作原理&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细观察哈希值的源头，我们会发现，它并不是 key 本身的 hashCode，
而是来自于HashMap 内部的另外一个 hash 方法。&lt;/p&gt;

&lt;h3 id=&#34;为什么这里需要将高位数据移位到低位进行异或算呢&#34;&gt;为什么这里需要将高位数据移位到低位进行异或算呢？&lt;/h3&gt;

&lt;p&gt;这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，
那么这种处理就可以有效避免类似情况下的哈希碰撞。&lt;/p&gt;

&lt;h3 id=&#34;resize-方法的源码设计&#34;&gt;resize 方法的源码设计&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;final Node&amp;lt;K,V&amp;gt;[] resize() {
    // ...
    else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACIY &amp;amp;&amp;amp;
    oldCap &amp;gt;= DEFAULT_INITIAL_CAPAITY)
        newThr = oldThr &amp;lt;&amp;lt; 1; // double there
    // ...
    else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {
        // zero initial threshold signifies using defaultsfults
        newCap = DEFAULT_INITIAL_CAPAITY;
        newThr = (int)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；
    }
    if (newThr ==0) {
        float ft = (float)newCap * loadFator;
        newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?(int)ft : Intege
    }
    threshold = neThr;
    Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newap];
    table = n；
    // 移动到新的数组结构 e 数组结构
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依据 resize 源码，不考虑极端情况（容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&amp;lt;&amp;lt;30，也就是 2 的 30 次方），
我们可以归纳为：&lt;br /&gt;
* 门限值等于（负载因子）*（容量），如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。
* 门限通常是以倍数进行调整 （newThr = oldThr &amp;lt;&amp;lt; 1），我前面提到，根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。
* 扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。&lt;/p&gt;

&lt;h3 id=&#34;容量-负载因子和树化&#34;&gt;容量、负载因子和树化&lt;/h3&gt;

&lt;p&gt;容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。
极端情况下，假设只有一个桶，那么它就退化成了链表，完全不能提供所谓常数时间存的性能。&lt;/p&gt;

&lt;p&gt;如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。
具体数值我们可以根据扩容发生的条件来做简单预估，根据前面的代码分析，我们知道它需要符合计算条件：负载因子 * 容量 &amp;gt; 元素数量，
所以，预先设置的容量需要满足，大于“预估元素数量 / 负载因子”，同时它是 2 的幂数，结论已经非常清晰了。&lt;/p&gt;

&lt;p&gt;对于负载因子如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。&lt;br /&gt;
如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap的性能。&lt;br /&gt;
如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。&lt;/p&gt;

&lt;p&gt;树化改造，对应逻辑主要在 putVal 和 treeifyBin 中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash) {
    int n, index; Node&amp;lt;K,V&amp;gt; e;
    if (tab == null || (n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) &amp;amp; hash]) != null) {
        // 树化改造逻辑
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;综合这两个方法，树化改造的逻辑就非常清晰了，可以理解为，当 bin 的数量大于 TREEIFY_THRESHOLD 时：
* 如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容。
* 如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。&lt;/p&gt;

&lt;p&gt;那么，为什么 HashMap 要树化呢？&lt;br /&gt;
本质上这是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，
我们知道链表查询是线性的，会严重影响存取的性能。&lt;br /&gt;
而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，
导致服务器端 CPU 大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。&lt;/p&gt;

&lt;h3 id=&#34;当两个对象的hashcode相同&#34;&gt;当两个对象的hashcode相同&lt;/h3&gt;

&lt;p&gt;它们会储存在同一个bucket位置的链表中。因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。
因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。&lt;/p&gt;

&lt;p&gt;HashMap 内部的结构，它可以看作是数组（Node[] table）和链表结合组成的复合结构，
数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；
哈希值相同的键值对，则以链表形式存储。
这里需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），的链表就会被改造为树形结构。&lt;/p&gt;

&lt;h3 id=&#34;两个键的hashcode相同-如何获取值对象&#34;&gt;两个键的hashcode相同,如何获取值对象&lt;/h3&gt;

&lt;p&gt;当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。&lt;/p&gt;

&lt;h3 id=&#34;hashmap的大小超过了负载因子-load-factor-定义的容量-会发生什么&#34;&gt;HashMap的大小超过了负载因子(load factor)定义的容量，会发生什么？&lt;/h3&gt;

&lt;p&gt;对象会进行rehashing，调用hash方法找到新的bucket位置。&lt;br /&gt;
默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。&lt;/p&gt;

&lt;h3 id=&#34;调整hashmap大小存在什么问题&#34;&gt;调整HashMap大小存在什么问题&lt;/h3&gt;

&lt;p&gt;多线程的情况下，可能产生条件竞争(race condition)。如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。&lt;/p&gt;

&lt;h3 id=&#34;为什么string-interger这样的wrapper类适合作为键&#34;&gt;为什么String, Interger这样的wrapper类适合作为键&lt;/h3&gt;

&lt;p&gt;因为wrapper类如String是不可变的，也是final的，而且重写了equals()和hashCode()方法了，防止计算hashCode()改变键值。&lt;/p&gt;

&lt;p&gt;如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。&lt;/p&gt;

&lt;p&gt;也可以使用自定义的对象作为键，条件是遵守equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。&lt;/p&gt;

&lt;h3 id=&#34;hashmap与hashset&#34;&gt;HashMap与HashSet&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;HashMap&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;HashSet&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;实现了Map接口&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;实现了Set接口（构造new HashMap）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;put()存键值对&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;add()存储对象&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;使用键对象来计算hashcode值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;hashmap与hashtable&#34;&gt;HashMap与Hashtable&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;HashMap几乎等于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。&lt;/li&gt;
&lt;li&gt;HashMap是非synchronized，而Hashtable是synchronized。Java 5提供了ConcurrentHashMap，可以替代HashTable&lt;/li&gt;
&lt;li&gt;HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器非fail-fast。所以当有其它线程通过map对象改变了HashMap的结构（增加或者移除元素），会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出这个异常。&lt;/li&gt;
&lt;li&gt;由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。&lt;/li&gt;
&lt;li&gt;HashMap不能保证随着时间的推移Map中的元素次序是不变的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;如何保证容器是线程安全的-concurrenthashmap-如何实现高效地线程安全&#34;&gt;如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？&lt;/h3&gt;

&lt;p&gt;Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 Hashtable 等同步容器，
还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用 Collections 工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap），
但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。&lt;/p&gt;

&lt;p&gt;另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：
* 各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList。
* 各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue。
* 各种有序容器的线程安全版本等。&lt;/p&gt;

&lt;p&gt;具体保证线程安全的方式，包括有从简单的 synchronize 方式，
到基于更加精细化的，比如基于分离锁实现的 ConcurrentHashMap 等并发实现等。&lt;br /&gt;
具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。&lt;/p&gt;

&lt;h3 id=&#34;cocurrenthashmap与hashtable-为什么需要-concurrenthashmap&#34;&gt;CocurrentHashMap与Hashtable (为什么需要 ConcurrentHashMap？)&lt;/h3&gt;

&lt;p&gt;Hashtable是synchronized的(基本就是将 put、get、size 等各种方法加上“synchronized”)，
简单来说，这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其他线程只能等待，大大降低了并发操作的效率。&lt;/p&gt;

&lt;p&gt;同步包装器只是利用输入 Map 构造了另一个同步版本，所有操作虽然不再声明成为 synchronized 方法，
但是还是利用了“this”作为互斥的 mutex，没有真正意义上的改进。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static class SynchronizedMap&amp;lt;K,V&amp;gt;
        implements Map&amp;lt;K,V&amp;gt;, Serializable {
        private static final long serialVersionUID = 1978198479659022715L;

        private final Map&amp;lt;K,V&amp;gt; m;     // Backing Map
        final Object      mutex;        // Object on which to synchronize
        ...
        public int size() {
            synchronized (mutex) {return m.size();}
        }
        public boolean isEmpty() {
            synchronized (mutex) {return m.isEmpty();}
        }
        ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以Hashtable 或者同步包装版本，都只是适合在非高度并发的场景下。&lt;/p&gt;

&lt;p&gt;ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。
ConcurrentHashMap的设计实现其实一直在演化，在 Java 8 中就发生了非常大的变化（ava 7 其实也有不少更新）。&lt;/p&gt;

&lt;p&gt;早期 ConcurrentHashMap，其实现是基于：
* 分离锁，也就是将内部进行分段（Segment），里面则是 HashEntry 的数组，和 HashMap类似，哈希相同的条目也是以链表形式存放。
* HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。&lt;/p&gt;

&lt;p&gt;在构造的时候，Segment 的数量由所谓的 concurrentcyLevel 决定，默认是 16，也可以在相应构造函数直接指定。
注意，Java 需要它是 2 的幂数值，如果输入是类似 15 这种非幂值，会被自动调整到 16 。&lt;/p&gt;

&lt;p&gt;ConcurrentHashMap(JDK7)并发写操作时：&lt;br /&gt;
ConcurrentHashMap 会获取再入锁，以保证数据一致性，Segment 本身就是基于ReentrantLock 的扩展实现，
所以，在并发修改期间，相应 Segment 是被锁定的。
在最初阶段，进行重复性的扫描，以确定相应 key 值是否已经在数组里面，进而决定是更新还是放置操作。
重复扫描、检测冲突是ConcurrentHashMap 的常见技巧。
ConcurrentHashMap进行的不是整体的扩容，而是单独对 Segment进行扩容。&lt;/p&gt;

&lt;p&gt;Map 的 size 方法同样需要关注，它的实现涉及分离锁的一个副作用。
如果不进行同步，简单的计算所有 Segment 的总值，可能会因为并发 put，导致结果不准确，
但是直接锁定所有 Segment 进行计算，就会变得非常昂贵。&lt;br /&gt;
所以，ConcurrentHashMap 的实现是通过重试机制（RETRIES_BEFORE_LOCK，指定重试次数 2），来试图获得可靠值。
如果没有监控到发生变化（通过对比 Segment.modCount），就直接返回，否则获取锁进行操作。&lt;/p&gt;

&lt;h3 id=&#34;在-java-8-和之后的版本中-concurrenthashmap-发生了哪些变化呢&#34;&gt;在 Java 8 和之后的版本中，ConcurrentHashMap 发生了哪些变化呢&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;总体结构上，它的内部存储变得和 HashMap 结构非常相似，同样是大的桶（bucket）数组，然后内部也是一个个所谓的链表结构（bin），同步的粒度要更细致一些。&lt;/li&gt;
&lt;li&gt;其内部仍然有 Segment 定义，但仅仅是为了保证序列化时的兼容性而已，不再有任何结构上的用处。&lt;/li&gt;
&lt;li&gt;因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销，解决了老版本很多人抱怨的这一点。&lt;/li&gt;
&lt;li&gt;数据存储利用 volatile 来保证可见性。&lt;/li&gt;
&lt;li&gt;使用 CAS 等操作，在特定场景进行无锁并发操作。&lt;/li&gt;
&lt;li&gt;使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>JVM笔记之JVM结构</title>
      <link>https://ianeiu.github.io/2018/09/11/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/09/11/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/</guid>
      
        <description>

&lt;h2 id=&#34;jvm运行时数据区&#34;&gt;JVM运行时数据区&lt;/h2&gt;

&lt;p&gt;运行时数据区（分布在操作系统堆中，由程序员管理）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;虚拟机栈（Java栈）&lt;/li&gt;
&lt;li&gt;堆（Java堆）&lt;/li&gt;
&lt;li&gt;本地方法栈/区&lt;/li&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img style=&#34;width:60%&#34; src=&#34;https://ianeiu.github.io/resouce/JVM/JVM结构.jpg&#34;  alt=&#34;JVM结构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;虽然这几个区域都是属于运行时数据区，但是这几个区域的创建时机是不一致的，有的是随虚拟机启动而创建的，随虚拟机销毁而销毁；有的是随线程创建而创建，随线程销毁而销毁。&lt;/p&gt;

&lt;h2 id=&#34;线程独享的区域&#34;&gt;线程独享的区域&lt;/h2&gt;

&lt;h4 id=&#34;程序计数器&#34;&gt;程序计数器&lt;/h4&gt;

&lt;p&gt;程序计数器是来指示当前线程正在执行的JVM指令，因此程序计数器是线程独有的。一个JVM支持多个线程，每一个线程都要自己的程序计数器。&lt;br /&gt;
如果线程正在执行的方法是Java方法，则程序计数器保存的是当前线程正在执行的JVM指令，如果正在执行的方法是Native方法，则保存为空（undefined)。&lt;/p&gt;

&lt;h4 id=&#34;虚拟机栈&#34;&gt;虚拟机栈&lt;/h4&gt;

&lt;p&gt;每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用。每个栈中的数据(原始类型和对象引用)都是私有的。数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失。&lt;br /&gt;
栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。&lt;/p&gt;

&lt;h4 id=&#34;本地方法区&#34;&gt;本地方法区&lt;/h4&gt;

&lt;p&gt;本地方法区存储着native方法的调用状态，一般会随着线程创建而针对每一个线程分配。&lt;/p&gt;

&lt;h2 id=&#34;全局共享的区域&#34;&gt;全局共享的区域&lt;/h2&gt;

&lt;h4 id=&#34;方法区&#34;&gt;方法区&lt;/h4&gt;

&lt;p&gt;方法区是可供各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量等。当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域。&lt;/p&gt;

&lt;p&gt;由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;运行时常量池&lt;/strong&gt; ：方法区的一部分&lt;em&gt;（Java jdk1.7中的常量池是移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域）    &lt;/em&gt;，存放着类中固定的常量信息、方法、和field的引用信息。JVM在加载类的时候会为每一个Class分配一个独立的常量池。&lt;/p&gt;

&lt;h4 id=&#34;堆&#34;&gt;堆&lt;/h4&gt;

&lt;p&gt;JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，存储着所有类实例即类对象和数组对象。对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定&lt;/p&gt;

&lt;p&gt;理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。&lt;/p&gt;

&lt;p&gt;&lt;img style=&#34;width:60%&#34; src=&#34;https://ianeiu.github.io/resouce/JVM/JVM.png&#34;  alt=&#34;jvm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;JVM 本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT Compiler 在运行时对热点方法进行编译，就会将编译后的方法储存在 Code Cache 里面；GC 等功能需要运行在本地线程之中，类似部分都需要占用内存空间。&lt;/p&gt;

&lt;p&gt;JDK 已经发生了很大变化，Intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，Intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。&lt;/p&gt;

&lt;h2 id=&#34;堆内部结构&#34;&gt;堆内部结构&lt;/h2&gt;

&lt;p&gt;&lt;img style=&#34;width:60%&#34; src=&#34;https://ianeiu.github.io/resouce/JVM/HeapInner.jpg&#34;  alt=&#34;HeapInner&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;新生代&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫from、to 区域，被用来放置从 Minor GC 中保留下来的对象。&lt;/p&gt;

&lt;p&gt;JVM 会随意选取一个 Survivor 区域作为“to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 from 区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;老年代&lt;/p&gt;

&lt;p&gt;放置长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;永久代&lt;/p&gt;

&lt;p&gt;这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存，在 JDK 8 之后就不存在永久代这块儿了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Java开发之常量定义</title>
      <link>https://ianeiu.github.io/2018/09/11/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2018/09/11/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89/</guid>
      
        <description>

&lt;p&gt;原文地址 &lt;a href=&#34;https://blog.csdn.net/autofei/article/details/6419460&#34; target=&#34;blank&#34;&gt;如何在Java中定义常量(Constant)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;java中定义常量的四种方法&#34;&gt;Java中定义常量的四种方法&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;/**&lt;/span&gt; 
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;One&lt;/span&gt; 
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;采用接口&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;的中变量默认为&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final的特性&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*/&lt;/span&gt;  
&lt;span class=&#34;n&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConstantInterface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;SUNDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;MONDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;TUESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;WEDNESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;THURSDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;FRIDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;SATURDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  

&lt;span class=&#34;o&#34;&gt;/**&lt;/span&gt; 
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Two&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;采用了&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Java&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;5.0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;中引入的&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Enum类型&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;推荐使用&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*/&lt;/span&gt;  
&lt;span class=&#34;n&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConstantEnum&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt;  
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
 
&lt;span class=&#34;o&#34;&gt;/**&lt;/span&gt; 
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Three&lt;/span&gt; 
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;采用了在普通类中使用&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final修饰变量的方法&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*/&lt;/span&gt;  
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ConstantClassField&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;SUNDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;MONDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;TUESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;WEDNESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;THURSDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;FRIDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;SATURDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;/**&lt;/span&gt; 
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Four&lt;/span&gt; 
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;类似方法三，但是通过函数来获取常量&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ibm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;developerworks&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;html&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*/&lt;/span&gt;  
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ConstantClassFunction&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;SUNDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;MONDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;TUESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;WEDNESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;THURSDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;FRIDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;SATURDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getSunday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getMonday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getTuesday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getWednesday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getThursday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getFirday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getSaturday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;TestConstant&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;day&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;saturday&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Is today Saturday?&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;day&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConstantInterface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;day&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConstantEnum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()));&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;day&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConstantClassField&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;day&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConstantClassFunction&lt;/span&gt;  
				&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getSaturday&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()));&lt;/span&gt;  
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
  </channel>
</rss>
