<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>吴炜棉</title>
        <link>https://ianeiu.github.io/</link>
        <description>Recent content on 吴炜棉</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <lastBuildDate>Tue, 27 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://ianeiu.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>mysql面试题</title>
        <link>https://ianeiu.github.io/p/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
        <pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
        <description>&lt;h2 id=&#34;mysql-innodbmysaim的特点&#34;&gt;MySQL InnoDB、Mysaim的特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB
&lt;ol&gt;
&lt;li&gt;支持事务处理、外键、行锁&lt;/li&gt;
&lt;li&gt;不保存表的具体行数，扫描表来计算多少行&lt;/li&gt;
&lt;li&gt;对于AUTO_INCREMENT类型的字段，必须包含只有该字段的索引&lt;/li&gt;
&lt;li&gt;DELETE表时，是一行一行的删除&lt;/li&gt;
&lt;li&gt;把数据和索引存放在表空间里面&lt;/li&gt;
&lt;li&gt;跨平台直接拷贝使用&lt;/li&gt;
&lt;li&gt;表格很难被压缩&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Mysaim （适合读多写少的场景）
&lt;ol&gt;
&lt;li&gt;不支持事务、外键&lt;/li&gt;
&lt;li&gt;保存表具体行数&lt;/li&gt;
&lt;li&gt;AUTO_INCREMENT可以与其他字段一起建联合索引&lt;/li&gt;
&lt;li&gt;DELETE表时先drop表，然后重建&lt;/li&gt;
&lt;li&gt;表将存放三个文件。frm文件存在表格定义，myds数据文件，myi存在索引&lt;/li&gt;
&lt;li&gt;跨平台很难卡片被&lt;/li&gt;
&lt;li&gt;表格可压缩&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql主备同步的基本原理&#34;&gt;Mysql主备同步的基本原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;master将该表记录到二进制日志 binary log中&lt;/li&gt;
&lt;li&gt;salve将master的binary log events 拷贝到它的中继日志relay log&lt;/li&gt;
&lt;li&gt;salve重做中继日志中的事件，改变数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何优化数据库性能索引分库分表批置操作分页算法升级硬盘ssd业务优化主从部署&#34;&gt;如何优化数据库性能（索引、分库分表、批置操作、分页算法、升级硬盘SSD、业务优化、主从部署）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;选择合适的数据库引擎，合理使用索引&lt;/li&gt;
&lt;li&gt;分页获取数据，按需取字段&lt;/li&gt;
&lt;li&gt;优化业务代码，减少数据库IO&lt;/li&gt;
&lt;li&gt;分库分表&lt;/li&gt;
&lt;li&gt;部署主从数据库&lt;/li&gt;
&lt;li&gt;升级硬件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sql什么情况下不会使用索引不包含不等于函数&#34;&gt;SQL什么情况下不会使用索引（不包含，不等于，函数）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;select * 可能导致不走索引&lt;/li&gt;
&lt;li&gt;空值会导致不走索引&lt;/li&gt;
&lt;li&gt;索引列有函数运算&lt;/li&gt;
&lt;li&gt;隐式转换可能导致不走索引&lt;/li&gt;
&lt;li&gt;表的数据库小或者需要选择大部分数据，不走索引&lt;/li&gt;
&lt;li&gt;!= 或者 &amp;lt;&amp;gt;&lt;/li&gt;
&lt;li&gt;like &amp;lsquo;%ex&amp;rsquo;&lt;/li&gt;
&lt;li&gt;not in 、 not exist&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;一般在什么字段上建索引过滤数据最多的字段&#34;&gt;一般在什么字段上建索引（过滤数据最多的字段）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;表的主键、外键&lt;/li&gt;
&lt;li&gt;数据量超过300的表&lt;/li&gt;
&lt;li&gt;经常与其他表进行连接的表的连接字段&lt;/li&gt;
&lt;li&gt;经常出现在where语句上的字段&lt;/li&gt;
&lt;li&gt;应该建在选择性高的字段、小字段&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mysql调优&#34;&gt;mysql调优&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;explain select 语句&lt;/li&gt;
&lt;li&gt;当只要一条数据时使用limit 1&lt;/li&gt;
&lt;li&gt;为查询字段建索引&lt;/li&gt;
&lt;li&gt;避免select *&lt;/li&gt;
&lt;li&gt;字段尽量使用not null&lt;/li&gt;
&lt;li&gt;垂直分割&lt;/li&gt;
&lt;li&gt;拆分大的delete和insert，这俩会锁表&lt;/li&gt;
&lt;li&gt;分库分表分区&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>struts工作流程</title>
        <link>https://ianeiu.github.io/p/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link>
        <pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid>
        <description>&lt;h2 id=&#34;struts工作流程&#34;&gt;struts工作流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;客户端浏览器发出HTTP请求。&lt;/li&gt;
&lt;li&gt;根据web.xml配置，该请求被FilterDispatcher接收。&lt;/li&gt;
&lt;li&gt;根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。&lt;/li&gt;
&lt;li&gt;Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。&lt;/li&gt;
&lt;li&gt;Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。&lt;/li&gt;
&lt;li&gt;返回HTTP响应到客户端浏览器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png&#34; data-size=&#34;680x710&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B_hu622a93dbdf3bb333382e70a1e40e2768_310431_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B_hu622a93dbdf3bb333382e70a1e40e2768_310431_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/struts%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png&#34; width=&#34;680&#34; height=&#34;710&#34; loading=&#34;lazy&#34;
				alt=&#34;&amp;nbsp;&#34;&gt;
		&lt;/a&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Spring面试题</title>
        <link>https://ianeiu.github.io/p/spring%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
        <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/spring%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
        <description>&lt;h2 id=&#34;spring装配bean的过程&#34;&gt;Spring装配Bean的过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;实例化;&lt;/li&gt;
&lt;li&gt;设置属性值;&lt;/li&gt;
&lt;li&gt;如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name;&lt;/li&gt;
&lt;li&gt;如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory;&lt;/li&gt;
&lt;li&gt;如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext&lt;/li&gt;
&lt;li&gt;调用BeanPostProcessor的预先初始化方法;&lt;/li&gt;
&lt;li&gt;调用InitializingBean的afterPropertiesSet()方法;&lt;/li&gt;
&lt;li&gt;调用定制init-method方法；&lt;/li&gt;
&lt;li&gt;调用BeanPostProcessor的后初始化方法;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;springboot的启动过程&#34;&gt;springboot的启动过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过 SpringFactoriesLoader加载 META-INF/spring.factories文件，获取并创建 SpringApplicationRunListener对象&lt;/li&gt;
&lt;li&gt;然后由 SpringApplicationRunListener来发出 starting 消息&lt;/li&gt;
&lt;li&gt;创建参数，并配置当前 SpringBoot 应用将要使用的 Environment&lt;/li&gt;
&lt;li&gt;完成之后，依然由 SpringApplicationRunListener来发出 environmentPrepared 消息&lt;/li&gt;
&lt;li&gt;创建 ApplicationContext&lt;/li&gt;
&lt;li&gt;初始化 ApplicationContext，并设置 Environment，加载相关配置等&lt;/li&gt;
&lt;li&gt;由 SpringApplicationRunListener来发出 contextPrepared消息，告知SpringBoot 应用使用的ApplicationContext已准备OK&lt;/li&gt;
&lt;li&gt;将各种 beans 装载入 ApplicationContext，继续由 SpringApplicationRunListener来发出 contextLoaded 消息，告知SpringBoot 应用使用的 ApplicationContext已装填OK&lt;/li&gt;
&lt;li&gt;refresh ApplicationContext，完成IoC容器可用的最后一步&lt;/li&gt;
&lt;li&gt;由 SpringApplicationRunListener来发出 started 消息&lt;/li&gt;
&lt;li&gt;完成最终的程序的启动&lt;/li&gt;
&lt;li&gt;由 SpringApplicationRunListener来发出 running 消息，告知程序已运行行起来了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/spring%E9%9D%A2%E8%AF%95%E9%A2%98/springboot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png&#34; data-size=&#34;960x961&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/spring%E9%9D%A2%E8%AF%95%E9%A2%98/springboot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B_hu44590242c4e1126b79f4195e0ff5f72c_172239_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/spring%E9%9D%A2%E8%AF%95%E9%A2%98/springboot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B_hu44590242c4e1126b79f4195e0ff5f72c_172239_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/spring%E9%9D%A2%E8%AF%95%E9%A2%98/springboot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png&#34; width=&#34;960&#34; height=&#34;961&#34; loading=&#34;lazy&#34;
				alt=&#34;&amp;nbsp;&#34;&gt;
		&lt;/a&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;spring事件的实现原理写出常用的几个事件&#34;&gt;spring事件的实现原理，写出常用的几个事件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;事件机制：Spring中的事件机制是一个观察者模式的实现.观察者模式就是一个目标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。&lt;/li&gt;
&lt;li&gt;spring默认存在的事件：
&lt;ol&gt;
&lt;li&gt;ContextStartedEvent：ApplicationContext启动后触发的事件&lt;/li&gt;
&lt;li&gt;ContextStoppedEvent：ApplicationContext停止后触发的事件&lt;/li&gt;
&lt;li&gt;ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件&lt;/li&gt;
&lt;li&gt;ContextClosedEvent：ApplicationContext关闭后触发的事件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spring中的设计模式&#34;&gt;spring中的设计模式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;简单工厂：spring中的BeanFactory就是简单工厂模式的体现，根据传⼊入一个唯一的标识来获得bean对象，但是否是在传⼊参数后创建还是传入参数前创建这个要根据具体情况来定。&lt;/li&gt;
&lt;li&gt;单例模式：Spring下默认的bean均为singleton。&lt;/li&gt;
&lt;li&gt;代理模式：为其他对象提供⼀种代理以控制对这个对象的访问。从结构上来看和Decorator模式类似，但Proxy是控制，更更像是一种对功能的限制，而Decorator是增加职责。 spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。&lt;/li&gt;
&lt;li&gt;观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更更新。spring中Observer模式常用的地方是listener的实现。如ApplicationListener。&lt;/li&gt;
&lt;li&gt;模板模式：类似 JdbcTemplate 等则是应用了模板模式。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Java笔记之NIO</title>
        <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/</link>
        <pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/</guid>
        <description>&lt;h2 id=&#34;java-提供了哪些-io-方式-nio-如何实现多路复用&#34;&gt;Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？&lt;/h2&gt;
&lt;p&gt;Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。
首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。 交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时， 在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。
java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。&lt;/p&gt;
&lt;p&gt;很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、 HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。&lt;/p&gt;
&lt;p&gt;第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象， 可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。&lt;/p&gt;
&lt;p&gt;第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。
异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里， 当后台处理完成，操作系统会通知相应线程进行后续工作。&lt;/p&gt;
&lt;p&gt;NIO是一种非阻塞式I/O；采用了双向通道进行数据传输，NIO基于Channel和Buffer(缓冲区)进⾏操作，数据总是从通道读取到缓冲区中，或者从缓冲区
写⼊入到通道中。Selector(选择区 [阻塞] )用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。
利用单线程轮询事件的机制，有效避免大量客户端连接时，频繁线程切换带来的问题。&lt;/p&gt;
&lt;h2 id=&#34;ionio&#34;&gt;IO、NIO&lt;/h2&gt;
&lt;p&gt;IO 概览:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IO 不仅仅是对文件的操作，网络编程中，比如 Socket 通信，都是典型的 IO 操作目标。&lt;/li&gt;
&lt;li&gt;输入流、输出流（InputStream/OutputStream）是用于读取或写入字节的，例如操作图片文件。&lt;/li&gt;
&lt;li&gt;Reader/Writer 用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader/Writer 相当于构建了应用逻辑和原始数据之间的桥梁。&lt;/li&gt;
&lt;li&gt;BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。&lt;/li&gt;
&lt;li&gt;很多 IO 工具类都实现了 Closeable 接口，因为需要进行资源的释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NIO 概览：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的 Buffer 实现。&lt;/li&gt;
&lt;li&gt;Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式IO 操作的一种抽象。&lt;/li&gt;
&lt;li&gt;File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过Socket 获取 Channel，反之亦然。&lt;/li&gt;
&lt;li&gt;Selector，是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多Channel 的高效管理。&lt;/li&gt;
&lt;li&gt;Chartset，提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，Charset.defaultCharset().encode(&amp;ldquo;Hello world!&amp;quot;))进行字符串到 ByteBuffer 的转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IO 适用场景&lt;br&gt;
如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更更合适。使⽤用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作⽐比较来权衡选择。&lt;/p&gt;
&lt;p&gt;NIO 适用场景&lt;br&gt;
如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候用NIO处理数据可能是个很好的选择。(适⽤用于小数据多连接)&lt;/p&gt;
&lt;p&gt;NIO原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由一个专门的线程来处理所有的 IO 事件，并负责分发。&lt;/li&gt;
&lt;li&gt;事件驱动机制：事件到的时候触发，而不是同步的去监视事件。&lt;/li&gt;
&lt;li&gt;线程通讯：线程之间通过 wait，notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/nio.png&#34; data-size=&#34;689x251&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/nio_huff8d1d00c71cc7eb26399567c9b43855_162553_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/nio_huff8d1d00c71cc7eb26399567c9b43855_162553_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/nio.png&#34; width=&#34;689&#34; height=&#34;251&#34; loading=&#34;lazy&#34;
				alt=&#34;NIO&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;NIO&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JVM笔记之调优及参数</title>
        <link>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B0%83%E4%BC%98%E5%8F%8A%E5%8F%82%E6%95%B0/</link>
        <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B0%83%E4%BC%98%E5%8F%8A%E5%8F%82%E6%95%B0/</guid>
        <description>&lt;h1 id=&#34;调优&#34;&gt;调优&lt;/h1&gt;
&lt;h2 id=&#34;调优时机&#34;&gt;调优时机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;内存（⽼年代）持续上涨达到设置的最大内存值；&lt;/li&gt;
&lt;li&gt;Full GC 次数频繁；&lt;/li&gt;
&lt;li&gt;GC 停顿时间过长（超过1秒）；&lt;/li&gt;
&lt;li&gt;应用出现OutOfMemory 等内存异常；&lt;/li&gt;
&lt;li&gt;应⽤中使用本地缓存占用大量内存空间；&lt;/li&gt;
&lt;li&gt;系统吞吐量量与响应性能不高或下降。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;调优原则&#34;&gt;调优原则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;多数的Java应用不需要在服务器上进行JVM优化，JVM优化是到最后不得已才采用的⼿段；&lt;/li&gt;
&lt;li&gt;多数导致GC问题的Java应用，往往是代码问题，分析GC情况优化代码；&lt;/li&gt;
&lt;li&gt;在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；&lt;/li&gt;
&lt;li&gt;减少创建对象的数量；&lt;/li&gt;
&lt;li&gt;减少使用全局变量和大对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;调优目标&#34;&gt;调优目标&lt;/h2&gt;
&lt;p&gt;GC低停顿、低频率； 低内存占用；⾼吞吐量&lt;/p&gt;
&lt;h2 id=&#34;调优步骤&#34;&gt;调优步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;分析GC日志及dump⽂文件，判断是否需要优化，确定瓶颈问题点；&lt;/li&gt;
&lt;li&gt;确定jvm调优量化目标；&lt;/li&gt;
&lt;li&gt;确定jvm调优参数（根据历史jvm参数来调整）；&lt;/li&gt;
&lt;li&gt;调优一台服务器，对比观察调优前后的差异；&lt;/li&gt;
&lt;li&gt;不断的分析和调整，直到找到合适的jvm参数配置；&lt;/li&gt;
&lt;li&gt;找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;参数&#34;&gt;参数&lt;/h1&gt;
&lt;h2 id=&#34;堆参数设置&#34;&gt;堆参数设置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-Xms 设置Java程序启动时初始化JVM堆内存大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-Xmx 设置Java程序能获得最大JVM堆内存大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-XX:+PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-XX:+PrintGCDetails 可以查看详细信息，包括各个区的情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-XX:+PrintHeapAtGC 打印 GC 前后的详细堆栈信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-XX:+PrintFlagsInitial打印JVM初始化参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-XX:+PrintFlagsFinal　标记人为修改过的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-XX:+PrintCommandLineFlags 查看默认垃圾回收器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新生代参数设置&#34;&gt;新生代参数设置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-XX:NewSize=5m 设置新生代最小空间大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-XX:MaxNewSize=10m 设置新生代最大空间大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-Xmn2g 设置新生代大小为2G，设置一个比较大的新生代会减少老年代的大小，这个参数对系统性能以及GC行为有很大的影响，&lt;!-- raw HTML omitted --&gt;新生代大小一般会设置整个堆空间的1/3&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-XX:SurvivorRatio=8（默认）用来设置新生代中eden空间和from/to空间的比例。-XX:SurvivorRatio=eden/from=eden/to。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本策略：尽可能将对象预留在新生代，减少老年代的GC次数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-XX:NewRatio=2（默认）设置新生代和老年代的比例 。-XX：NewRatio=老年代/新生代。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对象进入老年代参数设置&#34;&gt;对象进入老年代参数设置&lt;/h2&gt;
&lt;p&gt;-XX:MaxTenuringThreshold=15&lt;/p&gt;
&lt;p&gt;新生代每次GC之后如果对象没有被回收，则年龄加1，默认情况下为15&lt;/p&gt;
&lt;h2 id=&#34;堆溢出参数配置&#34;&gt;堆溢出参数配置&lt;/h2&gt;
&lt;p&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/p&gt;
&lt;p&gt;使用该参数可以在内存溢出时导出整个堆信息&lt;/p&gt;
&lt;p&gt;-XX:HeapDumpPath=D:/OOM.dump&lt;/p&gt;
&lt;p&gt;可以设置导出堆的存放路径。&lt;/p&gt;
&lt;h2 id=&#34;堆栈相关参数配置&#34;&gt;堆栈相关参数配置&lt;/h2&gt;
&lt;p&gt;　-Xss1m（默认）
　
来指定线程的最大栈空间&lt;/p&gt;
&lt;h2 id=&#34;方法区相关参数配置&#34;&gt;方法区相关参数配置&lt;/h2&gt;
&lt;p&gt;JDK1.2 ~ JDK6，使用永久代来实现方法区&lt;/p&gt;
&lt;p&gt;-XX:PermSize=64M&lt;/p&gt;
&lt;p&gt;设置永久代最小空间大小。&lt;/p&gt;
&lt;p&gt;-XX:MaxPermSize=64M（默认）&lt;/p&gt;
&lt;p&gt;如果系统运行时生产大量的类，就需要设置一个相对合适的方法区，以免出现永久区内存溢出的问题。&lt;/p&gt;
&lt;p&gt;Java8，元空间取代永久代，存储位置不同，永久代物理是堆的一部分，和新生代，老年代地址是连续的&lt;/p&gt;
&lt;p&gt;而元数据放到本地化的堆内存(native heap)中，这一块区域就叫Metaspace&lt;/p&gt;
&lt;p&gt;-XX:MetaspaceSize=128m（默认）&lt;/p&gt;
&lt;p&gt;初始化大小。&lt;/p&gt;
&lt;p&gt;　-XX:MaxMetaspaceSize=128m　&lt;/p&gt;
&lt;p&gt;JVM默认在运行时根据需要动态地设置MaxMetaspaceSize的大小。&lt;/p&gt;
&lt;h2 id=&#34;直接内存堆外内存参数配置&#34;&gt;直接内存（堆外内存）参数配置&lt;/h2&gt;
&lt;p&gt;-XX:MaxDirectMemorySize=64m&lt;/p&gt;
&lt;p&gt;该值是有上限的，默认是64M，最大为sun.misc.VM.maxDirectMemory()。   直接内存使用达到上限时，就会触发垃圾回收（Full GC），如果不能有效的释放空间，就会引起系统的OOM。&lt;/p&gt;
&lt;h2 id=&#34;tlab参数配置&#34;&gt;TLAB参数配置&lt;/h2&gt;
&lt;p&gt;Thread Local Allocation Buffer即线程本地分配缓存：&lt;/p&gt;
&lt;p&gt;一个线程专用的内存分配区域，是为了加速对象分配对象而生的。每一个线程都会产生一个TLAB，该线程独享的工作区域，Java虚拟机使用这种TLAB区避免多线程冲突问题，提高了对象分配的效率。&lt;/p&gt;
&lt;p&gt;-XX:+UseTLAB（默认开启）&lt;/p&gt;
&lt;p&gt;使用TLAB&lt;/p&gt;
&lt;p&gt;-XX:TLABSize=64k（默认）　&lt;/p&gt;
&lt;p&gt;设置TLAB初始化大小&lt;/p&gt;
&lt;p&gt;-XX:TLABRefillWasteFraction=64&lt;/p&gt;
&lt;p&gt;设置维护进入TLAB空间的单个对象大小，它是一个比例值，默认为64，即如果对象大于整个空间的1/64，则在堆创建对象。&lt;/p&gt;
&lt;p&gt;　-XX:+ResizeTLAB　&lt;/p&gt;
&lt;p&gt;自调整TLABRefillWasteFraction阈值。&lt;/p&gt;
&lt;p&gt;-XX:+PrintTLAB　&lt;/p&gt;
&lt;p&gt;查看TLAB信息&lt;/p&gt;
</description>
        </item>
        <item>
        <title>正则表达式——贪婪模式与懒惰模式</title>
        <link>https://ianeiu.github.io/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;&lt;strong&gt;知识点：正则表达式中表示字符串重复个数的元字符，如 &lt;code&gt;?,+,*,{}&lt;/code&gt;  默认贪婪模式匹配最大长度匹配字符串。
在元字符后加个&lt;code&gt;?&lt;/code&gt;即可切换为懒惰模式&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前做过一个短信模版的配置功能，需要用到正则判断完成预览方法，踩了个小坑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 部分代码 --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;//libs.baidu.com/jquery/1.10.2/jquery.min.js&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
$(document).ready(function () {
	createContentPreview()
});


function createContentPreview(){
        //遍历获取所有input标签值
	var vals=[];
	$(&amp;quot;#tExaDiv&amp;quot;).find(&amp;quot;input&amp;quot;).each(function(){
		var val=$(this).val();
		vals.push(val);
	})
	
        // 含有&amp;lt;input type=&amp;quot;..&amp;quot; /&amp;gt;标签
	var html=$(&amp;quot;#tExaDiv&amp;quot;).html();

        //遍历替换
	var reg=/&amp;lt;input[^]*?&amp;gt;/;
	for(var i=0;i&amp;lt;vals.length;i++){
		html=html.replace(reg,vals[i]);
	}

        //渲染
	$(&amp;quot;#contentPreview&amp;quot;).html(html);
}
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;tExaDiv&amp;quot;&amp;gt;
	如果我是&amp;lt;input =&amp;quot;text&amp;quot; value=&amp;quot;dj&amp;quot;/&amp;gt;,你会&amp;lt;input =&amp;quot;text&amp;quot; value=&amp;quot;爱&amp;quot;/&amp;gt;我吗？
&amp;lt;/div&amp;gt;

&amp;lt;div id=&amp;quot;contentPreview&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;contentPreview内容：如果我是dj,你会爱我吗？&lt;br&gt;
如果未加?，则是贪婪模式。contentPreview显示错误内容：如果我是dj我吗？&lt;/p&gt;
&lt;h2 id=&#34;懒惰模式&#34;&gt;懒惰模式&lt;/h2&gt;
&lt;p&gt;对字符串进行最小长度匹配&lt;/p&gt;
&lt;p&gt;字符串：&lt;code&gt;&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br&gt;
正则表达式：&lt;code&gt;&amp;lt;span&amp;gt;.*?&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br&gt;
匹配结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;共找到 2 处匹配：  
	&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt; 
	&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;贪婪模式&#34;&gt;贪婪模式&lt;/h2&gt;
&lt;p&gt;对字符串进行最大长度匹配&lt;/p&gt;
&lt;p&gt;字符串：&lt;code&gt;&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt; &lt;/code&gt;&lt;br&gt;
正则表达式：&lt;code&gt;&amp;lt;span&amp;gt;.*&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br&gt;
匹配结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;共找到 1 处匹配：
&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;常见元字符及其含义&#34;&gt;常见元字符及其含义&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;符号               含义
————————————————————————————————————————————————————
.                  匹配除换行符之外的任意字符
^                  匹配字符的开始位置
$                  匹配字符的结束位置
*                  匹配0次，1次或多次前面的原子
?                  匹配0次或1次前面的原子
+                  匹配1次或多次前面的原子
{n}                前面的原子恰好出现n次
{n,}               前面的原子至少出现n次
{n,m}              前面的原子至少出现n次，至多出现m次
|                  模式选择符
()                 模式单元符   
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Java面试之并发</title>
        <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/</link>
        <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/</guid>
        <description>&lt;h2 id=&#34;什么是乐观锁和悲观锁&#34;&gt;什么是乐观锁和悲观锁？&lt;/h2&gt;
&lt;p&gt;1、悲观锁&lt;br&gt;
Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。&lt;/p&gt;
&lt;p&gt;2、乐观锁&lt;br&gt;
乐观锁（Optimstic Locking）其实是一种思想。相对悲观锁而言，乐观锁假定认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式地对数据的冲突与否进行检测，如果发现冲突了，则返回错误信息。&lt;/p&gt;
&lt;h2 id=&#34;什么是aqs&#34;&gt;什么是AQS&lt;/h2&gt;
&lt;p&gt;AbstractQueuedSynchronizer，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、FutureTask等。&lt;/p&gt;
&lt;p&gt;AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作 哨兵节点或这哑节点，它不与任何线程关联。其他节点与等待线程关联，每个节点维护一个等待状态waitStatus。&lt;/p&gt;
&lt;h2 id=&#34;同步容器与并发容器&#34;&gt;同步容器与并发容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;同步容器
&lt;ol&gt;
&lt;li&gt;同步容器主要代表用Vector和Hashtable，及Collections.synchronizedXXX等&lt;/li&gt;
&lt;li&gt;锁粒度为整体对象&lt;/li&gt;
&lt;li&gt;迭代器是及时失败的，迭代过程修改会抛出ConcurrentModificationException&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;并发容器
&lt;ol&gt;
&lt;li&gt;主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet&lt;/li&gt;
&lt;li&gt;锁粒度是分散的、细粒度，即读写使用不同锁&lt;/li&gt;
&lt;li&gt;迭代器具有弱一致性，能够迭代时修改。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;synchronized-底层如何实现什么是锁的升级降级&#34;&gt;synchronized 底层如何实现？什么是锁的升级、降级？&lt;/h2&gt;
&lt;p&gt;synchronized 代码块是由 monitorenter/monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。&lt;/p&gt;
&lt;p&gt;在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。&lt;/p&gt;
&lt;p&gt;现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，
也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。&lt;/p&gt;
&lt;p&gt;所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，
当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。&lt;/p&gt;
&lt;p&gt;当没有竞争出现时，默认会使用偏斜锁。
JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。
这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。&lt;/p&gt;
&lt;p&gt;如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。
轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。&lt;/p&gt;
&lt;p&gt;当JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。&lt;/p&gt;
&lt;p&gt;偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，
只有当存在较多不会真正竞争的 synchronized 块儿时，才能体现出明显改善。
实践中对于偏斜锁的一直是有争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。
还有一方面是，偏斜锁会延缓 JIT 预热的进程，所以很多性能测试中会显式地关闭偏斜锁，命令：&lt;code&gt;-XX:-UseBiasedLocking&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;自旋锁是做什么的吗它的使用场景是什么&#34;&gt;“自旋锁”是做什么的吗？它的使用场景是什么？&lt;/h2&gt;
&lt;p&gt;自旋锁:&lt;br&gt;
竞争锁失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，
在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。&lt;/p&gt;
&lt;p&gt;适用场景:&lt;br&gt;
自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，
因为自旋的消耗会小于线程阻塞挂起操作的消耗。
如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁了，
因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费。&lt;/p&gt;
&lt;h2 id=&#34;一个线程两次调用-start-方法会出现什么情况谈谈线程的生命周期和状态转移&#34;&gt;一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。&lt;/h2&gt;
&lt;p&gt;Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException。&lt;br&gt;
在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。&lt;/p&gt;
&lt;p&gt;线程的生命周期和状态转移 详见java笔记基础篇&lt;/p&gt;
&lt;p&gt;线程是系统调度的最小单元，一个进程可以包含多个线程，
作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（ThreadLocal）等，
但是会和进程内其他线程共享文件描述符、虚拟地址空间等。&lt;/p&gt;
&lt;h2 id=&#34;虚假唤醒&#34;&gt;虚假唤醒&lt;/h2&gt;
&lt;p&gt;在多核处理器下，pthread_cond_signal可能会激活多于一个线程（阻塞在条件变量上的线程）。
结果就是，当一个线程调用pthread_cond_signal()后，多个调用pthread_cond_wait()或pthread_cond_timedwait()的线程返回。这种效应就称为“虚假唤醒”。&lt;/p&gt;
&lt;p&gt;举个例子，我们现在有一个生产者-消费者队列和三个线程。&lt;/p&gt;
&lt;p&gt;1） 1号线程从队列中获取了一个元素，此时队列变为空。&lt;/p&gt;
&lt;p&gt;2） 2号线程也想从队列中获取一个元素，但此时队列为空，2号线程便只能进入阻塞(cond.wait())，等待队列非空。&lt;/p&gt;
&lt;p&gt;3） 这时，3号线程将一个元素入队，并调用cond.notify()唤醒条件变量。&lt;/p&gt;
&lt;p&gt;4） 处于等待状态的2号线程接收到3号线程的唤醒信号，便准备解除阻塞状态，执行接下来的任务(获取队列中的元素)。&lt;/p&gt;
&lt;p&gt;5） 然而可能出现这样的情况：当2号线程准备获得队列的锁，去获取队列中的元素时，此时1号线程刚好执行完之前的元素操作，返回再去请求队列中的元素，1号线程便获得队列的锁，检查到队列非空，就获取到了3号线程刚刚入队的元素，然后释放队列锁。&lt;/p&gt;
&lt;p&gt;6） 等到2号线程获得队列锁，判断发现队列仍为空，1号线程“偷走了”这个元素，所以对于2号线程而言，这次唤醒就是“虚假”的，它需要再次等待队列非空。&lt;/p&gt;
&lt;p&gt;如果用if判断，多个等待线程在满足if条件时都会被唤醒(虚假的)，但实际上条件并不满足，生产者生产出来的消费品已经被第一个线程消费了。
这就是我们使用while去做判断而不是使用if的原因：因为等待在条件变量上的线程被唤醒有可能不是因为条件满足而是由于虚假唤醒。
所以，我们需要对条件变量的状态进行不断检查直到其满足条件，不仅要在pthread_cond_wait前检查条件是否成立，在pthread_cond_wait之后也要检查。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while ( isCondition()) {
    waitForAConfition(...);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;慎用threadlocal&#34;&gt;慎用ThreadLocal&lt;/h2&gt;
&lt;p&gt;慎用ThreadLocal，这是 Java 提供的一种保存线程私有信息的机制，
因为其在整个线程生命周期内有效，所以可以方便地在一个线程关联的不同业务模块之间传递信息，比如事务 ID、Cookie 等上下文相关信息。&lt;/p&gt;
&lt;p&gt;它的实现结构，可以参考源码，数据存储于线程相关的 ThreadLocalMap，其内部条目是弱引用，如下面片段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static class ThreadLocalMap {
    static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
        /** The value associated with this ThreadLocal. */
        Object value;
        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
            super(k);
            value = v;
        }
    }
    // …
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 Key 为 null 时，该条目就变成“废弃条目”，相关“value”的回收，往往依赖于几个关键点，即 set、remove、rehash。&lt;/p&gt;
&lt;p&gt;下面是 set 的示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void set(ThreadLocal&amp;lt;?&amp;gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp;amp; (len-1);
    for (Entry e = tab[i];; …) {
        //…
        if (k == null) {
            // 替换废弃条目
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    tab[i] = new Entry(key, value);
    int sz = ++size;
    // 扫描并清理发现的废弃条目，并检查容量是否超限
    if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)
        rehash();// 清理废弃条目，如果仍然超限，则扩容（加倍）
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常弱引用都会和引用队列配合清理机制使用，但是 ThreadLocal 是个例外，它并没有这么做。&lt;/p&gt;
&lt;p&gt;这意味着，废弃项目的回收依赖于显式地触发，否则就要等待线程结束，进而回收相应ThreadLocalMap！
这就是很多 OOM 的来源，所以通常都会建议，应用一定要自己负责remove，并且不要和线程池配合，因为 worker 线程往往是不会退出的。&lt;/p&gt;
&lt;h2 id=&#34;jvm-启动-hello-world的线程分析&#34;&gt;JVM 启动 Hello World的线程分析&lt;/h2&gt;
&lt;p&gt;检测获得
Thread[Reference Handler,10,system]&lt;br&gt;
Thread[Finalizer,8,system]&lt;br&gt;
Thread[main,5,main]&lt;br&gt;
Thread[Signal Dispatcher,9,system]&lt;br&gt;
Hello World!&lt;/p&gt;
&lt;p&gt;其中：&lt;br&gt;
Reference Handler：处理引用对象本身的垃圾回收&lt;br&gt;
Finalizer：处理用户的Finalizer方法&lt;br&gt;
Signal Dispatcher：外部jvm命令的转发器&lt;br&gt;
在jdk6环境中,还有一个Attach Listener的线程是负责接收外部命令的，如jmap、jstack&lt;/p&gt;
&lt;h2 id=&#34;什么情况下-java-程序会产生死锁如何定位修复&#34;&gt;什么情况下 Java 程序会产生死锁？如何定位、修复？&lt;/h2&gt;
&lt;p&gt;死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。
死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。
通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。&lt;/p&gt;
&lt;p&gt;定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。
如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。&lt;/p&gt;
&lt;p&gt;如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。
所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。&lt;/p&gt;
&lt;p&gt;基本上死锁的发生是因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥条件，类似 Java 中 Monitor 都是独占的，要么是我用，要么是你用。&lt;/li&gt;
&lt;li&gt;互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。&lt;/li&gt;
&lt;li&gt;循环依赖关系，两个或者多个个体之间出现了锁的链条环。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁；&lt;br&gt;
如果必须使用多个锁，尽量设计好锁的获取顺序（根据对象之间组合、调用的关系对比和组合，考虑可能调用时序）；&lt;br&gt;
使用带超时的方法，为程序带来更多可控性；&lt;br&gt;
业界也有一些其他方面的尝试，比如通过静态代码分析（如 FindBugs）去查找固定的模式，进而定位可能的死锁或者竞争情况&lt;/p&gt;
&lt;p&gt;死循环死锁可以认为是自旋锁死锁的一种，其他线程因为等待不到具体的信号提示。导致线程一直饥饿。&lt;br&gt;
这种情况下可以查看线程 cpu 使用情况，排查出使用 cpu 时间片最高的线程，再打出该线程的堆栈信息，排查代码。&lt;br&gt;
比如Linux上，可以使用top命令配合grep Java之类，找到忙的pid；然后，转换成16进制，就是jstack输出中的格式；再定位代码&lt;/p&gt;
&lt;h2 id=&#34;java-并发包提供了哪些并发工具类&#34;&gt;Java 并发包提供了哪些并发工具类？&lt;/h2&gt;
&lt;p&gt;我们通常所说的并发包也就是 java.util.concurrent 及其子包，集中了 Java 并发的各种基础工具类，具体主要包括几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Sempahore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。&lt;/li&gt;
&lt;li&gt;各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的ConcunrrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList 等。&lt;/li&gt;
&lt;li&gt;各种并发队列实现，如各种 BlockedQueue 实现，比较典型的 ArrayBlockingQueue、SynchorousQueue 或针对特定场景的 PriorityBlockingQueue 等。&lt;/li&gt;
&lt;li&gt;强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CountDownLatch，允许一个或多个线程等待某些操作完成。&lt;br&gt;
CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障。&lt;br&gt;
Semaphore，Java 版本的信号量实现。&lt;/p&gt;
&lt;p&gt;两个应用并发工具的场景:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求熔断器，使用 Semaphore 熔断某些请求线程，待系统恢复以后再逐步释放信号量。&lt;/li&gt;
&lt;li&gt;Worker 搜索停止标志。使用 countdownlatch 标记 Worker 找到的结果个数，达到结果后其他线程不再继续执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Java 并发类库还提供了Phaser，功能与 CountDownLatch 很接近，但是它允许线程动态地注册到 Phaser 上面，而 CountDownLatch 显然是不能动态设置的。
Phaser 的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动。&lt;/p&gt;
&lt;p&gt;并发包里提供的线程安全 Map、List 和 Set，总体上种类和结构还是比较简单的。&lt;br&gt;
如果我们的应用侧重于 Map 放入或者获取的速度，而不在乎顺序，大多推荐使用 ConcurrentHashMap，
反之则使用ConcurrentSkipListMap；如果我们需要对大量数据进行非常频繁地修改，ConcurrentSkipListMap 也可能表现出优势。&lt;/p&gt;
&lt;p&gt;关于两个 CopyOnWrite 容器，其实 CopyOnWriteArraySet 是通过包装了CopyOnWriteArrayList 来实现的
首先，CopyOnWrite 到底是什么意思呢？它的原理是，任何修改操作，如 add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add (E e){
    synchronized (lock) {
        Object[] elements = getArray();
        int len = elements.length;
        // 拷贝
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        // 替换
        setArray(newElements);
        return true;
    }
}
final void setArray (Object[]a){
    array = a;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;并发包中的-concurrentlinkedqueue-和-linkedblockingqueue-有什么区别&#34;&gt;并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue 内部则是基于锁，并提供了 BlockingQueue 的等待性方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;java.util.concurrent 包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为 Concurrent、CopyOnWrite和 Blocking* 等三类，同样是线程安全容，可以简单认为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。&lt;/li&gt;
&lt;li&gt;Concurrent 往往提供了较低的遍历一致性（弱一致性）。例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。size 等操作准确性是有限的。读取的性能具有一定的不确定性。&lt;/li&gt;
&lt;li&gt;与弱一致性对应的，就是我介绍过的同步容器常见的行为“fast-fail”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;哪些队列是有界的哪些是无界的&#34;&gt;哪些队列是有界的，哪些是无界的？&lt;/h2&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/Queue.png&#34; data-size=&#34;901x359&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/Queue_hu23ab40b4f6d1bf3358004b991a37e2e0_49974_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/Queue_hu23ab40b4f6d1bf3358004b991a37e2e0_49974_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/Queue.png&#34; width=&#34;901&#34; height=&#34;359&#34; loading=&#34;lazy&#34;
				alt=&#34;&amp;nbsp;&#34;&gt;
		&lt;/a&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们可以从不同的角度进行分类，从基本的数据结构的角度分析，有两个特别的Deque实现，ConcurrentLinkedDeque 和 LinkedBlockingDeque。Deque 的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尾部插入时需要的addLast(e)、offerLast(e)。&lt;/li&gt;
&lt;li&gt;尾部删除所需要的removeLast()、pollLast()。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从行为特征来看，绝大部分 Queue 都是实现了 BlockingQueue 接口。
在常规队列操作基础上，Blocking 意味着其提供了特定的等待性操作，获取时（take）等待元素进队，或者插入时（put）等待队列出现空位。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 获取并移除队列头结点，如果必要，其会等待直到队列出现元素
…
*/
E take() throws InterruptedException;
/**
* 插入元素，如果队列已满，则等待直到队列出现空闲空间
…
*/
void put(E e) throws InterruptedException;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一个 BlockingQueue 经常被考察的点，就是是否有界（Bounded、Unbounded），这一点也往往会影响我们在应用开发中的选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ArrayBlockingQueue 是最典型的的有界队列，其内部以 final 的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建 ArrayBlockingQueue 时，都要指定容量，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ArrayBlockingQueue(int capacity, boolean fair)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LinkedBlockingQueue，容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为Integer.MAX_VALUE，成为了无界队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SynchronousQueue，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PriorityBlockingQueue 是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DelayedQueue 和 LinkedTransferQueue 同样是无边界的队列。对于无边界的队列，有一个自然的结果，就是 put 操作永远也不会发生其他 BlockingQueue 的那种等待情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分析不同队列的底层实现，BlockingQueue 基本都是基于锁实现，一起来看看典型的LinkedBlockingQueue。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/** Lock held by take, poll, etc */
private final ReentrantLock takeLock = new ReentrantLock();

/** Wait queue for waiting takes */
private final Condition notEmpty = takeLock.newCondition();

/** Lock held by put, offer, etc */
private final ReentrantLock putLock = new ReentrantLock();

/** Wait queue for waiting puts */
private final Condition notFull = putLock.newCondition();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArrayBlockingQueue，其条件变量与 LinkedBlockingQueue 版本的实现是有区别的，notEmpty、notFull都是同一个再入锁的条件变量，
而 LinkedBlockingQueue 则改进了锁操作的粒度，头、尾操作使用不同的锁，所以在通用场景下，它的吞吐量相对要更好一些。&lt;/p&gt;
&lt;p&gt;LinkedBlockingQueue 的 take 方法与 ArrayBlockingQueue 中的实现，也是有不同的，由于其内部结构是链表，需要自己维护元素数量值。&lt;/p&gt;
&lt;p&gt;类似 ConcurrentLinkedQueue 等，则是基于 CAS 的无锁技术，不需要在每个操作时使用锁，所以扩展性表现要更加优异。&lt;/p&gt;
&lt;p&gt;相对比较另类的 SynchronousQueue，在 Java 6 中，其实现发生了非常大的变化，利用 CAS
替换掉了原本基于锁的逻辑，同步开销比较小。它是 Executors.newCachedThreadPool() 的
默认队列。&lt;/p&gt;
&lt;h2 id=&#34;队列使用场景与典型用例&#34;&gt;队列使用场景与典型用例&lt;/h2&gt;
&lt;p&gt;在实际开发中，我提到过 Queue 被广泛使用在生产者 - 消费者场景，比如利用BlockingQueue 来实现，由于其提供的等待机制，我们可以少操心很多协调工作。&lt;/p&gt;
&lt;p&gt;在日常的应用开发中，如何进行选择呢？&lt;br&gt;
以 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue 为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑应用场景中对队列边界的要求。ArrayBlockingQueue 是有明确的容量限制的，而LinkedBlockingQueue 则取决于我们是否在创建时指定，SynchronousQueue 则干脆不能缓存任何元素。&lt;/li&gt;
&lt;li&gt;从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。&lt;/li&gt;
&lt;li&gt;通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。&lt;/li&gt;
&lt;li&gt;ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。&lt;/li&gt;
&lt;li&gt;如果我们需要实现的是两个线程之间接力性（handoff）的场景，可选择 CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。&lt;/li&gt;
&lt;li&gt;可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java-并发类库提供的线程池有哪几种-分别有什么特点&#34;&gt;Java 并发类库提供的线程池有哪几种？ 分别有什么特点？&lt;/h2&gt;
&lt;p&gt;通常开发者都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。&lt;/p&gt;
&lt;p&gt;Executors 目前提供了 5 种不同的线程池创建配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。&lt;/li&gt;
&lt;li&gt;newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。&lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor()，它创建的是个 ScheduledExecutorService，也就是可以进行定时或周期性的工作调度。工作线程数目被限制为 1，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool(int corePoolSize)，同样是 ScheduledExecutorService，区别在于它会保持 corePoolSize 个工作线程。&lt;/li&gt;
&lt;li&gt;newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/Executor.png&#34; data-size=&#34;1085x630&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/Executor_hu2355051128c0c140b2646d5910e7b461_63411_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/Executor_hu2355051128c0c140b2646d5910e7b461_63411_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/Executor.png&#34; width=&#34;1085&#34; height=&#34;630&#34; loading=&#34;lazy&#34;
				alt=&#34;&amp;nbsp;&#34;&gt;
		&lt;/a&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Executor 是一个基础的接口，其初衷是将任务提交和任务执行细节解耦，这一点可以体会其定义的唯一方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void execute(Runnable command);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ExecutorService 则更加完善，不仅提供 service 的管理功能，比如 shutdown 等方法，也提供了更加全面的提交任务机制，如返回Future而不是 void 的 submit 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，这个例子输入的可是Callable，它解决了 Runnable 无法返回结果的困扰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 标准类库提供了几种基础实现，比如ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool。这些线程池的设计特点在于其高度的可调节性和灵活性，以尽量满足复杂多变的实际应用场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Executors 则从简化使用的角度，为我们提供了各种方便的静态工厂方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;threadpoolexecutor&#34;&gt;ThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/ThreadPoolExecutor.png&#34; data-size=&#34;1134x468&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/ThreadPoolExecutor_hu49dfa4654d3ab09a8df8d3a18fc47e93_102891_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/ThreadPoolExecutor_hu49dfa4654d3ab09a8df8d3a18fc47e93_102891_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/ThreadPoolExecutor.png&#34; width=&#34;1134&#34; height=&#34;468&#34; loading=&#34;lazy&#34;
				alt=&#34;&amp;nbsp;&#34;&gt;
		&lt;/a&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作队列负责存储用户提交的各个任务，这个工作队列，可以是容量为 0 的 SynchronousQueue（使用 newCachedThreadPool），也可以是像固定大小线程池（newFixedThreadPool）那样使用 LinkedBlockingQueue
&lt;pre&gt;&lt;code&gt;private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;内部的“线程池”，这是指保持工作线程的集合，线程池需要在运行过程中管理线程创建、销毁。例如，对于带缓存的线程池，当任务压力较大时，线程池会创建新的工作线程；当业务压力退去，线程池会在闲置一段时间（默认 60 秒）后结束线程。
&lt;pre&gt;&lt;code&gt;private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;ThreadFactory 提供上面所需要的创建线程逻辑。&lt;/li&gt;
&lt;li&gt;如果任务提交时被拒绝，比如线程池已经处于 SHUTDOWN 状态，需要为其提供处理逻辑，Java 标准库提供了类似ThreadPoolExecutor.AbortPolicy等默认实现，也可以按照实际需求自定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程池的几个基本组成部分，一起都体现在线程池的构造函数中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目（除非设置了allowCoreThreadTimeOut）。对于不同的线程池，这个值可能会有很大区别，比如newFixedThreadPool 会将其设置为 nThreads，而对于 newCachedThreadPool 则是为0。&lt;/li&gt;
&lt;li&gt;maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数。同样进行对比，对于 newFixedThreadPool，当然就是 nThreads，因为其要求是固定大小，而newCachedThreadPool 则是 Integer.MAX_VALUE。&lt;/li&gt;
&lt;li&gt;keepAliveTime 和 TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。&lt;/li&gt;
&lt;li&gt;workQueue，工作队列，必须是 BlockingQueue。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过配置不同的参数，我们就可以创建出行为大相径庭的线程池，这就是线程池高度灵活性的基础。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
        int maximumPoolSize,
        long keepAliveTime,
        TimeUnit unit,
        BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
        ThreadFactory threadFactory,
        RejectedExecutionHandler handler)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;线程池实践&#34;&gt;线程池实践&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;避免任务堆积。newFixedThreadPool 是创建指定数目的线程，但是其工作队列是无界的，如果工作线程数目太少，导致处理跟不上入队的速度，这就很有可能占用大量统内存，甚至是出现 OOM。诊断时，你可以使用 jmap 之类的工具，查看是否有大量的任务对象入队。&lt;/li&gt;
&lt;li&gt;避免过度扩展线程。我们通常在处理大量短时任务时，使用缓存的线程池，比如在最新的HTTP/2 client API 中，目前的默认实现就是如此。我们在创建线程池的时候，并不能准确预计任务压力有多大、数据特征是什么样子（大部分请求是 1K 、100K 还是 1M 以上？），所以很难明确设定一个线程数目。&lt;/li&gt;
&lt;li&gt;如果线程数目不断增长（可以使用 jstack 等工具检查），也需要警惕另外一种可能性，就是线程泄漏，这种情况往往是因为任务逻辑有问题，导致工作线程迟迟不能被释放。建议你排查下线程栈，很有可能多个线程都是卡在近似的代码处。&lt;/li&gt;
&lt;li&gt;避免死锁等同步问题，对于死锁的场景和排查&lt;/li&gt;
&lt;li&gt;尽量避免在使用线程池时操作 ThreadLocal。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程池大小的选择策略&#34;&gt;线程池大小的选择策略&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果我们的任务主要是进行计算，那么就意味着 CPU 的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照 CPU 核的数目 N 或者 N+1。&lt;/li&gt;
&lt;li&gt;如果是需要较多等待的任务，例如 I/O 操作比较多，可以参考 Brain Goetz 推荐的计算方法：线程数 = CPU 核数 × （1 + 平均等待时间 / 平均工作时间）&lt;/li&gt;
&lt;li&gt;上面是仅仅考虑了 CPU 等限制，实际还可能受各种系统资源（文件句柄、内存）限制影响&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;atomicinteger-底层实现原理是什么如何在自己的代码中应用cas-操作&#34;&gt;AtomicInteger 底层实现原理是什么？如何在自己的代码中应用CAS 操作？&lt;/h2&gt;
&lt;p&gt;AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术&lt;/p&gt;
&lt;p&gt;CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。
如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。&lt;/p&gt;
&lt;p&gt;从 AtomicInteger 的内部属性可以看出，它依赖于 Unsafe 提供的一些底层能力，进行底层操作；以 volatile 的 value 字段，记录数值，以保证可见性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();
private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &amp;quot;value&amp;quot;);
private volatile int value;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的原子操作细节，可以参考任意一个原子更新方法，比如下面的 getAndIncrement。Unsafe 会利用 value 字段的内存地址偏移，直接完成操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final int getAndIncrement() {
    return U.getAndAddInt(this, VALUE, 1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 getAndIncrement 需要返归数值，所以需要添加失败重试逻辑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而类似 compareAndSet 这种返回 boolean 类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final boolean compareAndSet(int expectedValue, int newValue)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CAS 是 Java 并发中所谓 lock-free 机制的基础。&lt;/p&gt;
&lt;p&gt;Java 9 中移除了 Unsafe.moniterEnter()/moniterExit()，导致无法平滑升级到新的 JDK 版本。
目前 Java 提供了两种公共 API，可以实现这种 CAS 操作，比如使用 java.util.concurrent.atomic.AtomicLongFieldUpdater，它是基于反射机制创建，我们需要保证类型和字段名称正确。&lt;/p&gt;
&lt;p&gt;Atomic 包提供了最常用的原子性数据类型，甚至是引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选。&lt;br&gt;
atomic 包提供的LongAdder，在高度竞争环境下，可能就是比 AtomicLong 更佳的选择，尽管它的本质是空间换时间。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java面试题</title>
        <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
        <pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
        <description>&lt;h2 id=&#34;java平台理解及java是解释执行吗&#34;&gt;Java平台理解及Java是解释执行吗？&lt;/h2&gt;
&lt;p&gt;首先Java是一种面向对象的语言，本身具有两个特性：一个是跨平台能力（一次编写，到处运行），屏蔽了操作系统和硬件的细节；
第二个就是垃圾自动回收机制（GC）。&lt;/p&gt;
&lt;p&gt;我们日常接触到的jre（Java runtime environment）和jdk（Java development kit），
jre是Java运行时环境，包含了JVM和java类库；
jdk则是Java开发工具，里面提供了许多开发工具如；编译器(javac)、诊断和监控(jconsole)工具等。&lt;/p&gt;
&lt;p&gt;java生态：spring，spark，elasticsearch，maven&lt;/p&gt;
&lt;p&gt;不完全正确，Java是通过对源文件进行编译成字节码文件（.class），然后jvm（Java虚拟机）对字节码文件逐条进行解释运行。
但是往往有一部分热点代码（hot spot）会占有大部分时间解释，所以Java中会有jit（Just-In-Time）。即时编译器将该部分直接编译成机器代码直接运行，大大提高效率。
这部分热点代码就是编译执行了而不是解释执行。&lt;/p&gt;
&lt;p&gt;在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。
主流 Java 版本中，如 JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。
通常运行在 server 模式的 JVM，会进行上万次调用以收集足够的信息进行高效的编译，client 模式这个门限是 1500 次。
Oracle Hotspot JVM 内置了两个不同的 JIT compiler，
C1 对应前面说的 client 模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用；
C2 对应 server 模式，它的优化是为长时间运行的服务器端应用设计的，默认是采用所谓的分层编译（TieredCompilation）。&lt;/p&gt;
&lt;p&gt;除了我们日常最常见的 Java 使用模式，其实还有一种新的编译方式，
即所谓的 AOT（Aheadof-Time Compilation），直接将字节码编译成机器代码，
这样就避免了 JIT 预热等各方面的开销，
比如 Oracle JDK 9 就引入了实验性的 AOT 特性，并且增加了新的 jaotc 工具。&lt;/p&gt;
&lt;h2 id=&#34;java创建对象的方式&#34;&gt;java创建对象的方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用new关键字创建对象&lt;/li&gt;
&lt;li&gt;使用Class类的newInstance方法(反射机制)&lt;/li&gt;
&lt;li&gt;使用Constructor类的newInstance方法(反射机制)&lt;/li&gt;
&lt;li&gt;使用Clone方法创建对象&lt;/li&gt;
&lt;li&gt;使用(反)序列化机制创建对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;exception和error有什么区别&#34;&gt;Exception和Error有什么区别&lt;/h2&gt;
&lt;p&gt;Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。&lt;/p&gt;
&lt;p&gt;Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。&lt;/p&gt;
&lt;p&gt;Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM自身）处于非正常的、不可恢复状态。
既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。&lt;/p&gt;
&lt;p&gt;Exception 又分为可检查（checked）异常和不检查（unchecked）异常。
可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。
不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。&lt;/p&gt;
&lt;p&gt;扩展&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NoClassDefFoundError 和 ClassNotFoundException 有什么区别，这也是个经典的入门题目。&lt;/li&gt;
&lt;li&gt;理解 Java 语言中操作 Throwable 的元素和实践。掌握最基本的语法是必须的，如 trycatch-finally 块，throw、throws 关键字等。&lt;/li&gt;
&lt;li&gt;与此同时，也要懂得如何处理典型场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;异常处理原则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常。进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。&lt;/li&gt;
&lt;li&gt;不要生吞（swallow）异常&lt;/li&gt;
&lt;li&gt;try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码。&lt;/li&gt;
&lt;li&gt;请勿在try代码块中调用return、break或continue语句。万一无法避免，一定要确保finally的存在不会改变函数的返回值（不要在finally代码块中处理返回值）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;noclassdeffounderror-和-classnotfoundexception-有什么区别&#34;&gt;NoClassDefFoundError 和 ClassNotFoundException 有什么区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;ClassNotFoundException&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;NoClassDefFoundError&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;从java.lang.Exception继承，是一个Exception类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;从java.lang.Error继承，是一个Error类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当动态加载Class的时候找不到类会抛出该异常&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当编译成功以后执行过程中Class找不到导致抛出该错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一般在执行Class.forName()、ClassLoader.loadClass()或ClassLoader.findSystemClass()的时候抛出&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由JVM的运行时系统抛出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;finalfinally-finalize有什么不同&#34;&gt;final、finally、 finalize有什么不同&lt;/h2&gt;
&lt;p&gt;final 可以用来修饰类（不可继承扩展）、方法（不能重写）、变量（字段值不能修改。&lt;/p&gt;
&lt;p&gt;finally 异常处理机制的关键字，表示最后执⾏行。来进行类似关闭 JDBC 连接、保证 unlock 锁、释放资源等动作。&lt;/p&gt;
&lt;p&gt;finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。
finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为deprecated。
Java 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。&lt;/p&gt;
&lt;h2 id=&#34;不可变-immutable&#34;&gt;不可变 Immutable&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将 class 自身声明为 final，这样别人就不能扩展来绕过限制了。&lt;/li&gt;
&lt;li&gt;将所有成员变量定义为 private 和 final，并且不要实现 setter 方法。&lt;/li&gt;
&lt;li&gt;通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。&lt;/li&gt;
&lt;li&gt;如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，使用 copy-on-write原则，创建私有的 copy。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;stringstringbufferstringbuilder-有什么区别&#34;&gt;String、StringBuffer、StringBuilder 有什么区别？&lt;/h2&gt;
&lt;p&gt;String是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性类似拼接、裁剪字符串等动作，都会产生新的 String 对象。&lt;/p&gt;
&lt;p&gt;原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。&lt;/p&gt;
&lt;p&gt;StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是StringBuilder。&lt;/p&gt;
&lt;p&gt;为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。&lt;br&gt;
另外，这个内部数组应该创建成多大的呢？如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。
目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。
我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。
扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy&lt;/p&gt;
&lt;h4 id=&#34;字符串缓存&#34;&gt;字符串缓存&lt;/h4&gt;
&lt;p&gt;String 在 Java 6 以后提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。
在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。
一般来说，JVM 会将所有的类似“abc”这样的文本字符串，或者字符串常量之类缓存起来。&lt;/p&gt;
&lt;p&gt;看起来很不错是吧？但实际情况估计会让你大跌眼镜。一般使用 Java 6 这种历史版本，并不推荐大量使用 intern，为什么呢？
魔鬼存在于细节中，被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。
所以，如果使用不当，OOM 就会光顾。&lt;/p&gt;
&lt;p&gt;在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在JDK 8 中被 MetaSpace（元数据区）替代了。
而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用参数直接打印具体数字 &lt;code&gt;-XX:+PrintStringTableStatistics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;手动调整大小 &lt;code&gt;-XX:StringTableSize=N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Intern 是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；
另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。&lt;br&gt;
幸好在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。
它是通过将相同数据的字符串指向同一份数据来做到的，是 JVM 底层的改变，并不需要 Java 类库做什么修改。
这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用 G1 GC：&lt;br&gt;
&lt;code&gt;-XX:+UseStringDeduplication&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;动态代理是基于什么原理&#34;&gt;动态代理是基于什么原理？&lt;/h2&gt;
&lt;p&gt;通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。&lt;/p&gt;
&lt;p&gt;Java 发射机制的常见应用：动态代理（AOP、RPC）、提供第三方开发者扩展能力（Servlet容器，JDBC连接）、第三方组件创建对象（DI）……&lt;/p&gt;
&lt;p&gt;动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，
比如用来包装 RPC 调用、面向切面的编程（AOP）。&lt;/p&gt;
&lt;p&gt;实现动态代理的方式很多，
比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。
还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。&lt;/p&gt;
&lt;p&gt;JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。新版本也开始结合ASM机制。&lt;br&gt;
cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。&lt;/p&gt;
&lt;p&gt;JDK Proxy 的优势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。&lt;/li&gt;
&lt;li&gt;平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。&lt;/li&gt;
&lt;li&gt;代码实现简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于类似 cglib 框架的优势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。&lt;/li&gt;
&lt;li&gt;只操作我们关心的类，而不必为其他相关类增加工作量。&lt;/li&gt;
&lt;li&gt;高性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有哪些方法可以在运行时动态生成一个-java-类&#34;&gt;有哪些方法可以在运行时动态生成一个 Java 类&lt;/h2&gt;
&lt;p&gt;直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。本质上还是在当前程序进程之外编译的。&lt;/p&gt;
&lt;p&gt;使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能。&lt;/p&gt;
&lt;p&gt;直接生成相应的字节码，然后交给类加载器去加载。通常我们可以利用 Java 字节码操纵工具和类库 ASM、Javassist、cglib 等 来实现。&lt;/p&gt;
&lt;h2 id=&#34;字节码和类加载到底是怎么无缝进行转换的发生在整个类加载过程的哪一步&#34;&gt;字节码和类加载到底是怎么无缝进行转换的？发生在整个类加载过程的哪一步？&lt;/h2&gt;
&lt;p&gt;类从字节码到 Class 对象的转换，在类加载过程中，这一步是通过下面的方法提供的功能，或者 defineClass 的其他本地对等实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//只选取了最基础的两个典型的 defineClass 实现
protected final Class&amp;lt;?&amp;gt; defineClass(String name, byte[] b, int off, int len,
            ProtectionDomain protectionDomain)
protected final Class&amp;lt;?&amp;gt; defineClass(String name, java.nio.ByteBuffer b,
            ProtectionDomain protectionDomain)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只要能够生成出规范的字节码，不管是作为 byte 数组的形式，还是放到 ByteBuffer里，都可以平滑地完成字节码到 Java 对象的转换过程。&lt;br&gt;
JDK 提供的 defineClass 方法，最终都是本地代码实现的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private native Class&amp;lt;?&amp;gt; defineClass0(String name, byte[] b, int off, int len,
                                     ProtectionDomain pd);

private native Class&amp;lt;?&amp;gt; defineClass1(String name, byte[] b, int off, int len,
                                     ProtectionDomain pd, String source);

private native Class&amp;lt;?&amp;gt; defineClass2(String name, java.nio.ByteBuffer b,
                                     int off, int len, ProtectionDomain pd,
                                     String source);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;相关的字节码操纵逻辑&#34;&gt;相关的字节码操纵逻辑&lt;/h4&gt;
&lt;p&gt;JDK dynamic proxy （1.8） 的实现代码，对应逻辑是实现在 Proxy类中的 ProxyClassFactory 这个静态内部类，
通过 ProxyGenerator 生成字节码，并以 byte 数组的形式保存，然后调用 本地 的 defineClass0 入口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
 * Generate the specified proxy class.
 */
byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
    proxyName, interfaces, accessFlags);
try {
    return defineClass0(loader, proxyName,
                        proxyClassFile, 0, proxyClassFile.length);
} catch (ClassFormatError e) {
    /*
     * A ClassFormatError here means that (barring bugs in the
     * proxy class generation code) there was some other
     * invalid aspect of the arguments supplied to the proxy
     * class creation (such as virtual machine limitations
     * exceeded).
     */
    throw new IllegalArgumentException(e.toString());
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JDK 内部动态代理的逻辑，可以参考java.lang.reflect.ProxyGenerator的内部实现。
可以认为这是种另类的字节码操纵技术，这种实现方式的好处是没有太多依赖关系，但是前提是需要懂各种JVM 指令，知道怎么处理那些偏移地址等，实际门槛非常高，所以并不适合大多数的普通开发场景。&lt;/p&gt;
&lt;p&gt;Java 社区专家提供了各种从底层到更高抽象水平的字节码操作类库。JDK 内部也集成了 ASM 类库。&lt;/p&gt;
&lt;h2 id=&#34;如何利用字节码操纵技术实现基本的动态代理逻辑&#34;&gt;如何利用字节码操纵技术，实现基本的动态代理逻辑？&lt;/h2&gt;
&lt;p&gt;对于一个普通的 Java 动态代理，其实现过程可以简化成为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供一个基础的接口，作为被调用类型（com.mycorp.HelloImpl）和代理类之间的统一入口，如 com.mycorp.Hello。&lt;/li&gt;
&lt;li&gt;实现InvocationHandler，对代理对象方法的调用，会被分派到其 invoke 方法来真正实现动作。&lt;/li&gt;
&lt;li&gt;通过 Proxy 类，调用其 newProxyInstance 方法，生成一个实现了相应基础接口的代理类实例，可以看下面的方法签名。
&lt;pre&gt;&lt;code&gt;public static Object newProxyInstance(ClassLoader loader,
Class&amp;lt;?&amp;gt;[] interfaces,
InvocationHandler h)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用 ASM 实现的简要过程:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
cw.visit(V1_8, // 指定 Java 版本
        ACC_PUBLIC, // 说明是 public 类型
        &amp;quot;com/mycorp/HelloProxy&amp;quot;, // 指定包和类的名称
        null, // 签名，null 表示不是泛型
        &amp;quot;java/lang/Object&amp;quot;, // 指定父类
        new String[]{ &amp;quot;com/mycorp/Hello&amp;quot; }); // 指定需要实现的接口

MethodVisitor mv = cw.visitMethod(
                ACC_PUBLIC, // 声明公共方法
                &amp;quot;sayHello&amp;quot;, // 方法名称
                &amp;quot;()Ljava/lang/Object;&amp;quot;, // 描述符
                null, // 签名，null 表示不是泛型
                null); // 可能抛出的异常，如果有，则指定字符串数组
mv.visitCode();
// 省略代码逻辑实现细节
cw.visitEnd(); // 结束类字节码生成
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不同的 visitX 方法提供了创建类型，创建各种方法等逻辑。ASM API，广泛的使用了Visitor模式。
按照前面的分析，字节码操作最后大都应该是生成 byte 数组，ClassWriter 提供了一个简便的方法。&lt;code&gt;cw.toByteArray();&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;除了动态代理字节码操纵技术还有那些应用场景&#34;&gt;除了动态代理，字节码操纵技术还有那些应用场景？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;各种 Mock 框架&lt;/li&gt;
&lt;li&gt;ORM 框架&lt;/li&gt;
&lt;li&gt;IOC 容器&lt;/li&gt;
&lt;li&gt;部分 Profiler 工具，或者运行时诊断工具等&lt;/li&gt;
&lt;li&gt;生成形式化代码的工具&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;假如我们有这样一个需求需要添加某个功能例如对某类型资源如网络通信的消耗进行统计重点要求是不开启时必须是零开销而不是低开销&#34;&gt;假如我们有这样一个需求，需要添加某个功能，例如对某类型资源如网络通信的消耗进行统计，重点要求是，不开启时必须是零开销，而不是低开销&lt;/h2&gt;
&lt;p&gt;将资源消耗的这个实例，用动态代理的方式创建这个实例动态代理对象，在动态代理的invoke中添加新的需求。
开始使用代理对象，不开启则使用原来的方法，因为动态代理是在运行时创建。所以是零消耗。&lt;/p&gt;
&lt;h2 id=&#34;设计模式应用例子&#34;&gt;设计模式应用例子&lt;/h2&gt;
&lt;p&gt;装饰模式：BufferedInputStream 经过包装，为输入流过程增加缓存，类似这种装饰器还可以多次嵌套，不断地增加不同层次的功能。
&lt;code&gt;public BufferedInputStream(InputStream in)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;构建器模式：JDK 最新版本中 HTTP/2 Client API，下面这个创建 HttpRequest的过程就是典型的构建器模式（Builder），
通常会被实现成fluent 风格的 API，也有人叫它方法链。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HttpRequest request = HttpRequest.newBuilder(new URI(uri))
                        .header(headerAlice, valueAlice)
                        .headers(headerBob, value1Bob,
                        headerCarl, valueCarl,
                       headerBob, value2Bob)
                        .GET()
                        .build();
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Mybatis之面试篇</title>
        <link>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E9%9D%A2%E8%AF%95%E7%AF%87/</link>
        <pubDate>Sun, 09 Feb 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E9%9D%A2%E8%AF%95%E7%AF%87/</guid>
        <description>&lt;h2 id=&#34;和的区别&#34;&gt;#{}和${}的区别？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;${}&lt;/code&gt;是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换。&lt;br&gt;
&lt;code&gt;#{}&lt;/code&gt;是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值&lt;/p&gt;
&lt;h2 id=&#34;最佳实践中通常一个xml映射文件都会写一个dao接口与之对应请问这个dao接口的工作原理是什么dao接口里的方法参数不同时方法能重载吗&#34;&gt;最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？&lt;/h2&gt;
&lt;p&gt;Dao接口的全限定名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中MappedStatement的id值；接口方法内的参数，就是传递给sql的参数。&lt;/p&gt;
&lt;p&gt;Mapper接口是没有实现类的，当调用接口方法时，全限定名+方法名作为key值，可唯一定位一个MappedStatement。&lt;/p&gt;
&lt;p&gt;Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。&lt;/p&gt;
&lt;p&gt;Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。&lt;/p&gt;
&lt;h2 id=&#34;mybatis是如何分页的&#34;&gt;mybatis是如何分页的&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;SQL带参直接分页&lt;/li&gt;
&lt;li&gt;使用拦截器分页&lt;br&gt;
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。&lt;/li&gt;
&lt;li&gt;RowBounds分页&lt;br&gt;
Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。数据量小时，RowBounds不失为一种好办法。但是数据量大时，实现拦截器就很有必要了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mybatis是如何将sql执行结果封装为目标对象并返回的都有哪些映射形式&#34;&gt;Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用标签，逐一定义列名和对象属性名之间的映射关系。&lt;/li&gt;
&lt;li&gt;使用sql列的别名功能，将列别名书（不区分大小写）写为对象属性名，比如TNAME AS NAME&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mybatis是否支持延迟加载如果支持它的实现原理是什么&#34;&gt;Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？&lt;/h2&gt;
&lt;p&gt;Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。&lt;/p&gt;
&lt;p&gt;原理：使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。&lt;/p&gt;
&lt;h2 id=&#34;mybatis都有哪些executor执行器它们之间的区别是什么&#34;&gt;Mybatis都有哪些Executor执行器？它们之间的区别是什么？&lt;/h2&gt;
&lt;p&gt;Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。&lt;/p&gt;
&lt;p&gt;SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。&lt;/p&gt;
&lt;p&gt;ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。&lt;/p&gt;
&lt;p&gt;BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。&lt;/p&gt;
&lt;p&gt;作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。&lt;/p&gt;
&lt;h2 id=&#34;mybatis是否可以映射enum枚举类&#34;&gt;Mybatis是否可以映射Enum枚举类&lt;/h2&gt;
&lt;p&gt;Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java开发之命名规范</title>
        <link>https://ianeiu.github.io/p/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</link>
        <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</guid>
        <description>&lt;p&gt;原文： &lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/q_C9daCZTq1SR0zwkrwyag&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;编码5分钟，命名2小时？史上最全的Java命名规范参考！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;一java中的命名规范&#34;&gt;一、Java中的命名规范&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类型(名)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;约束&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;项目&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;全部小写&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多个单词用中划线分隔‘-’	spring-cloud&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;全部小写&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;com.alibaba.fastjson&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;类&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单词首字母大写&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Feature,FieldDeserializer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;变量&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;首字母小写多个单词组成时，除首个单词其他单词首字母都要大写&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;password, userName&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;常量&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;全部大写，多个单词，用&#39;_&amp;lsquo;分隔&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CACHEEXPIREDTIME&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同变量&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;read(), getById(Long id)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;二包命名&#34;&gt;二、包命名&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;前缀&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;indi或onem&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;indi.发起者名.项目名.模块名.……&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;个体项目&lt;!-- raw HTML omitted --&gt;个人发起，但非自己独自完成&lt;!-- raw HTML omitted --&gt;可公开或私有项目，copyright主要属于发起者。&lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pers&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pers.个人名.项目名.模块名.……&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;个人项目&lt;!-- raw HTML omitted --&gt;指个人发起，独自完成，&lt;!-- raw HTML omitted --&gt;可分享的项目,copyright主要属于个人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;priv&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;priv.个人名.项目名.模块名.……&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;私有项目，指个人发起，独自完成&lt;!-- raw HTML omitted --&gt;非公开的私人使用的项目，copyright属于个人。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;team&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;team.团队名.项目名.模块名.……&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;团队项目，指由团队发起&lt;!-- raw HTML omitted --&gt;并由该团队开发的项目,copyright属于该团队所有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;顶级域名&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;com.公司名.项目名.模块名.……&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;公司项目，copyright由项目发起的公司所有&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;三类命名&#34;&gt;三、类命名&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;属性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;约束&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;抽象&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Abstract 或 Base 开头&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;BaseUserService&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;枚举&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Enum 作为后缀&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OSType&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;工具&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Utils作为后缀&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;StringUtils&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;异常&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Exception结尾&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RuntimeException&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;接口实现&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;接口名+ Impl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UserServiceImpl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;领域模型相&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;/DO/DTO/VO/DAO&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;正例：UserDAO 反例：UserDao&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设计模式相关&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Builder，Factory等&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当使用到设计模式时要使用对应的设计模式作为后缀，如ThreadFactory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;处理特定功能&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Handler，Predicate，Validator&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示处理器，校验器，断言&lt;!-- raw HTML omitted --&gt;这些类工厂还有配套的方法名，如handle，predicate，validate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;测试&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Test后缀&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UserServiceTest，表示用来测试UserService类的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;MVC分层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Controller，Service，ServiceImpl，DAO后缀&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UserManageController，UserManageDAO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;四方法&#34;&gt;四、方法&lt;/h2&gt;
&lt;p&gt;注：pre- prefix前缀，suf- suffix后缀，alo-alone 单独使用&lt;/p&gt;
&lt;h4 id=&#34;41-返回真伪值的方法pre&#34;&gt;4.1 返回真伪值的方法（pre）&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;意义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;is&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对象是否符合期待的状态&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;isValid&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;can&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对象能否执行所期待的动作&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;canRemove&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;should&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;调用方执行某个命令或方法是好还是不好、应不应该，&lt;!-- raw HTML omitted --&gt;或者说推荐还是不推荐&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;shouldMigrate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;has&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对象是否持有所期待的数据和属性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;hasObservers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;needs&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;调用方是否需要执行某个命令或方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;needsMigrate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;42-用来检查的方法&#34;&gt;4.2 用来检查的方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;意义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ensure&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;检查是否为期待的状态，不是则抛出异常或返回error code&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ensureCapacity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;validate&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;检查是否为正确的状态，不是则抛出异常或返回error code&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;validateInputs&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;43-按需求才执行的方法&#34;&gt;4.3 按需求才执行的方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;位置&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;意义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;suf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;IfNeeded&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要的时候执行，不需要则什么都不做&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawIfNeeded&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;might&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;mightCreate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;try&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;尝试执行，失败时抛出异常，或是返回errorcode&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;tryCreate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;suf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OrDefault&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;尝试执行，失败时返回默认值&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;getOrDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;suf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OrElse&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;尝试执行，失败时返回，实际参数中指定的值&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;getOrElse&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;force&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;强制尝试执行，error抛出异常或是返回值&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;forceCreate, forceStop&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;44-异步相关方法&#34;&gt;4.4 异步相关方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;位置&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;意义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;blocking&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;线程阻塞方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;blockingGetUser&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;suf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;InBackground&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;执行在后台线程&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;doInBackground&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;suf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Async&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;异步方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sendAsync&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;suf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Sync&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同步方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sendSync&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;schedule&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Job和Task放入队列&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;schedule, scheduleJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;post&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;postJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;execute&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;执行异步或同步方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;execute,executeTask&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;start&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;star,startJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cancel&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;停止异步方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cancel,cancelJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;stop&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;stop,stopJob&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;45-回调方法&#34;&gt;4.5 回调方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;位置&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;意义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;on&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;事件发生时执行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;onCompleted&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;before&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;事件发生前执行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;beforeUpdate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;preUpdate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;will&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;willUpdate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;after&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;事件发生后执行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;afterUpdate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;post&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;postUpdate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;did&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;didUpdate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pre&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;should&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确认事件是否可以执行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;shouldUpdate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;46-操作对象生命周期的方法&#34;&gt;4.6 操作对象生命周期的方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;意义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;initialize&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;初始化或延迟初始化使用&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;initialize&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pause&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;暂停&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;onPause,pause&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;stop&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;停止&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;onStop,stop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;abandon&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;销毁的替代&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;abandon&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;destroy&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;destroy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dispose&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同上&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dispose&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;47-与集合操作相关的方法&#34;&gt;4.7 与集合操作相关的方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;意义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;contains&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是包含指定对象相同的对象&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;contains&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;add&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;添加&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;addJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;append&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;添加&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;appendJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;insert&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;插入到下标n&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;insertJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;put&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;添加与key对应的元素&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;putJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;remove&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;移除元素&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;removeJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;enqueue&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;添加到队列的最末位&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;enqueueJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dequeue&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;从队列中头部取出并移除&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dequeueJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;push&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;添加到栈头&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pushJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pop&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;从栈头取出并移除&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;popJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;peek&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;从栈头取出但不移除&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;peekJob&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;find&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;寻找符合条件的某物&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;findById&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;48-与数据相关的方法&#34;&gt;4.8 与数据相关的方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;意义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;create&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;新创建&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;createAccount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;new&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;新创建&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;newAccount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;从既有的某物新建或是从其他的数据新建&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fromConfig&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;转换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;toString&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;update&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;更新既有某物&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;updateAccount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;load&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;读取&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadAccount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fetch&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;远程读取&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fetchAccount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;delete&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;删除&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;deleteAccount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;remove&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;删除&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;removeAccount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;save&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保存&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;saveAccount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;store&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保存&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;storeAccount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commit&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保存&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commitChange&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;apply&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保存或应用&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;applyChange&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;clear&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;清除或是恢复到初始状态&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;clearAll&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reset&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;清除或是恢复到初始状态&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;resetAll&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;49-成对出现的动词&#34;&gt;4.9 成对出现的动词&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词/意义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单词/意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;get获取&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;set 设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;add 增加&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;remove 删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;create 创建&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;destory 移除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;start 启动&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;stop 停止&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;open 打开&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;close 关闭&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;read 读取&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;write 写入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;load 载入&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;save 保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;create 创建&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;destroy 销毁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;begin 开始&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;end 结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;backup 备份&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;restore 恢复&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;import 导入&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;export 导出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;split 分割&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;merge 合并&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;inject 注入&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;extract 提取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;attach 附着&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;detach 脱离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bind 绑定&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;separate 分离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;view 查看&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;browse 浏览&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;edit 编辑&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;modify 修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;select 选取&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;mark 标记&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;copy 复制&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;paste 粘贴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;undo 撤销&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redo 重做&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;insert 插入&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;delete 移除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;add 加入&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;append 添加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;clean 清理&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;clear 清除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index 索引&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sort 排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;find 查找&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;search 搜索&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;increase 增加&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;decrease 减少&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;play 播放&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pause 暂停&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;launch 启动&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;run 运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;compile 编译&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;execute 执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;debug 调试&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;trace 跟踪&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;observe 观察&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;listen 监听&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;build 构建&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;publish 发布&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;input 输入&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;output 输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;encode 编码&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;decode 解码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;encrypt 加密&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;decrypt 解密&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;compress 压缩&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;decompress 解压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pack 打包&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;unpack 解包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;parse 解析&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;emit 生成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connect 连接&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;disconnect 断开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;send 发送&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;receive 接收&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;download 下载&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;upload 上传&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;refresh 刷新&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;synchronize 同步&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;update 更新&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;revert 复原&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lock 锁定&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;unlock 解锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;check out 签出&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;check in 签入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;submit 提交&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commit 交付&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;push 推&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;pull 拉&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;expand 展开&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;collapse 折叠&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;begin 起始&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;end 结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;start 开始&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;finish 完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;enter 进入&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;exit 退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;abort 放弃&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;quit 离开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;obsolete 废弃&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;depreciate 废旧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;collect 收集&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;aggregate 聚集&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;五变量常量命名&#34;&gt;五，变量&amp;amp;常量命名&lt;/h2&gt;
&lt;h4 id=&#34;51-变量命名&#34;&gt;5.1 变量命名&lt;/h4&gt;
&lt;p&gt;变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 computedValues，index、变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。&lt;/p&gt;
&lt;p&gt;变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo中的布尔变量，都不要加is(数据库中的布尔字段全都要加 is_ 前缀)。&lt;/p&gt;
&lt;h4 id=&#34;52-常量命名&#34;&gt;5.2 常量命名&lt;/h4&gt;
&lt;p&gt;常量命名CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。那么什么是常量呢？&lt;/p&gt;
&lt;p&gt;常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，全局常量（public static final修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。&lt;/p&gt;
&lt;p&gt;常量一般都有自己的业务含义,不要害怕长度过长而进行省略或者缩写。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。&lt;/p&gt;
&lt;h4 id=&#34;通用命名规则&#34;&gt;通用命名规则&lt;/h4&gt;
&lt;p&gt;尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。正例：BeiJing， HangZhou 反例：validateCanShu&lt;/p&gt;
&lt;p&gt;命名过程中尽量不要出现特殊的字符，常量除外。&lt;/p&gt;
&lt;p&gt;尽量不要和jdk或者框架中已存在的类重名，也不能使用java中的关键字命名。&lt;/p&gt;
&lt;p&gt;妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。&lt;/p&gt;
&lt;h4 id=&#34;六代码注解&#34;&gt;六，代码注解&lt;/h4&gt;
&lt;h4 id=&#34;61-注解的原则&#34;&gt;6.1 注解的原则&lt;/h4&gt;
&lt;p&gt;好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。&lt;/p&gt;
&lt;p&gt;优雅的注解通常要满足三要素。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Nothing is strange 没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。&lt;/li&gt;
&lt;li&gt;Less is more 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。
&lt;pre&gt;&lt;code&gt;// 根据id获取信息【废话注解】
getMessageById(id)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Advance with the time 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;62-注解格式&#34;&gt;6.2 注解格式&lt;/h4&gt;
&lt;p&gt;注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。&lt;/p&gt;
&lt;p&gt;javadoc注解可以生成JavaAPI为外部用户提供有效的支持javadoc注解通常在使用IDEA或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。&lt;/p&gt;
&lt;p&gt;a. 包注解&lt;br&gt;
包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 落地也质量检测
 * 1. 用来解决什么问题
 * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等; 模拟不同的网络：2G，3G，4G，wifi等
 *
 * 2. 如何实现
 * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络，OS参数，获取到浏览器返回结果。
 *
 * 注意：网络环境配置信息{@link cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum}目前使用是常规速度，可以根据实际情况进行调整
 *
 * @author cruder
 * @time 2019/12/7 20:3 下午
 */
package.cn.mycookies.landingpagecheck;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;b. 类注接&lt;br&gt;
javadoc注解中，每个类都必须有注解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* Copyright (C), 2019-2020, Jann  balabala...
*
* 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....
*
* @author   类创建者姓名 保持对齐
* @date     创建日期 保持对齐
* @version  版本号 保持对齐
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;c. 属性注解&lt;br&gt;
在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/** 提示信息 */
private String userName;
/**
 * 密码
 */
private String password;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;d. 方法注释&lt;br&gt;
在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
  * 方法的详细说明，能干嘛，怎么实现的，注意事项...
  *
  * @param xxx      参数1的使用说明， 能否为null
  * @return 返回结果的说明， 不同情况下会返回怎样的结果
  * @throws 异常类型   注明从此类方法中抛出异常的说明
  */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;e. 构造方法注释&lt;br&gt;
在每个构造方法前面必须加上注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
  * 构造方法的详细说明
  *
  * @param xxx      参数1的使用说明， 能否为null
  * @throws 异常类型   注明从此类方法中抛出异常的说明
  */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而简单注解往往是需要工程师字节定义，在使用注解时应该注意一下几点：&lt;/p&gt;
&lt;p&gt;枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。&lt;/p&gt;
&lt;p&gt;保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用1个空格分隔。&lt;/p&gt;
&lt;p&gt;对于不同的逻辑说明，可以用空行分隔&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;无论是命名和注解，他们的目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优秀的代码往往能够见名知意，注解往往是对命名的补充和完善。命名太南了！&lt;/p&gt;
&lt;p&gt;参考文献：&lt;br&gt;
《码出高效》&lt;br&gt;
&lt;code&gt;https://www.cnblogs.com/wangcp-2014/p/10215620.html&lt;/code&gt;
&lt;code&gt;https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6&lt;/code&gt;
&lt;code&gt;https://google.github.io/styleguide/javaguide.html#s2.1-file-name&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Mybatis之XML篇</title>
        <link>https://ianeiu.github.io/p/mybatis%E4%B9%8Bxml%E7%AF%87/</link>
        <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/mybatis%E4%B9%8Bxml%E7%AF%87/</guid>
        <description>&lt;p&gt;Mybatis xml映射文件中，除了常见的select、insert、updae、delete标签之外
还有动态sql标签 trim、 where、set、foreach、if、choose、when、otherwise、bind等&lt;/p&gt;
&lt;h3 id=&#34;where标签&#34;&gt;where标签&lt;/h3&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT
module_code, oper_type, oper_content, data_id, oper_by, oper_name, oper_dt, INET_NTOA(oper_ip) as oper_ip
FROM tb_operation_log l WHERE 1=1
&amp;lt;if test=&amp;quot;param.moduleCode != null&amp;quot;&amp;gt;
    AND l.module_code = #{param.moduleCode}
&amp;lt;/if&amp;gt;
&amp;lt;if test=&amp;quot;param.operBy != null and param.operBy !=&#39;&#39;&amp;quot;&amp;gt;
    AND l.oper_by = #{param.operBy}
&amp;lt;/if&amp;gt;
&amp;lt;if test=&amp;quot;param.operName != null and param.operName !=&#39;&#39;&amp;quot;&amp;gt;
    AND l.oper_name LIKE CONCAT(&amp;quot;%&amp;quot;,#{param.operName},&amp;quot;%&amp;quot;)
&amp;lt;/if&amp;gt;
&amp;lt;if test=&amp;quot;param.operDtStart != null and param.operDtEnd != null&amp;quot;&amp;gt;
    AND l.oper_dt BETWEEN #{param.operDtStart} AND #{param.operDtEnd}
&amp;lt;/if&amp;gt;
order by l.oper_dt desc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT
module_code, oper_type, oper_content, data_id, oper_by, oper_name, oper_dt, INET_NTOA(oper_ip) as oper_ip
FROM tb_operation_log l
&amp;lt;where&amp;gt;
    &amp;lt;if test=&amp;quot;param.moduleCode != null&amp;quot;&amp;gt;
        AND l.module_code = #{param.moduleCode}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;param.operBy != null and param.operBy !=&#39;&#39;&amp;quot;&amp;gt;
        AND l.oper_by = #{param.operBy}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;param.operName != null and param.operName !=&#39;&#39;&amp;quot;&amp;gt;
        AND l.oper_name LIKE CONCAT(&amp;quot;%&amp;quot;,#{param.operName},&amp;quot;%&amp;quot;)
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;param.operDtStart != null and param.operDtEnd != null&amp;quot;&amp;gt;
        AND l.oper_dt BETWEEN #{param.operDtStart} AND #{param.operDtEnd}
    &amp;lt;/if&amp;gt;
&amp;lt;/where&amp;gt;
order by l.oper_dt desc
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;foreach标签&#34;&gt;foreach标签&lt;/h3&gt;
&lt;p&gt;参数未加@Param命名，默认是list&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select p.* from tb_process_btn_param p where p.param_type = 0 and p.btn_id in
&amp;lt;foreach collection=&amp;quot;list&amp;quot; item=&amp;quot;btnId&amp;quot; index=&amp;quot;index&amp;quot; open=&amp;quot;(&amp;quot; close=&amp;quot;)&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
    #{btnId}
&amp;lt;/foreach&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Spring常用注解</title>
        <link>https://ianeiu.github.io/p/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</link>
        <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</guid>
        <description>&lt;h2 id=&#34;常用注解&#34;&gt;常用注解&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;注解&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Component&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;泛指组件，类似在xml中配置bean &lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Configuration&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;把类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Repository&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于标注数据访问组件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Service&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于标注业务层组件,默认bean的id为类名且首字母小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Controller&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于标注控制层组件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@RestController&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;spring4.0之后，@controller和@responsebody的结合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Scope&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;作用域 表示将Action的范围声明为原型，可以利用容器的scope=&amp;ldquo;prototype&amp;quot;来保证每一个请求有一个单独的Action来处理，避免struts中Action的线程安全问题。spring默认scope是单例模式(scope=&amp;ldquo;singleton&amp;rdquo;)，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2是要求每次次访问都对应不同的Action，scope=&amp;ldquo;prototype&amp;quot;可以保证当有请求的时候都创建一个Action对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Lazy(true)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;延迟初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@RequestMapping&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。value：指定请求的实际地址；method：指定请求的method类型，GET、POST、PUT、DELETE等（Spring4.3中引进了｛@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping｝，来帮助简化常用的HTTP方法的映射）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@ResponseBody&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，效果等同于通过response对象输出指定格式的数据 效果等同于如下代码：@RequestMapping(&amp;quot;/login&amp;rdquo;)   public void login(User user, HttpServletResponse response){  response.getWriter.write(JSONObject.fromObject(user).toString());  }&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@PostConstruct&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;初始化注解,用于指定初始化方法（用在方法上）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@PreDestory&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于指定销毁方法（用在方法上）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@DependsOn&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;定义Bean初始化及销毁时的顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Primary&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Autowired&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Resource&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;默认按名称装配,当找不到与名称匹配的bean才会按类型装配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@Async&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;异步方法调用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@RequestParam&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;接收参数,从request里面拿取值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@PathVariable&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;接收参数,从一个URI模板里面来填充&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@PathParam&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@QueryParam&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;JAX-RS 提供的，和Spring的RequestParam作用一致&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;@RequestBody&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一般是post请求的时候才会使用这个请求(处理application/json、application/xml等格式的数据)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;属性注入&#34;&gt;属性注入&lt;/h2&gt;
&lt;h3 id=&#34;autowired&#34;&gt;@Autowired&lt;/h3&gt;
&lt;p&gt;自动装配，可消除代码里的getter/setter与bean属性中的property&lt;/p&gt;
&lt;p&gt;如果不使用注解自动注入，必须通过代码手动注入,如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot; /&amp;gt;
    &amp;lt;property name=&amp;quot;student&amp;quot; ref=&amp;quot;student&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;xxx.Student&amp;quot; /&amp;gt;
...

@Test
public void test(){
    //读取配置文件
    ApplicationContext ctx=new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);
    User user=(User) ctx.getBean(&amp;quot;user&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而使用注解@Autowired大大减少了代码量，提高可读性。&lt;br&gt;
使用前配置文件要添加扫描器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&amp;lt;context:component-scan base-package=&amp;quot;xxx.vo&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;xxx.Student&amp;quot; /&amp;gt;
...

class User{
    @Autowired
    private Student student;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：当xml配置了user的属性时，Spring会按照xml优先的原则去User.java中寻找这两个属性的getter/setter，导致的结果就是初始化bean报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&amp;quot;xxx.vo&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;student&amp;quot; ref=&amp;quot;student&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;xxx.Student&amp;quot; /&amp;gt;

class User{
    @Autowired
    private Student student;
    //无getter/setter
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：当xml未配置了student的bean时会抛出找不到bean的异常，可将@Autowired注解的required设置为false，默认student为null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&amp;quot;xxx.vo&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot; /&amp;gt;

class User{
    @Autowired(required=false)
    private Student student;
    //无getter/setter
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;qualifier&#34;&gt;Qualifier&lt;/h3&gt;
&lt;p&gt;指定注入Bean的名称&lt;/p&gt;
&lt;h3 id=&#34;resource&#34;&gt;@Resource&lt;/h3&gt;
&lt;p&gt;@Resource注解与@Autowired注解作用相似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User{
    @Resource(name=&amp;quot;student&amp;quot;)
    private Student student;
	
    //@Resource(type=&amp;quot;Student.class&amp;quot;)
    //private Student student;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@Resource的装配顺序：
(1)、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配
(2)、指定了name或者type则根据指定的类型去匹配bean，任何一个不匹配都将报错&lt;/p&gt;
&lt;p&gt;@Autowired和@Resource两个注解的区别：
(1)、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配
(2)、@Autowired是Spring的注解，@Resource是J2EE的注解&lt;/p&gt;
&lt;h3 id=&#34;value&#34;&gt;@Value&lt;/h3&gt;
&lt;p&gt;基本数值的填充 :@Value(&amp;quot;&amp;quot;)&lt;br&gt;
常用于获取配置文件参数值 ${配置文件中参数名}&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直接new对象是无法获取参数值的，必须通过springIOC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;@Value注入static属性的两种方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;//1.通过执行set方法进行参数注入
private static String userName;
@Value(&amp;quot;${git.userName}&amp;quot;)
public void setUserName(String userName) {
    GitUtils.userName = userName;
}

//2.通过中间变量赋值
private static String userName; 
@Value(&amp;quot;${git.userName}&amp;quot;)
private String userNameTmp;
@PostConstruct
public void init() {
    userName = userNameTmp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;接收参数&#34;&gt;接收参数&lt;/h2&gt;
&lt;h3 id=&#34;requestparam&#34;&gt;@RequestParam&lt;/h3&gt;
&lt;p&gt;处理Content-Type为 application/x-www-form-urlencoded编码的内容&lt;/p&gt;
&lt;p&gt;http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20&lt;br&gt;
根据上面的这个URL，你可以用这样的方式来进行获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String getDetails(
    @RequestParam(value=&amp;quot;param1&amp;quot;, required=true) String param1,
    @RequestParam(value=&amp;quot;param2&amp;quot;, required=false) String param2){
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@RequestParam 支持下面四种参数
defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值
name 绑定本次参数的名称，要跟URL上面的一样
required 这个参数是不是必须的
value 跟name一样的作用，是name属性的一个别名&lt;/p&gt;
&lt;h3 id=&#34;pathvariable&#34;&gt;@PathVariable&lt;/h3&gt;
&lt;p&gt;这个注解能够识别URL里面的一个模板，我们看下面的一个URL
http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20
上面的一个url你可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String getDetails(
    @RequestMapping(&amp;quot;/hello/{id}&amp;quot;)
    public String getDetails(@PathVariable(value=&amp;quot;id&amp;quot;) String id,
    @RequestParam(value=&amp;quot;param1&amp;quot;, required=true) String param1,
    @RequestParam(value=&amp;quot;param2&amp;quot;, required=false) String param2){
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;requestbody&#34;&gt;@RequestBody&lt;/h3&gt;
&lt;p&gt;@RequestBody用于post请求，处理 application/json、application/xml等格式的数据&lt;/p&gt;
&lt;h3 id=&#34;modelattribute&#34;&gt;@ModelAttribute&lt;/h3&gt;
&lt;p&gt;@ModelAttribute注解类型将参数绑定到Model对象，处理 multipart/form-data 格式的数据&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JVM之volatile关键字</title>
        <link>https://ianeiu.github.io/p/jvm%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</link>
        <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/jvm%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
        <description>&lt;h2 id=&#34;引入&#34;&gt;引入&lt;/h2&gt;
&lt;p&gt;Java内存模型简称JMM（Java Memory Model），是Java虚拟机所定义的一种抽象规范，
用来屏蔽不同硬件和操作系统的内存访问差异，让java程序在各种平台下都能达到一致的内存访问效果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主内存（Main Memory）&lt;br&gt;
主内存可以简单理解为计算机当中的内存，但又不完全等同。&lt;br&gt;
主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作内存（Working Memory）&lt;br&gt;
工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。&lt;br&gt;
每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。&lt;br&gt;
线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。&lt;br&gt;
不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于一个静态变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int s = 0；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;线程A执行如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = 3；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过一系列内存读写的操作指令，线程A把静态变量 s=0 从主内存读到工作内存，再把 s=3 的更新结果同步到主内存当中。&lt;/p&gt;
&lt;p&gt;从单线程的角度来看，这个过程没有任何问题。这时候我们引入线程B，执行如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(&amp;quot;s=&amp;quot; + s);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有可能输出 0 或 3&lt;/p&gt;
&lt;p&gt;可以使用synchronized同步锁（影响性能）或者使用volatile关键字修饰（轻量）&lt;/p&gt;
&lt;h2 id=&#34;volatile的实现原理&#34;&gt;volatile的实现原理&lt;/h2&gt;
&lt;p&gt;volatile可以实现内存的可见性和防止指令重排序。&lt;/p&gt;
&lt;p&gt;通过内存屏障技术实现的。&lt;/p&gt;
&lt;p&gt;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障指令，内存屏障效果有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;禁止volatile 修饰变量指令的重排序&lt;/li&gt;
&lt;li&gt;写入数据强制刷新到主存&lt;/li&gt;
&lt;li&gt;读取数据强制从主存读取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对变量的写操作不依赖于当前值。例如 i++ 这种就不适用。&lt;/li&gt;
&lt;li&gt;该变量没有包含在具有其他变量的不变式中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;volatile的使用场景不是很多，使用时需要仔细考虑下是否适用volatile，注意满足上面的二个原则。&lt;/p&gt;
&lt;h2 id=&#34;volatile-之-可见性&#34;&gt;volatile 之 可见性&lt;/h2&gt;
&lt;p&gt;volatile关键字具有许多特性，其中最重要的特性就是保证了用volatile修饰的变量对所有线程的可见性[当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值]。&lt;/p&gt;
&lt;p&gt;比如用一个变量标识程序是否启动、初始化完成、是否停止等，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MessageLoopHandler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shutdown&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//A线程执行shutdown方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;shutdown&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;shutdown&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;//B线程检查到shutdown为true结束循环
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;doWork&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shutdown&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//应用没有停止时，继续检查是否有新消息
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但volatile不能保证变量的原子性即无法保证线程安全。&lt;/p&gt;
&lt;h4 id=&#34;什么时候适合用&#34;&gt;什么时候适合用&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;VolatileTest&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//开启 10个线程
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
                    &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Runnable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                            &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                                &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
                            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InterruptedException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                                &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
                            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
                            &lt;span class=&#34;c1&#34;&gt;//每个线程当中让count值自增 100次
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                                &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++;&lt;/span&gt;
                            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
                        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
                    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Weep&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2000&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InterruptedException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;count&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//最终count的结果值未必是1000，有可能小于1000。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;变量不需要与其他的状态变量共同参与不变约束。
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   
&lt;span class=&#34;n&#34;&gt;线程A执行如下代码&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;//do something
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
&lt;span class=&#34;n&#34;&gt;线程B执行如下代码&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   
&lt;span class=&#34;c1&#34;&gt;//这种情况下，一旦在线程A的循环中执行了线程B，start有可能先更新成6，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//造成了一瞬间 start == end，从而跳出while循环的可能性。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;volatile-之-有序性-阻止指令重排&#34;&gt;volatile 之 有序性 （阻止指令重排）&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Singleton2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Singleton2&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Singleton2&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    	&lt;span class=&#34;c1&#34;&gt;//双重检测机制
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        	&lt;span class=&#34;c1&#34;&gt;//同步锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            	&lt;span class=&#34;c1&#34;&gt;//双重检测机制
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Singleton2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;已上代码存在问题，可能会得到一个没有初始化完成的对象&lt;/p&gt;
&lt;p&gt;JVM编译器的指令重排，可能会得到一个没有初始化的对象&lt;/p&gt;
&lt;p&gt;java中简单的一句 &lt;code&gt;instance = new Singleton&lt;/code&gt;，会被编译器编译成如下JVM指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;memory =allocate();    //1：分配对象的内存空间 
ctorInstance(memory);  //2：初始化对象 
instance =memory;     //3：设置instance指向刚分配的内存地址 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;memory =allocate();    //1：分配对象的内存空间 
instance =memory;     //3：设置instance指向刚分配的内存地址 
ctorInstance(memory);  //2：初始化对象 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当线程A执行完1,3,时，instance对象还未完成初始化，但已经不再指向null。&lt;br&gt;
此时如果线程B抢占到CPU资源，执行  if（instance == null）的结果会是false，从而返回一个没有初始化完成的instance对象。&lt;/p&gt;
&lt;p&gt;如何避免这一情况呢？我们需要在instance对象前面增加一个修饰符volatile。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>redis笔记</title>
        <link>https://ianeiu.github.io/p/redis%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/redis%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;redis&#34;&gt;redis&lt;/h2&gt;
&lt;p&gt;Redis本质上是一个Key-Value类型的内存数据库，支持保存多种数据结构，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。&lt;br&gt;
因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。&lt;/p&gt;
&lt;p&gt;Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。&lt;/p&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;daemonize：是否以后台进程运行，默认为no。Windows下不支持修改 。Linux平台下可以改为yes，这样就不用为了启动Redis而单独保留一个shell窗口。&lt;/li&gt;
&lt;li&gt;pidfile：如以后台进程运行，则需指定一个pid，默认为/var/run/redis.pid。Windows下不支持修改。&lt;/li&gt;
&lt;li&gt;bind：绑定主机IP，默认值为127.0.0.1（注释）&lt;/li&gt;
&lt;li&gt;protected-mode：以保护模式运行，默认yes&lt;/li&gt;
&lt;li&gt;port： 监听端口，默认为6379&lt;/li&gt;
&lt;li&gt;timeout： 超时时间，默认为300（秒）&lt;/li&gt;
&lt;li&gt;loglevel： 日志记录等级，有4个可选值，debug，verbose（默认值），notice，warning&lt;/li&gt;
&lt;li&gt;logfile： 日志记录方式，默认值为stdout&lt;/li&gt;
&lt;li&gt;databases： 可用数据库数，默认值为16，默认数据库为0&lt;/li&gt;
&lt;li&gt;save &lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt;： 指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。这个可以多个条件配合，比如默认配置文件中的设置，就设置了三个条件。
&lt;ul&gt;
&lt;li&gt;save 900 1 900秒（15分钟）内至少有1个key被改变&lt;/li&gt;
&lt;li&gt;save 300 10 300秒（5分钟）内至少有10个key被改变&lt;/li&gt;
&lt;li&gt;save 60 10000 60秒内至少有10000个key被改变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rdbcompression： 存储至本地数据库时是否压缩数据，默认为yes&lt;/li&gt;
&lt;li&gt;dbfilename： 本地数据库文件名，默认值为dump.rdb&lt;/li&gt;
&lt;li&gt;dir： 本地数据库存放路径，默认值为 ./&lt;/li&gt;
&lt;li&gt;slaveof： &lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt; 当本机为从服务时，设置主服务的IP及端口（注释）&lt;/li&gt;
&lt;li&gt;masterauth： &lt;!-- raw HTML omitted --&gt; 当本机为从服务时，设置主服务的连接密码（注释）&lt;/li&gt;
&lt;li&gt;requirepass 连接密码（注释）&lt;/li&gt;
&lt;li&gt;maxclients： 最大客户端连接数，默认不限制（注释）&lt;/li&gt;
&lt;li&gt;maxmemory &lt;!-- raw HTML omitted --&gt;： 设置最大内存，达到最大内存设置后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，任到达最大内存设置，将无法再进行写入操作。（注释）&lt;/li&gt;
&lt;li&gt;appendonly： 是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认值为no&lt;/li&gt;
&lt;li&gt;appendfilename： 更新日志文件名，默认值为appendonly.aof（注释）&lt;/li&gt;
&lt;li&gt;appendfsync： 更新日志条件，共有3个可选值。no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次（默认值）。&lt;/li&gt;
&lt;li&gt;vm-enabled： 是否使用虚拟内存，默认值为no&lt;/li&gt;
&lt;li&gt;vm-swap-file： 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享&lt;/li&gt;
&lt;li&gt;vm-max-memory： 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;info replication 查看信息，本机角色（master、slave）、ip、端口、状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;哨兵配置&#34;&gt;哨兵配置&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 这个是Redis6379配置内容，其他文件同理新增然后改一下端口即可，26380 26381
#当前Sentinel服务运行的端口
port 26381
bind 127.0.0.1
# 哨兵监听的主服务器 
sentinel monitor mymaster 127.0.0.1 6379 2
# 3s内mymaster无响应，则认为mymaster宕机了
sentinel down-after-milliseconds mymaster 3000
#如果10秒后,mysater仍没启动过来，则启动failover  
sentinel failover-timeout mymaster 10000  
# 执行故障转移时， 最多有1个从服务器同时对新的主服务器进行同步
sentinel parallel-syncs mymaster 1
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码，没有的话不用设置
sentinel auth-pass mymaster 123456
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动哨兵命令：redis-server.exe sentinel.conf &amp;ndash;sentinel&lt;/p&gt;
&lt;h2 id=&#34;redis的数据类型以及每种数据类型的使用场景&#34;&gt;redis的数据类型，以及每种数据类型的使用场景&lt;/h2&gt;
&lt;p&gt;(一)String&lt;br&gt;
这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。&lt;/p&gt;
&lt;p&gt;(二)hash&lt;br&gt;
这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。&lt;/p&gt;
&lt;p&gt;(三)list&lt;br&gt;
使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。&lt;/p&gt;
&lt;p&gt;(四)set&lt;br&gt;
因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。&lt;/p&gt;
&lt;p&gt;(五)sorted set&lt;br&gt;
sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。还可以用来做延时任务(&lt;!-- raw HTML omitted --&gt;分布式之延时任务方案解析&lt;!-- raw HTML omitted --&gt;)、范围查找。&lt;/p&gt;
&lt;h2 id=&#34;项目中使用redis&#34;&gt;项目中使用redis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;响应请求获取数据时经过redis查询（如果没有则访问数据库，并将数据存储至redis），达到极速响应；&lt;/li&gt;
&lt;li&gt;高并发的情况，可能减少数据库压力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis单线程工作模型优势&#34;&gt;redis单线程工作模型优势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;纯内存操作&lt;/li&gt;
&lt;li&gt;单线程操作，避免了频繁的上下文切换&lt;/li&gt;
&lt;li&gt;采用了非阻塞I/O多路复用机制（单个线程，跟踪每个I/O流的状态，来管理多个I/O流。）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用redis存在的问题&#34;&gt;使用redis存在的问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;缓存和数据库双写一致性问题&lt;/li&gt;
&lt;li&gt;缓存雪崩问题&lt;/li&gt;
&lt;li&gt;缓存击穿问题&lt;/li&gt;
&lt;li&gt;缓存的并发竞争问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis的过期策略以及内存淘汰机制&#34;&gt;redis的过期策略以及内存淘汰机制&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;为什么不用定时删除策略?&lt;br&gt;
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.&lt;/li&gt;
&lt;li&gt;定期删除+惰性删除是如何工作的呢?&lt;br&gt;
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。&lt;/li&gt;
&lt;li&gt;采用定期删除+惰性删除就没其他问题了么?&lt;br&gt;
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在redis.conf中有一行配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# maxmemory-policy volatile-lru
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。
3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。
4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐
5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐
6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用redis实现分布式锁&#34;&gt;使用Redis实现分布式锁&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//伪代码
//当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；
//当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败。
if（setnx（key，1） == 1）{
    //设置锁超时
    expire（key，30）
    try {
        do something ......
    } finally {
        //解锁
        del（key）
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的伪代码中，存在着三个致命问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;setnx和expire的非原子性&lt;br&gt;
设想一个极端场景，当线程A执行setnx，成功得到了锁，setnx刚执行成功，还未来得及执行expire指令，节点1（线程A）挂掉了。&lt;br&gt;
这样一来，这把锁就没有设置过期时间，变得“长生不老”，别的线程再也无法获得锁了。&lt;br&gt;
解决方法：使用set（key，1，30，NX）取代 setnx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;del 导致误删&lt;br&gt;
又是一个极端场景，假如某线程成功得到了锁，并且设置的超时时间是30秒。&lt;br&gt;
如果某些原因导致线程A执行的很慢很慢，过了30秒都没执行完，这时候锁过期自动释放，线程B得到了锁。&lt;br&gt;
随后，线程A执行完了任务，线程A接着执行del指令来释放锁。&lt;br&gt;
但这时候线程B还没执行完，线程A实际上删除的是线程B加的锁。&lt;br&gt;
解决方法：可以在加锁的时候把当前的线程ID当做value，并在删除之前验证key对应的value是不是自己线程的ID。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String threadId = Thread.currentThread().getId()
set（key，threadId ，30，NX）
//解锁
if（threadId .equals(redisClient.get(key))）{
    del(key)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，这样做又隐含了一个新的问题，判断和释放锁是两个独立操作，不是原子性。
使用用Lua脚本来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String luaScript = &amp;quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&amp;quot;;
redisClient.eval(luaScript , Collections.singletonList(key), Collections.singletonList(threadId));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;出现并发的可能性
还是刚才第二点所描述的场景，虽然我们避免了线程A误删掉key的情况，但是同一时间有A，B两个线程在访问代码块，仍然是不完美的。&lt;br&gt;
我们可以让获得锁的线程开启一个守护线程，用来给快要过期的锁“续航”。&lt;br&gt;
当过去了29秒，线程A还没执行完，这时候守护线程会执行expire指令，为这把锁“续命”20秒。&lt;br&gt;
守护线程从第29秒开始执行，每20秒执行一次。&lt;br&gt;
当线程A执行完任务，会显式关掉守护线程。&lt;br&gt;
另一种情况，如果节点1 忽然断电，由于线程A和守护线程在同一个进程，守护线程也会停下。&lt;br&gt;
这把锁到了超时的时候，没人给它续命，也就自动释放了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ref&#34;&gt;REF&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/rjzheng/p/9096228.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;分布式之redis复习精讲&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Survivalist/p/10321476.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Redis的那些最常见面试问题&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/8fdBKAyHZrfHmSajXT_dnA&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;什么是分布式锁？&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Eclipse笔记</title>
        <link>https://ianeiu.github.io/p/eclipse%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/eclipse%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;快捷键&#34;&gt;快捷键&lt;/h2&gt;
&lt;h4 id=&#34;使用频率极高的快捷键&#34;&gt;使用频率极高的快捷键&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DESC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代码提示&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt+/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自动生成object方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt + shift + s，然后根据提示继续&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;复制当前行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl +alt + ↓&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查找文本&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + k ,ctrl + shfit + k&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如何跳转到文件中的特定行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + l&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;调出搜索文本的视图&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + f&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;进行全局搜索和局部搜索&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + h&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;文件&#34;&gt;文件&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DESC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;创建各种类型的文件&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭当前文件&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭所有文件&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打开文件所在目录&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt + shift + w，选择system explorer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;类&#34;&gt;类&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DESC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示出当前打开的所有文件&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文件切换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + pg、up ,ctrl + pg、dn&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;视图切换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + f7	跳转到代码编辑器视图 f12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;经典的quick access&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + 3  搜maven、server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;eclipse的面包屑功能&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt + shift + b （右键面包屑有关闭按钮）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;文本&#34;&gt;文本&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DESC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;删除当前行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + d&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看字符串出现的地方&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + u&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示html和xml元素的所有属性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + ,&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;大小写转换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;变小写ctrl + shift + y,变大写ctrl +shift + x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重构-修改名字&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt + shift + r 统一修改方法的参数名字、或者类变量、方法变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重构-抽取类方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选中代码，然后使用alt + shift + m,就会弹出抽取视图&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;eclipse-插件&#34;&gt;Eclipse-插件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Team
&lt;ul&gt;
&lt;li&gt;Subclipse&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Theme
&lt;ul&gt;
&lt;li&gt;Eclipse Color Theme&lt;/li&gt;
&lt;li&gt;Darkest Dark Theme with DevStyle&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反编译
&lt;ul&gt;
&lt;li&gt;Enhanced Class Decompiler&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UML
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://ianeiu.github.io/resouce/tool/AmaterasUML_1.3.4.zip&#34; &gt;AmaterasUML_1.3.4.zip&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lombok
&lt;ul&gt;
&lt;li&gt;方式1&lt;br&gt;
将 &lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://ianeiu.github.io/resouce/tool/lombok.jar&#34; &gt;lombok.jar&lt;/a&gt;&lt;/em&gt; 文件，放到eclipse安装路径，该jar包也就是lombok插件的jar文件了&lt;br&gt;
打开eclipse.ini文件，添加如下内容：&lt;br&gt;
-javaagent:lombok.jar&lt;br&gt;
-Xbootclasspath/a:lombok.jar&lt;/li&gt;
&lt;li&gt;方式2(推荐)&lt;br&gt;
&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/dorothy1224/article/details/79280591&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;eclipse安装lombok&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;修改tomcat设置内存大小&#34;&gt;修改tomcat设置内存大小&lt;/h2&gt;
&lt;p&gt;方式1（推荐）：&lt;br&gt;
在Eclipse中下面Servers双击Tomcat Server&amp;hellip; 然后点击General InformAtion 下的Open launch configuration；&lt;br&gt;
会弹出Edit Configuration，然后在选中Arguments选项卡；在VM arguments文本框中最后面添加
-Xms256m -Xmx1024m -XX:MaxPermSize=256m 。&lt;/p&gt;
&lt;p&gt;方式2：&lt;br&gt;
在Eclipse菜单栏中Window ——》Preferences ——》Server ———》 Runtime Environment；&lt;br&gt;
选择您用的Tomcat 然后点击Edit&amp;hellip;弹出Edit Server Runtime Ecvironment 下面JRE选项后面的Installed JREs&amp;hellip;
点击弹出Installed JREs；在选中您用的Jre在点击Edit..在Defaul VM Arguments：中填入-Xms256m -Xmx512m&lt;/p&gt;
&lt;h2 id=&#34;删除某个工作空间&#34;&gt;删除某个工作空间&lt;/h2&gt;
&lt;p&gt;方式1（推荐）：&lt;br&gt;
打开你的Eclipse，菜单中找到：Window&amp;ndash;&amp;gt;Preferences&amp;ndash;&amp;gt;General&amp;ndash;&amp;gt;Startup and Shutdown&amp;ndash;&amp;gt;WorkSpace，
然后选中你想要删除的工作空间，点击右边的remove按钮即可。&lt;/p&gt;
&lt;p&gt;方式2：&lt;br&gt;
在你的Eclipse目录中找到以下文件configuration.settings\org.eclipse.ui.ide.prefs，这个就是工作空间的配置文件了。
然后将RECENT_WORKSPACES后面你想删除的工作空间删除即可。&lt;/p&gt;
&lt;h2 id=&#34;问题记录&#34;&gt;问题记录&lt;/h2&gt;
&lt;h2 id=&#34;tomcat启动报nullpointerexception&#34;&gt;tomcat启动报NullPointerException&lt;/h2&gt;
&lt;p&gt;在自己设置的workspace目录下面，打开目录：.metadata.plugins\org.eclipse.wst.server.core\ ，然后删除“temp0”文件夹即可。&lt;/p&gt;
&lt;h2 id=&#34;server视图加载项目之后项目名后边有带括号的名字&#34;&gt;Server视图加载项目之后项目名后边有带括号的名字&lt;/h2&gt;
&lt;p&gt;复制过来的项目会出现的一种情况：有时即使是项目改了名字在添加到Server上的时候在Server视图中看到项目名后边有一个带括号的名字,还是复制之前的项目名。&lt;/p&gt;
&lt;p&gt;解决：打开文件“你的工程目录.settings\org.eclipse.wst.common.component”看到内容，将里面所有为你原来工程名的字符串替换为新工程名字。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>IDEA笔记</title>
        <link>https://ianeiu.github.io/p/idea%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/idea%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;快捷键设置&#34;&gt;快捷键设置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;默认情况下，我们输入代码时IDEA会自动弹出代码提示框，这时候是不用按快捷键的，直接使用方向键选择我们需要的条目就可以了。&lt;/li&gt;
&lt;li&gt;如果我们想主动 使用代码提示时，默认的快捷键是CTRL+空格，但是中文系统这个快捷键为切换输入法，我们应该调整一下这个快捷键的功能。
首先我们点击左上角的File（文件）——》Setting（设置），打开全局设置。&lt;/li&gt;
&lt;li&gt;我们在左侧菜单选择KeyMap，Main Menu-&amp;gt;Code-&amp;gt;Complation，找到Basic和Cyclic Expand Word两个快捷键设置。&lt;/li&gt;
&lt;li&gt;在Cyclic Expand Word上点击右键，移除原本的快捷键（AIT+/）。&lt;/li&gt;
&lt;li&gt;Basic就是代码提示功能的选项了，我们在这条项目上点击右键，选择第一项，增加快捷键。&lt;/li&gt;
&lt;li&gt;在这个界面，我们按下的键就会成为快捷键，此时我们按下AIT+/ 把它作为代码提示的快捷键。&lt;/li&gt;
&lt;li&gt;添加完之后代码提示有了两个快捷键了，我们再次点击右键，删除原来的AIT+空格的快捷键就可以了！&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用快捷键&#34;&gt;常用快捷键&lt;/h2&gt;
&lt;h4 id=&#34;辅助&#34;&gt;辅助&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DESC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查找Intellij的命令&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Ctrl+Shift+A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;调整项目窗口宽度&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt+1定位到project视图，使用ctrl+shift+左右箭头来调整项目窗口宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;查询&#34;&gt;查询&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DESC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;跳转文件指定行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + l&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索文本&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + f&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;全局搜索和局部搜索&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;结合ctrl + f 快捷上下查找文本&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + k ,ctrl + shift + k&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查找接口实现类&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + alt +B ，ctrl + T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查询&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;shift + shift&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;方位名查询&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + alt + n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;目录查询&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + alt + n，输入/&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;编辑&#34;&gt;编辑&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DESC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自动处理&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt+Enter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代码联系&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + alt + space&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自动生成方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt+insert，然后根据提示继续&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;删除当前行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + d、x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;复制当前行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl +alt + ↓&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选中单词&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + ←、→&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;大小写转换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + u、y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;收尾补充（;{}等）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + 回车&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;驼峰下划线命名切换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + alt + c&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重构-修改类、方法、参数名字&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt + shift + r&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重构-抽取类方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选中代码，然后使用alt + shift + m,就会弹出抽取视图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重构-可选择&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Ctrl+Shift+Alt+T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代码生成&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Template/Postfix +Tab&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;文件&#34;&gt;文件&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DESC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭所有文件&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示最近打开的文件&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示最近修改的文件&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文件切换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + pg、up&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bookmarks&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + shift + F11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bookmarks查看&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;shift + F11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;视图&#34;&gt;视图&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DESC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;视图切换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + Tab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示类结构&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + o&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示文件位置&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Alt+F1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;项目切换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl + alt + [ 、]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择窗口&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alt + 窗口代码（1、2、3 ..）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;水平分组&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;右键文件tab，选择split vertically&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;垂直分组&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;右键文件tab，选择split horizontally&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;收藏至bookmark&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ctrl+shift+F11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打开  bookmark&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;shift+F11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;view&#34;&gt;View&lt;/h2&gt;
&lt;h4 id=&#34;演出模式&#34;&gt;演出模式&lt;/h4&gt;
&lt;p&gt;选择Enter Presentation Mode ，将IDEA弄到最大，让你只关注一个类里面的代码，进行毫无干扰的coding；&lt;br&gt;
配合CTRL+E等快捷键定位文件；&lt;br&gt;
选择Exit Presentation Mode 即可退出。&lt;/p&gt;
&lt;h4 id=&#34;去掉面包屑上方导航栏&#34;&gt;去掉面包屑（上方导航栏）&lt;/h4&gt;
&lt;p&gt;使用alt+v，然后取消Navigation bar勾选即可。&lt;/p&gt;
&lt;h2 id=&#34;inject-language&#34;&gt;Inject language&lt;/h2&gt;
&lt;p&gt;选中&amp;quot;&amp;quot;，使用alt+enter快捷键弹出inject language视图，并选中Inject language or reference；&lt;br&gt;
直接按下回车键，在inject language列表选择显示语言（JSON等）；&lt;br&gt;
再次使用alt+enter，选中Edit JSON Fragment并回车，就可以看到编辑JSON文件的视图了；&lt;br&gt;
使用alt+enter，选中Un-inject language/reference 回车即可取消。&lt;/p&gt;
&lt;h2 id=&#34;常用的exprjava&#34;&gt;常用的expr（Java）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;.sout&lt;/li&gt;
&lt;li&gt;.notnull&lt;/li&gt;
&lt;li&gt;.try&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常用的setting&#34;&gt;常用的Setting&lt;/h2&gt;
&lt;h4 id=&#34;auto-import&#34;&gt;Auto Import&lt;/h4&gt;
&lt;p&gt;add unambiguous imports on the fly 编写时自动导入&lt;br&gt;
optimize imports on the fly 编写时自动优化去除没用到的包&lt;/p&gt;
&lt;h4 id=&#34;appearance&#34;&gt;Appearance&lt;/h4&gt;
&lt;p&gt;show memory indicator 右下角显示内存使用情况，点击可回收内存&lt;br&gt;
show line number 显示选中代码行数&lt;/p&gt;
&lt;h4 id=&#34;editor-tabs&#34;&gt;editor tabs&lt;/h4&gt;
&lt;p&gt;取消勾选 show tabs in single row 多行显示tab，配合tab limit&lt;/p&gt;
&lt;h4 id=&#34;general&#34;&gt;General&lt;/h4&gt;
&lt;p&gt;change font size(Zoom) with ctrl+Mouse Wheel 滚轮调整字体大小&lt;/p&gt;
&lt;h4 id=&#34;不使用import-&#34;&gt;不使用import *&lt;/h4&gt;
&lt;p&gt;Settings -&amp;gt; Editor -&amp;gt; Code Style -&amp;gt; Java -&amp;gt; Imports  两个count to use import with &amp;lsquo;*&amp;rsquo; 设置成999。&lt;/p&gt;
&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;
&lt;h4 id=&#34;idea-rest-client&#34;&gt;IDEA REST Client&lt;/h4&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;学会IDEA REST Client后就可以丢掉postman了&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;常用插件&#34;&gt;常用插件&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;插件名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;插件介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Alibaba Java Coding Guidelines&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;阿里巴巴代码规范检查插件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;FindBugs-IDEA （QAPlug + QAPlug FindBugs）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;潜在 Bug 检查&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SonarLint&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Sonar代码检查&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Translation&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一款非常好用的翻译插件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CodeGlance&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代码编辑区迷你缩放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Rainbow Brackets&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对成对括号进行着色的插件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CamelCase&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;字段命名切换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Grep Console&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自定义设置不用日志用不同的颜色进行标识&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RestfulToolkit&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;取代postman，自动定位项目接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;MybatisX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Mapper接口和XML之间的跳转和自动生成模版的功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GsonFormat&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快速生成一个和该Json数据对应的Java对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Statistic&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代码统计插件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Maven Helper&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Maven 辅助插件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Properties to YAML Converter&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Properties 转 YAML 格式插件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;IDEA Mind Map&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;画思维导图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Git Commit Template&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;格式化提交信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;问题记录&#34;&gt;问题记录&lt;/h2&gt;
&lt;h4 id=&#34;idea-修复-弹窗license-activation报this-license-big3clik6f-has-been-cancelled&#34;&gt;IDEA 修复 弹窗License activation报this license BIG3CLIK6F has been cancelled&lt;/h4&gt;
&lt;p&gt;修改系统配置 ：&lt;br&gt;
Linux在/etc/hosts中添加 0.0.0.0 account.jetbrains.com&lt;br&gt;
windows在C:\Windows\System32\drivers\etc\hosts，将“0.0.0.0 account.jetbrains.com”添加到hosts文件中&lt;/p&gt;
&lt;h4 id=&#34;tomcat启动项目-错误&#34;&gt;tomcat启动项目 错误&lt;/h4&gt;
&lt;p&gt;Error running &amp;lsquo;Tomcat&amp;rsquo;: Unable to open debugger port (127.0.0.1:53904): java.net.SocketExceptio&lt;br&gt;
socket阻塞导致端口占用。
解决步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;netstat -ano | find &amp;quot;8081&amp;quot;&lt;/code&gt;  查看进程&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;taskkill -f -pid 8152&lt;/code&gt; 关闭进程&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;使用-lombok-后编译不通过&#34;&gt;使用 Lombok 后编译不通过&lt;/h4&gt;
&lt;p&gt;在 Intellij 中 Settings &amp;gt; Build, Execution, Deployment &amp;gt; Compiler &amp;gt; Annotation Processor 选项打钩&lt;/p&gt;
&lt;h2 id=&#34;开发记录&#34;&gt;开发记录&lt;/h2&gt;
&lt;h4 id=&#34;idea将项目部署到tomcatwebapps目录下&#34;&gt;idea将项目部署到tomcat/webapps目录下&lt;/h4&gt;
&lt;p&gt;Project Structure -&amp;gt; Modules -&amp;gt; Inherit project compile output path&lt;br&gt;
Artifacts 选择 Output directory D:\xxxx\tomcat\apache-tomcat-7.0.81\webapps\serverName&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Maven笔记</title>
        <link>https://ianeiu.github.io/p/maven%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/maven%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;项目构建和管理自动化工具&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;坐标(可由groupId、artifactId、version组成)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构件通过坐标作为其唯一标识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仓库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;远程仓库：maven-model-builder-3.3.3.jar\org\apache\maven\model,超级pom.xml文件，全球中央仓库地址：https://repo.maven.apache.org/maven2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;镜像仓库：/conf/setting文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;mirror&amp;gt;
    &amp;lt;id&amp;gt;maven.net.cn&amp;lt;/id&amp;gt;
    &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;name&amp;gt;central mirror in china&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http://maven.net.cn/content/groups/public&amp;lt;/url&amp;gt;
&amp;lt;/mirror&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地仓库：修改本地仓库的位置 &lt;code&gt;&amp;lt;localRepository&amp;gt;D:/Maven/repository&amp;lt;/localRepository&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定jdk1.7&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;profile&amp;gt;
    &amp;lt;id&amp;gt;jdk-1.7&amp;lt;/id&amp;gt;
    &amp;lt;activation&amp;gt;
        &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;
        &amp;lt;jdk&amp;gt;1.7&amp;lt;/jdk&amp;gt;
    &amp;lt;/activation&amp;gt;	
    &amp;lt;properties&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;maven.compiler.compilerVersion&amp;gt;1.7&amp;lt;/maven.compiler.compilerVersion&amp;gt;
    &amp;lt;/properties&amp;gt;
&amp;lt;/profile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;``&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用构建命令&#34;&gt;常用构建命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;mvn compile 编译
mvn test 测试
mvn package 打包
mvn clean 删除target
mvn install 安装jar包到本地仓库
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;自动创建目录骨架&#34;&gt;自动创建目录骨架&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;archetype:generate 按照提示进行&lt;/li&gt;
&lt;li&gt;archetype:generate -DgroupId=组织名, 公司网址的反写+项目名&lt;br&gt;
-DartifactId=项目名-模块名&lt;br&gt;
-Dversion=版本号&lt;br&gt;
-Dpackage=代码所存在的包&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;完整的项目构建过程&#34;&gt;完整的项目构建过程&lt;/h2&gt;
&lt;p&gt;清理、编译、测试、打包、集成测试、验证、部署&lt;/p&gt;
&lt;h2 id=&#34;maven生命周期&#34;&gt;maven生命周期&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;clean：清理项目
	- pre-clean ：执行清理前的工作
	- clean：清理上一次构建生成的所有文件
	- post-clean：执行清理后的文件
default：构建项目
	- compile test package install
site：生成项目站点
	- pre-site 在生成项目站点之前要完成的工作
	- site 生成项目的站点文档
	- post-site在生成项目站点后要完成的工作
	- site-deploy发布生成的站点到服务器上
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;pom结构&#34;&gt;pom结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;project (根元素，包含约束信息)
	modelVersion  指定了当前pom版本
	groupId    反写的公司网址+项目名
	artifactId  项目名+模块名
	version     版本号  第一个0表示大版本号，第二个0表示大版本号，第三个0表示大版本号 0.0.1snapshot快照 alpha內部測試 beta公测 Release稳定 GA正式发布
	packaging   打包方式 默认是jar

	name       项目的描述名
	url       项目的地址
	description  项目描述
	developers   开发人员信息
	licenses    许可证信息
	
	dependencies 
		-dependency ｛依赖冲突 1.短路优先（优先依赖最近的模块）2.先声明先优先｝
			-groupId
			-artifactId
			-version
			-type	
			-scope    依赖范围 [默认compile、provided、runtime、test、system、import]
			-optional 设置依赖是否可选
			-exclusions
				-exclusion
					-groupId
					-artifactId

	dependencyManagement   依赖管理  不会被运行(子模块来引用)
		-dependencies
			-dependency
			
	build
		-plugins  插件列表（指出坐标）
			-plugin
				-groupId
				-artifactId
				-version
				
	parent    对父模块的继承
		-groupId	[org..]
		-artifactId [jetty\tomcat..]
		-version [...]
		-executions
			-execution	在打包成功后使用 jetty\tomcat：run来运行jetty服务
				-phase [package]
				-goals [run]
					-goal
	modules   定义多个模块  一起进行编译
		-module [聚合的项目、模块]
		


&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;问题记录&#34;&gt;问题记录&lt;/h2&gt;
&lt;h4 id=&#34;could-not-calculate-build-plan&#34;&gt;Could not calculate build plan&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;将C:\User.m2\repository\org\apache\maven\plugins\maven-deploy-plugin目录下的文件夹删除;&lt;/li&gt;
&lt;li&gt;右击项目Maven-&amp;gt;Update Project-&amp;gt;Update Dependencies&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;missing-artifact&#34;&gt;Missing artifact&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;看看本地仓库是否有这个jar的目录，目录里是否有该jar的一个后缀为lastUpdated的文件;&lt;/li&gt;
&lt;li&gt;如果有就把这个文件删掉，再update一下dependency就行了。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Git笔记</title>
        <link>https://ianeiu.github.io/p/git%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/git%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;git使用教程&#34;&gt;Git使用教程&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/tugenhua0707/p/4050072.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Git使用教程&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;几条常用命令记录&#34;&gt;几条常用命令记录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt; 查看本地分支文件信息，确保更新时不产生冲突&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout –- [file name]&lt;/code&gt;  若文件有修改，可以还原到最初状态; 若文件需要更新到服务器上，应该先merge到服务器，再更新到本地&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch&lt;/code&gt; 查看当前分支情况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout remote branch&lt;/code&gt;  若分支为本地分支，则需切换到服务器的远程分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git pull&lt;/code&gt; 拉取代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout branchA&lt;/code&gt; 切换到分支branchA&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch branchB&lt;/code&gt; 创建分支branchB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;git-工具本地用户名修改&#34;&gt;git 工具本地用户名修改&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;获取当前的用户名  &lt;code&gt;git config user.name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改用户名 &lt;code&gt;git config --global user.name &amp;quot;用户名&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reset-与-revert&#34;&gt;reset 与 revert&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用 reset&lt;/li&gt;
&lt;li&gt;如果我们想恢复之前的某一版本（该版本不是merge类型），但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用 revert&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐文章  &lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/yxlshk/article/details/79944535&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Git恢复之前版本的两种方法reset、revert（图文详解）&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;恢复修改的文件&#34;&gt;恢复修改的文件&lt;/h2&gt;
&lt;p&gt;情况1：&lt;br&gt;
修改了文件，没有做过任何git操作，直接 &lt;code&gt;git checkout -- test.txt&lt;/code&gt; 就OK了。&lt;/p&gt;
&lt;p&gt;情况2：&lt;br&gt;
修改了文件，只进行了git add，执行 &lt;code&gt;git reset HEAD&lt;/code&gt; 回退到当前版本, 然后&lt;code&gt;git checkout -- test.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;情况3：&lt;br&gt;
修改了文件，进行了git add 和 git commit，执行 &lt;code&gt;git reset HEAD^&lt;/code&gt; 回退到上一个版本, 然后&lt;code&gt;git checkout -- test.txt&lt;/code&gt;&lt;br&gt;
使用IDEA  &lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_36033658/article/details/81902589&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;git还原commit（push之前）&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;情况4：
修改了文件，进行了git add 、 git commit 、git push，根据版本号从新到旧依次执行&lt;code&gt;git revert [版本号]&lt;/code&gt;、然后 &lt;code&gt;git commit&lt;/code&gt;、&lt;code&gt;git push&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;分支&#34;&gt;分支&lt;/h2&gt;
&lt;p&gt;建议使用IDEA  &lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.malaoshi.top/show_1EF2E613IFX.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;idea git的使用（四）git建立分支与合并分支&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;tag&#34;&gt;tag&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git tag &lt;/code&gt;                          列出所有标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git tag -a v1.0.0 -m &amp;quot;1.0.0版本&amp;quot;&lt;/code&gt;  创建标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin v1.0.0&lt;/code&gt;            将v1.0.0标签提交到git服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin –tags&lt;/code&gt;            将本地所有标签一次性提交到git服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git tag -d v1.0.0&lt;/code&gt;                 删除标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin :refs/tags/v1.0.0&lt;/code&gt; 删除git服务器的v1.0.0标签&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gitignore配置-不生效原因和解决&#34;&gt;.gitignore配置 不生效原因和解决&lt;/h2&gt;
&lt;p&gt;查看状态，想要忽略的文件还是显示被追踪状态。
原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，
这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。&lt;/p&gt;
&lt;p&gt;解决方法: git清除本地缓存（改变成未track状态），然后再提交:
git rm -r &amp;ndash;cached .
git add .&lt;/p&gt;
</description>
        </item>
        <item>
        <title>常用代码片段</title>
        <link>https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</link>
        <pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</guid>
        <description>&lt;h3 id=&#34;操作元素的样式&#34;&gt;操作元素的样式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;#msg&amp;quot;).css(&amp;quot;background&amp;quot;); //返回元素的背景颜色
$(&amp;quot;#msg&amp;quot;).css(&amp;quot;background&amp;quot;,&amp;quot;#ccc&amp;quot;) //设定元素背景为灰色
$(&amp;quot;#msg&amp;quot;).height(300); $(&amp;quot;#msg&amp;quot;).width(&amp;quot;200&amp;quot;); //设定宽高
$(&amp;quot;#msg&amp;quot;).css({ color: &amp;quot;red&amp;quot;, background: &amp;quot;blue&amp;quot; });//以名值对的形式设定样式

$(&amp;quot;p&amp;quot;).attr(&amp;quot;class&amp;quot;, &amp;quot;ddiiyy&amp;quot;); //设置p元素的class为 &amp;quot;ddiiyy&amp;quot; 
$(&amp;quot;#nm_p&amp;quot;).addClass(&amp;quot;another&amp;quot;); // 追加样式 
$(&amp;quot;p&amp;quot;).removeClass(&amp;quot;ddiiyy another&amp;quot;); //溢出样式
$(&amp;quot;p&amp;quot;).toggleClass(&amp;quot;ddiiyy&amp;quot;); //如果存在（不存在）就删除（添加）名为ddiiyy的class
$(&amp;quot;p&amp;quot;).hasClass(&amp;quot;another&amp;quot;); //是否含有某个class。是返true，否返false
$(&amp;quot;p&amp;quot;).is(&amp;quot;.another&amp;quot;); //is(&amp;quot;.&amp;quot;+class);//JQuery实现，增强代码可读性
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;readonly和disabled&#34;&gt;readonly和disabled&lt;/h3&gt;
&lt;p&gt;表单中readOnly和disabled的区别：&lt;br&gt;
readonly只针对input(text/ password)和textarea有效，而disabled对于所有的表单元素都有效，包括select,radio, checkbox, button等。&lt;br&gt;
但是表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去（这种情况出现在我们将某个表单中的textarea元素设置为disabled或readonly，但是submit或button却是可以使用的）。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;隐藏和显示操作display属性&#34;&gt;隐藏和显示(操作display属性)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;#id&amp;quot;).show();//表示display:block, 
$(&amp;quot;#id&amp;quot;).hide();//表示display:none; 
$(&amp;quot;#id&amp;quot;).toggle();//切换元素的可见状态。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。
$(&amp;quot;#id&amp;quot;).css(&#39;display&#39;,&#39;none&#39;); 
$(&amp;quot;#id&amp;quot;).css(&#39;display&#39;,&#39;block&#39;); 
或 
$(&amp;quot;#id&amp;quot;)[0].style.display = &#39;none&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;操作disabled属性&#34;&gt;操作disabled属性&lt;/h3&gt;
&lt;p&gt;js操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function disableElement(element,val){
    document.getElementById(element).disabled=val;d
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jQuery进行操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//两种方法设置disabled属性
$(&#39;#areaSelect&#39;).attr(&amp;quot;disabled&amp;quot;,true);
$(&#39;#areaSelect&#39;).attr(&amp;quot;disabled&amp;quot;,&amp;quot;disabled&amp;quot;);
//三种方法移除disabled属性
$(&#39;#areaSelect&#39;).attr(&amp;quot;disabled&amp;quot;,false);
$(&#39;#areaSelect&#39;).removeAttr(&amp;quot;disabled&amp;quot;);
$(&#39;#areaSelect&#39;).attr(&amp;quot;disabled&amp;quot;,&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取s:textfield，并设置其disabled属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;functiondisableTextfieldofAccountDiv(element,val) {
    $(element).find(&amp;quot;:textfield&amp;quot;).attr(&#39;disabled&#39;,val);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;禁用abutton点击&#34;&gt;禁用a，button点击&lt;/h3&gt;
&lt;p&gt;1.jquery禁用a标签方法1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready(function () {
    $(&amp;quot;a&amp;quot;).each(function () {
        var textValue = $(this).html();
        if (textValue == &amp;quot;XX概况&amp;quot; || textValue == &amp;quot;服务导航&amp;quot;) {
            $(this).css(&amp;quot;cursor&amp;quot;, &amp;quot;default&amp;quot;);
            $(this).attr(&#39;href&#39;, &#39;#&#39;);     //修改&amp;lt;a&amp;gt;的 href属性值为 #  这样状态栏不会显示链接地址 
            $(this).click(function (event) {
                event.preventDefault();   // 如果&amp;lt;a&amp;gt;定义了 target=&amp;quot;_blank“ 需要这句来阻止打开新页面
            });
        }
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.jquery禁用a标签方法2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;a.tooltip&#39;).live(&#39;click&#39;, function(event) {
  alert(&amp;quot;抱歉,已停用！&amp;quot;); 
  event.preventDefault();  
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.jquery禁用a标签方法3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(function(){
    $(&#39;.disableCss&#39;).removeAttr(&#39;href&#39;);//去掉a标签中的href属性
    $(&#39;.disableCss&#39;).removeAttr(&#39;onclick&#39;);//去掉a标签中的onclick事件
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.jquery控制按钮的禁用与启用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;#button&#39;).attr(&#39;disabled&#39;,&amp;quot;true&amp;quot;);//添加disabled属性
$(&#39;#button&#39;).removeAttr(&amp;quot;disabled&amp;quot;); //移除disabled属性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.css3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a style=&amp;quot;pointer-events: none;&amp;quot; onclick=&amp;quot;alert(&#39;ok&#39;);&amp;quot;&amp;gt;无法点击&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;操作checked属性回显&#34;&gt;操作checked属性\回显&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input id=&amp;quot;cb1&amp;quot; type=&amp;quot;checkbox&amp;quot; checked /&amp;gt;
&amp;lt;input id=&amp;quot;cb2&amp;quot; type=&amp;quot;checkbox&amp;quot; checked=&amp;quot;checked&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.jquery判断checked的三种方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.attr(&#39;checked&#39;)   //看版本1.6+返回:&amp;quot;checked&amp;quot;或&amp;quot;undefined&amp;quot; ;1.5-返回:true或false
.prop(&#39;checked&#39;) //16+:true/false
.is(&#39;:checked&#39;)    //所有版本:true/false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.jquery赋值checked的几种写法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//所有的jquery版本都可以这样赋值
$(&amp;quot;#cb1&amp;quot;).attr(&amp;quot;checked&amp;quot;,&amp;quot;checked&amp;quot;);
$(&amp;quot;#cb1&amp;quot;).attr(&amp;quot;checked&amp;quot;,true);

//jquery1.6+:prop的4种赋值
$(&amp;quot;#cb1&amp;quot;).prop(&amp;quot;checked&amp;quot;,true);    //很简单就不说了哦
$(&amp;quot;#cb1&amp;quot;).prop({checked:true});    //map键值对
$(&amp;quot;#cb1&amp;quot;).prop(&amp;quot;checked&amp;quot;,function(){  return true;   }); //函数返回true或false
$(&amp;quot;#cb1&amp;quot;).prop(&amp;quot;checked&amp;quot;,&amp;quot;checked&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.check回显的一个demo：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(list){
    if(type==1){
        var checkBoxAll = $(&amp;quot;input[name=&#39;outsideFileName&#39;]&amp;quot;);
        for(var i=0;i&amp;lt;list.length;i++){
            $.each(checkBoxAll,function(j,checkbox){
                //获取复选框的value属性
                var checkValue=$(checkbox).val();
                if(list[i].filePath==checkValue){
                    $(checkbox).attr(&amp;quot;checked&amp;quot;,true);
                }
            })
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;checkbox全选反选&#34;&gt;checkbox（全选反选..）&lt;/h3&gt;
&lt;p&gt;demo：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注：jquery1.9.0+无法正常显示
&amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;quot;&amp;gt; 
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;&amp;gt; 
&amp;lt;head&amp;gt; 
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt; 
&amp;lt;title&amp;gt;jQuery 对checkbox的操作&amp;lt;/title&amp;gt; 
&amp;lt;/HEAD&amp;gt; 
&amp;lt;body style=&amp;quot;text-align:center;margin: 0 auto;font-size: 12px;&amp;quot; mce_style=&amp;quot;text-align:center;margin: 0 auto;font-size: 12px;&amp;quot;&amp;gt; 
&amp;lt;div style=&amp;quot;border: 1px solid #999; width: 500px; padding: 15px; background: #eee; margin-top: 150px;&amp;quot;&amp;gt; 
&amp;lt;form name=&amp;quot;form1&amp;quot; method=&amp;quot;post&amp;quot; action=&amp;quot;&amp;quot;&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn1&amp;quot; value=&amp;quot;全选&amp;quot;&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn2&amp;quot; value=&amp;quot;取消全选&amp;quot;&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn3&amp;quot; value=&amp;quot;选中所有奇数&amp;quot;&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn4&amp;quot; value=&amp;quot;反选&amp;quot;&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn5&amp;quot; value=&amp;quot;获得选中的所有值&amp;quot;&amp;gt; 
&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt; 
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;checkbox&amp;quot; value=&amp;quot;checkbox1&amp;quot;&amp;gt; 
checkbox1 
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;checkbox&amp;quot; value=&amp;quot;checkbox2&amp;quot;&amp;gt; 
checkbox2 
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;checkbox&amp;quot; value=&amp;quot;checkbox3&amp;quot;&amp;gt; 
checkbox3 
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;checkbox&amp;quot; value=&amp;quot;checkbox4&amp;quot;&amp;gt; 
checkbox4 
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;checkbox&amp;quot; value=&amp;quot;checkbox5&amp;quot;&amp;gt; 
checkbox5 
&amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;checkbox&amp;quot; value=&amp;quot;checkbox6&amp;quot;&amp;gt; 
checkbox6 
&amp;lt;/form&amp;gt; 
&amp;lt;/div&amp;gt; 
&amp;lt;/body&amp;gt; 
&amp;lt;/HTML&amp;gt; 

&amp;lt;script  type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;http://libs.baidu.com/jquery/1.8.0/jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; 
&amp;lt;!-- 
$(&amp;quot;document&amp;quot;).ready(function(){ 
$(&amp;quot;#btn1&amp;quot;).click(function(){ 
$(&amp;quot;[name=&#39;checkbox&#39;]&amp;quot;).attr(&amp;quot;checked&amp;quot;,&#39;true&#39;);//全选 
}) 
$(&amp;quot;#btn2&amp;quot;).click(function(){ 
$(&amp;quot;[name=&#39;checkbox&#39;]&amp;quot;).removeAttr(&amp;quot;checked&amp;quot;);//取消全选 
}) 
$(&amp;quot;#btn3&amp;quot;).click(function(){ 
$(&amp;quot;[name=&#39;checkbox&#39;]:even&amp;quot;).attr(&amp;quot;checked&amp;quot;,&#39;true&#39;);//选中所有奇数 
}) 
$(&amp;quot;#btn4&amp;quot;).click(function(){ 
$(&amp;quot;[name=&#39;checkbox&#39;]&amp;quot;).each(function(){//反选 
if($(this).attr(&amp;quot;checked&amp;quot;)){ 
$(this).removeAttr(&amp;quot;checked&amp;quot;); 
} 
else{ 
$(this).attr(&amp;quot;checked&amp;quot;,&#39;true&#39;); 
} 
}) 
}) 
$(&amp;quot;#btn5&amp;quot;).click(function(){//输出选中的值 
var str=&amp;quot;&amp;quot;; 
$(&amp;quot;[name=&#39;checkbox&#39;][checked]&amp;quot;).each(function(){ 
str+=$(this).val()+&amp;quot;/r/n&amp;quot;; 
//alert($(this).val()); 
}) 
alert(str); 
}) 
}) 
--&amp;gt; 
&amp;lt;/script&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.获取checkbox选中的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var chk_value =[]; 
$(&#39;input[name=&amp;quot;test&amp;quot;]:checked&#39;).each(function(){ 
    chk_value.push($(this).val()); 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.点击全选 非全选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;input[name=&amp;quot;pCheckBox&amp;quot;]&#39;).click(function(){  
    //alert(this.checked);  
    if($(this).is(&#39;:checked&#39;)){  
        $(&#39;input[name=&amp;quot;eventIds&amp;quot;]&#39;).each(function(){  
            //此处如果用attr，会出现第三次失效的情况  
            $(this).prop(&amp;quot;checked&amp;quot;,true);  
        });  
    }else{  
         $(&#39;input[name=&amp;quot;eventIds&amp;quot;]&#39;).each(function(){  
            $(this).removeAttr(&amp;quot;checked&amp;quot;,false);  
        });  
        //$(this).removeAttr(&amp;quot;checked&amp;quot;);  
    }  
});  
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;radio&#34;&gt;radio&lt;/h3&gt;
&lt;p&gt;1.获取选中值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;input:radio :checked&#39;).val()；
$(&amp;quot;input[type=&#39;radio&#39;]:checked&amp;quot;).val();
$(&amp;quot;input[name=&#39;rd&#39;]:checked&amp;quot;).val();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.设置第一个Radio为选中值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;input:radio :first&#39;).attr(&#39;checked&#39;, &#39;checked&#39;);
$(&#39;input:radio :first&#39;).attr(&#39;checked&#39;, &#39;true&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.设置最后一个Radio为选中值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;input:radio :last&#39;).attr(&#39;checked&#39;, &#39;checked&#39;);
$(&#39;input:radio :last&#39;).attr(&#39;checked&#39;, &#39;true&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.根据索引值设置任意一个radio为选中值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;input:radio&#39;).eq(索引值).attr(&#39;checked&#39;, &#39;true&#39;);//索引值=0,1,2....
$(&#39;input:radio&#39;).slice(1,2).attr(&#39;checked&#39;, &#39;true&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.根据Value值设置Radio为选中值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;input:radio[value=&#39;rd2&#39;]&amp;quot;).attr(&#39;checked&#39;,&#39;true&#39;);
$(&amp;quot;input[value=&#39;rd2&#39;]&amp;quot;).attr(&#39;checked&#39;,&#39;true&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;select&#34;&gt;select&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;s&amp;quot;&amp;gt;
    &amp;lt;option value=&amp;quot;1&amp;quot;&amp;gt;嘻嘻&amp;lt;/option&amp;gt;
    &amp;lt;option value=&amp;quot;2&amp;quot;&amp;gt;呵呵&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.获取select中option被选中的文本值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;误：$(&amp;quot;#s&amp;quot;).text();  //获取所有option的文本值
$(&amp;quot;#s option:selected&amp;quot;).text();  //获取选中的option的文本值
$(&amp;quot;#s&amp;quot;).find(&amp;quot;option:selected&amp;quot;).text(); //获取选中的option的文本值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.获取select中option被选中的value值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;#s&amp;quot;).val();
$(&amp;quot;#s option:selected&amp;quot;).val();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.js获取select选中的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var sel=document.getElementById(&amp;quot;s&amp;quot;); 
var index = sel.selectedIndex; // 选中索引
albumid= sel.options[index].value;//要的值
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;textarea&#34;&gt;textarea&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;textarea name=&amp;quot;content&amp;quot; id=&amp;quot;content&amp;quot; rows=&amp;quot;8&amp;quot; cols=&amp;quot;5&amp;quot;&amp;gt;这是textarea内容&amp;lt;/textarea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.获取textarea文本值（用name和id）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;textarea[name=&#39;content&#39;]&amp;quot;).val()      $(&amp;quot;#content&amp;quot;).val()    
$(&amp;quot;textarea[name=&#39;content&#39;]&amp;quot;).text()      $(&amp;quot;#content&amp;quot;).text()    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.赋值textarea文本值（只能用id）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;#content&amp;quot;).val(&amp;quot;这是要写入的textarea文本内容&amp;quot;)
$(&amp;quot;#content&amp;quot;).text(&amp;quot;这是要写入的textarea文本内容&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;val和text的区别是：val()可以体现换行符，而text()不能。&lt;/p&gt;
&lt;p&gt;3.禁止文本域textarea可拖拽的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;textarea{ resize:none;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.让textarea没有黄框且不能拖拽：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;textarea{outline:none;resize:none;}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;confirm二次确认&#34;&gt;confirm，二次确认&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;if(confirm(&amp;quot;确定要删除该记录吗？&amp;quot;)){
    doSomething();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;重置表单reset&#34;&gt;重置表单reset&lt;/h3&gt;
&lt;p&gt;使用jquery方法重置form表单&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;误：$(&#39;#formName&#39;).reset();//得到的是数组。
正：$(&#39;#formName&#39;)[0].reset();//得到的是jQuery对象。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：这种方式虽然可以重置表单，但是不能重置隐藏字段。隐藏字段要单独处理。&lt;br&gt;
小知识：$(&#39;#formName&#39;).get(0)得到的是DOM对象。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;jquery-获取元素个数&#34;&gt;jquery 获取元素个数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;#div1&#39;).children().length;
$(&#39;#div1&#39;).children(&#39;span&#39;).length;//获取id=div1下的span元素个数
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;定位&#34;&gt;定位&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id =&#39;&#39;localid&amp;quot;&amp;gt; xixi&amp;lt;/div&amp;gt;
window.location.href=&#39;#localid&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;修改标题title&#34;&gt;修改标题title&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;document.title=&amp;quot;批量业务单&amp;quot;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;jq的事件处理功能&#34;&gt;JQ的事件处理功能&lt;/h3&gt;
&lt;p&gt;1.hover&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//当鼠标放在表格的某行上时将class置为over，离开时置为out。
$(&amp;quot;tr&amp;quot;).hover(
function(){
     $(this).addClass(&amp;quot;over&amp;quot;);
}, 
function(){ 
    $(this).addClass(&amp;quot;out&amp;quot;); 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;demo鼠标移入出现悬浮框&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td class=&#39;linkTd&#39;&amp;gt;
    &amp;lt;div style=&#39;position:relative;&#39;&amp;gt;
        @link&amp;lt;span class=&#39;linkHover&#39;&amp;gt;@detailLink&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/td&amp;gt;

.linkHover{         
    position: absolute;  
    top: 20px;  
    width: 320px;
    max-height: 250px;           /* 设置最大高度，当高度达到此值时出现滚动条 */  
    z-index: 10;  
    background-color: #E0E5E5;   
    overflow: auto;              /* 自动添加滚动条 */  
    box-shadow:0px 0px 10px #000;   /* 外阴影 */  
    display:none;
}

$(&#39;.linkTd&#39;).hover(  
    function(){   
        $(this).find(&#39;.linkHover&#39;).show();
    } ,  
    function(){  
        $(this).find(&#39;.linkHover&#39;).hide();
    }   
);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;进化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;```
    &amp;lt;!doctype html&amp;gt;
    &amp;lt;html&amp;gt;
        &amp;lt;head&amp;gt;
            &amp;lt;title class=&amp;quot;lang&amp;quot; langKey=&amp;quot;xxxx&amp;quot;&amp;gt;index&amp;lt;/title&amp;gt;
            &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf8&amp;quot; /&amp;gt;
            &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;js/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
            &amp;lt;style&amp;gt;
            .linkHover{         
                position: absolute;  
                top: 20px;  
                width: 320px;
                max-height: 250px;           /* 设置最大高度，当高度达到此值时出现滚动条 */  
                z-index: 10;  
                background-color: #E0E5E5;   
                overflow: auto;              /* 自动添加滚动条 */  
                box-shadow:0px 0px 10px #000;   /* 外阴影 */  
                display:none;
            }
            &amp;lt;/style&amp;gt;
        &amp;lt;/head&amp;gt;
        &amp;lt;body&amp;gt;
            &amp;lt;div class=&#39;linkTd&#39;&amp;gt;
                123123
            &amp;lt;/div&amp;gt;
        &amp;lt;/body&amp;gt;
        &amp;lt;script&amp;gt;
            $(function () {
                var tip =&amp;quot;&amp;lt;div style=&#39;position:relative;&#39;&amp;gt; &amp;lt;span class=&#39;linkHover&#39;&amp;gt;1111&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt;&amp;quot;;
                    $(&#39;.linkTd&#39;).append(tip);
            })
            $(&#39;.linkTd&#39;).hover( 
                function(){   
                    $(this).find(&#39;.linkHover&#39;).show();
                } ,  
                function(){  
                    $(this).find(&#39;.linkHover&#39;).hide();
                }   
            );
        &amp;lt;/script
    &amp;lt;/html&amp;gt;
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.ready&lt;br&gt;
在文档加载后激活函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready(function(){
  $(&amp;quot;.btn1&amp;quot;).click(function(){
    $(&amp;quot;p&amp;quot;).slideToggle();
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;语法 1  &lt;!-- raw HTML omitted --&gt;$(document).ready(function)&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
语法 2  &lt;!-- raw HTML omitted --&gt;$().ready(function)&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
语法 3  &lt;!-- raw HTML omitted --&gt;$(function)&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;3.toggle&lt;br&gt;
toggle()和slidetoggle()方法提供了状态切换功能。&lt;br&gt;
toggle()方法包括了hide()和show()方法。 slideToggle()方法包括了slideDown()和slideUp()方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//每次点击时轮换添加和删除名为selected的class。
$(&amp;quot;p&amp;quot;).toggle(function(){ 
     $(this).addClass(&amp;quot;selected&amp;quot;); 
},function(){ 
     $(this).removeClass(&amp;quot;selected&amp;quot;); 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.trigger&lt;br&gt;
在每一个匹配的元素上触发某类事件,如模拟点击，回车登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//模拟点击
$(&amp;quot;#b&amp;quot;).click(function(){$(&amp;quot;#a&amp;quot;).trigger(&amp;quot;click&amp;quot;)})
$(&amp;quot;#a&amp;quot;).trigger(&amp;quot;click&amp;quot;);//执行#a的click事件

//回车点击
$(document).keyup(function(event){
  if(event.keyCode ==13){
    $(&amp;quot;#btn_login&amp;quot;).trigger(&amp;quot;click&amp;quot;);
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;form表单增加&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; style=&amp;quot;display:none&amp;quot;/&amp;gt;&lt;/code&gt;可以防止回车提交自动提交表单&lt;/p&gt;
&lt;p&gt;推荐：keyup，防止笔记本键盘不小心触摸到了
有些文档中有写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(window).keydown（function(){
...
}）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;XP系统IE6下是不成功的。&lt;/p&gt;
&lt;p&gt;5.bind(eventtype,fn)，unbind(eventtype)&lt;br&gt;
事件的绑定与反绑定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;p&amp;quot;).bind(&amp;quot;click&amp;quot;, function(){alert($(this).text());}); //为每个p元素添加单击事件 
$(&amp;quot;p&amp;quot;).unbind(); //删除所有p元素上的所有事件 
$(&amp;quot;p&amp;quot;).unbind(&amp;quot;click&amp;quot;) //删除所有p元素上的单击事件
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;jq集合遍历&#34;&gt;JQ集合遍历&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//为索引分别为0，1，2的p元素分别设定不同的字体颜色。
$(&amp;quot;p&amp;quot;).each(function(i){this.style.color=[&#39;#f00&#39;,&#39;#0f0&#39;,&#39;#00f&#39;][i]})
//实现表格的隔行换色效果
$(&amp;quot;tr&amp;quot;).each(function(i){this.style.backgroundColor=[&#39;#ccc&#39;,&#39;#fff&#39;][i%2]})
//为每个p元素增加了click事件，单击某个p元素则弹出其内容
$(&amp;quot;p&amp;quot;).click(function(){alert($(this).html())})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;demo遍历table的tr获取td的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;tbody id=&amp;quot;history_income_list&amp;quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;input-s input-w input-hs&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;input-s input-w input-hs&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;input-s input-w input-hs&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;a class=&amp;quot;&amp;quot; onclick=&amp;quot;history_income_del(this);&amp;quot; href=&amp;quot;###&amp;quot;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;input-s input-w input-hs&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;input-s input-w input-hs&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;input-s input-w input-hs&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;a class=&amp;quot;&amp;quot; href=&amp;quot;###&amp;quot;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;input-s input-w input-hs&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;input-s input-w input-hs&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;input-s input-w input-hs&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;a class=&amp;quot;&amp;quot; href=&amp;quot;###&amp;quot;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/tbody&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for循环遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var trList = $(&amp;quot;#history_income_list&amp;quot;).children(&amp;quot;tr&amp;quot;)
for (var i=0;i&amp;lt;trList.length;i++) {
    var tdArr = trList.eq(i).find(&amp;quot;td&amp;quot;);
    var history_income_type = tdArr.eq(0).find(&amp;quot;input&amp;quot;).val();//收入类别
    var history_income_money = tdArr.eq(1).find(&amp;quot;input&amp;quot;).val();//收入金额
    var history_income_remark = tdArr.eq(2).find(&amp;quot;input&amp;quot;).val();//  备注
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JQ遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;#history_income_list&amp;quot;).find(&amp;quot;tr&amp;quot;).each(function(){
    var tdArr = $(this).children();
    var history_income_type = tdArr.eq(0).find(&amp;quot;input&amp;quot;).val();//收入类别
    var history_income_money = tdArr.eq(1).find(&amp;quot;input&amp;quot;).val();//收入金额
    var history_income_remark = tdArr.eq(2).find(&amp;quot;input&amp;quot;).val();//  备注
    ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Map集合遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//{&amp;quot;code&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;desc&amp;quot;:&amp;quot;操作成功&amp;quot;,&amp;quot;data&amp;quot;:{&amp;quot;shfwxt&amp;quot;:&amp;quot;售后服务系统&amp;quot;,&amp;quot;cs_win&amp;quot;:&amp;quot;测试_win&amp;quot;,&amp;quot;qdglxt&amp;quot;:&amp;quot;渠道管理系统&amp;quot;}}
success: function(result) {
    if(result.code == &#39;1&#39;){
        var data = result.data;
        var html = &amp;quot;&amp;lt;option selected=&#39;selected&#39; value=&#39;&#39;&amp;gt;请选择权限代码&amp;lt;/option&amp;gt;&amp;quot;;
        $.each(data, function (key, value) {
            html += &amp;quot;&amp;lt;option value= &#39;&amp;quot; + key + &amp;quot;&#39;&amp;gt;&amp;quot; + value +&amp;quot;(&amp;quot; + key+&amp;quot;)&amp;lt;/option&amp;gt;&amp;quot;;
        });
        $(&amp;quot;#permissionCode&amp;quot;).html(&#39;&#39;).append(html);
        layui.use(&#39;form&#39;, function() {
            var form = layui.form; //只有执行了这一步，部分表单元素才会自动修饰成功
            form.render();
        });
    }else{
        _msgShowToFunc(result.desc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;jquery-&#34;&gt;jquery $.&lt;/h3&gt;
&lt;h4 id=&#34;extend&#34;&gt;$.extend&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;//为jquery扩展了min,max两个方法
$.extend({ 
    min: function(a, b){return a &amp;lt; b?a:b; },
    max: function(a, b){return a &amp;gt; b?a:b; }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用扩展的方法（通过“$.方法名”调用）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alert(&amp;quot;a=10,b=20,max=&amp;quot;+$.max(10,20)+&amp;quot;,min=&amp;quot;+$.min(10,20));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;each&#34;&gt;$.each&lt;/h4&gt;
&lt;p&gt;$.each(obj, fn)：通用的迭代函数。可用于代替循环。 如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.each( [0,1,2], function(i, n){ alert( &amp;quot;Item #&amp;quot; + i + &amp;quot;: &amp;quot; + n ); });
//等价 
var tempArr=[0,1,2]; 
for(var i=0;i&amp;lt;tempArr.length;i++){ alert(&amp;quot;Item #&amp;quot;+i+&amp;quot;: &amp;quot;+tempArr[i]); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以处理json数据，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.each( { name: &amp;quot;John&amp;quot;, lang: &amp;quot;JS&amp;quot; }, function(i, n){ alert( &amp;quot;Name: &amp;quot; + i + &amp;quot;, Value: &amp;quot; + n ); });
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;map&#34;&gt;$.map&lt;/h4&gt;
&lt;p&gt;$.map(array, fn)：数组映射。把一个数组中的项目(处理转换后)保存到到另一个新数组中，并返回生成的新数组。 如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var tempArr=$.map( [0,1,2], function(i){ return i + 4; });//[4,5,6] 
var tempArr=$.map( [0,1,2], function(i){ return i &amp;gt; 0 ? i + 1 : null; });//[2,3] 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;merge&#34;&gt;$.merge&lt;/h4&gt;
&lt;p&gt;$.merge(arr1,arr2):合并两个数组并删除其中重复的项目。 如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.merge( [0,1,2], [2,3,4] ) //返回[0,1,2,3,4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;trim&#34;&gt;$.trim&lt;/h4&gt;
&lt;p&gt;$.trim(str)：删除字符串两端的空白字符。 如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.trim(&amp;quot; hello, how are you? &amp;quot;); //返回&amp;quot;hello,how are you? &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;js-获取数组长度&#34;&gt;JS 获取数组长度&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var myarray = [1,2,3];
myarray.length // 初始的长度是3
myarray.length = 2; // 删除最后一个元素
myarray.length = 20 // 添加18个元素到数组中
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;js-判断-undefined&#34;&gt;JS 判断 undefined&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;if(typeof(value)==&amp;quot;undefined&amp;quot;){ 
    alert(&amp;quot;undefined&amp;quot;); 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;js--join将数组转字符串&#34;&gt;JS  join将数组转字符串&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input class=&amp;quot;chcekInp&amp;quot; type=&amp;quot;checkbox&amp;quot; name=&amp;quot;nextDeal&amp;quot; value=&amp;quot;zs&amp;quot;/&amp;gt;张三
&amp;lt;input class=&amp;quot;chcekInp&amp;quot; type=&amp;quot;checkbox&amp;quot; name=&amp;quot;nextDeal&amp;quot; value=&amp;quot;ls&amp;quot;/&amp;gt;李四
&amp;lt;input class=&amp;quot;chcekInp&amp;quot; type=&amp;quot;checkbox&amp;quot; name=&amp;quot;nextDeal&amp;quot; value=&amp;quot;we&amp;quot;/&amp;gt;王二
&amp;lt;input class=&amp;quot;chcekInp&amp;quot; type=&amp;quot;checkbox&amp;quot; name=&amp;quot;nextDeal&amp;quot; value=&amp;quot;sw&amp;quot;/&amp;gt;三五
&amp;lt;input class=&amp;quot;chcekInp&amp;quot; type=&amp;quot;checkbox&amp;quot; name=&amp;quot;nextDeal&amp;quot; value=&amp;quot;sl&amp;quot;/&amp;gt;四六

var chk_value =[]; 
$(&#39;input[name=&amp;quot;nextDeal&amp;quot;]:checked&#39;).each(function(){ 
    chk_value.push($(this).val()); 
});
var userNames = chk_value.join(&amp;quot;,&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;js-遮罩功能&#34;&gt;JS 遮罩功能&lt;/h3&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--弹窗背景--&amp;gt;
&amp;lt;div class=&amp;quot;flexBg&amp;quot; style=&amp;quot;display: none;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!--loading--&amp;gt;
&amp;lt;div class=&amp;quot;loading&amp;quot; style=&amp;quot;display: none;&amp;quot;&amp;gt;
    &amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;
    &amp;lt;p&amp;gt;加载中...&amp;lt;/p&amp;gt;
    &amp;lt;%-- &amp;lt;img src=&amp;quot;${baseURL}/images/loading.gif&amp;quot;&amp;gt;&amp;lt;/img&amp;gt; --%&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.flexBg {
    background: url(../images/flexBg.png);
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 999;
}
.loading {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 50%;
    left: 50%;
    margin: -50px 0 0 -50px;
    z-index: 999;
    background: #fff;
    padding: 15px;
    border-radius: 5px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function sZZ(){
    $(&#39;.flexBg&#39;).show();
    $(&#39;.loading&#39;).show();
}
function hZZ(){
    $(&#39;.flexBg&#39;).hide();
    $(&#39;.loading&#39;).hide();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IMG&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/flexBg.png&#34; data-size=&#34;342x265&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/flexBg_hu55beb7d244ae006d6812867a459c4d45_119_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/flexBg_hu55beb7d244ae006d6812867a459c4d45_119_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/flexBg.png&#34; width=&#34;342&#34; height=&#34;265&#34; loading=&#34;lazy&#34;
				alt=&#34;&amp;nbsp;&#34;&gt;
		&lt;/a&gt;
		
	&lt;/figure&gt;&lt;br&gt;
&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/loading.gif&#34; data-size=&#34;128x128&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/loading_hu45a832759e9abc2132bd929882f39581_3897_480x0_resize_box.gif 480w, https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/loading_hu45a832759e9abc2132bd929882f39581_3897_1024x0_resize_box.gif 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/loading.gif&#34; width=&#34;128&#34; height=&#34;128&#34; loading=&#34;lazy&#34;
				alt=&#34;&amp;nbsp;&#34;&gt;
		&lt;/a&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;js中的encodeuridecodeuridecodeuricomponent解决传值中文乱码&#34;&gt;js中的encodeURI、decodeURI、decodeURIComponent,解决传值中文乱码&lt;/h3&gt;
&lt;p&gt;一、基本概念&lt;br&gt;
encodeURI和decodeURI是成对来使用的，因为浏览器的地址栏有中文字符的话，可以会出现不可预期的错误，所以可以encodeURI把非英文字符转化为英文编码，decodeURI可以用来把字符还原回来。&lt;br&gt;
encodeURI方法不会对下列字符进行编码：&amp;quot;:&amp;quot;、&amp;quot;/&amp;quot;、&amp;quot;;&amp;quot; 和 &amp;ldquo;?&amp;quot;，encodeURIComponent方法可以对这些字符进行编码。&lt;/p&gt;
&lt;p&gt;decodeURI()方法相当于java.net.URLDecoder.decode(URIString, &amp;ldquo;UTF-8&amp;rdquo;);&lt;br&gt;
encodeURI()方法相当于java.net.URLEncoder.encode(URIString, &amp;ldquo;UTF-8&amp;rdquo;);&lt;br&gt;
二、例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.location.href = encodeURI(encodeURI(jumpURL));
//http://127.0.0.1:8081/zsyx/jsp/component/demandwork/functiontest/functiontest.jsp?id=NEW20183123134021852&amp;amp;slink=%25E9%259C%2580%25E6%25B1%2582%25E5%25A4%2584%25E7%2590%2586

var slink = decodeURI(decodeURI(&#39;${param.slink}&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;js判断文件是否存在&#34;&gt;JS判断文件是否存在&lt;/h3&gt;
&lt;p&gt;方法1：判断图片是否存在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function isHasImg(pathImg){  
    var ImgObj=new Image();  
    ImgObj.src= pathImg;  
    if(ImgObj.fileSize &amp;gt; 0 || (ImgObj.width &amp;gt; 0 &amp;amp;&amp;amp; ImgObj.height &amp;gt; 0))  
    {  
    return true;  
    } else {  
    return false;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法2：AJAX验证图片或文件链接是否存在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function validateImage(url) {      
var xmlHttp ;  
if (window.ActiveXObject)  
{  
xmlHttp = new ActiveXObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;);  
}  
else if (window.XMLHttpRequest)  
{  
xmlHttp = new XMLHttpRequest();  
}   
xmlHttp.open(&amp;quot;Get&amp;quot;,url,false);  
xmlHttp.send();  
if(xmlHttp.status==404)  
return false;  
else  
return true;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法3：用onerror替换不存在的图片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;images/img1.jpg&amp;quot; height=&amp;quot;300&amp;quot; width=&amp;quot;800&amp;quot; onerror=&amp;quot;images/defaultImg.jpg&amp;quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;解决自定义方法或其他类库与jquery的冲突&#34;&gt;解决自定义方法或其他类库与jQuery的冲突&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//使用jquery中的jQuery.noConflict();方法即可把变量$的控制权让渡给第一个实现它的那个库或之前自定义的$方法。之后应用Jquery的时候只要将所有的$换成jQuery即可
jQuery.noConflict(); 
// 开始使用jQuery 
jQuery(&amp;quot;div p&amp;quot;).hide(); 
// 使用其他库的 $() 
$(&amp;quot;content&amp;quot;).style.display = &#39;none&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;获取iframe中文档内容&#34;&gt;获取iframe中文档内容&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function getIframeContent(){  //获取iframe中文档内容
    var doc;
    if (document.all){ // IE 
        doc = document.frames[&amp;quot;ueditor_0&amp;quot;].document; 
    }else{ // 标准
        doc = document.getElementById(&amp;quot;ueditor_0&amp;quot;).contentDocument; 
    }
    return doc.body.innerHTML;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;子窗体调父窗体方法&#34;&gt;子窗体调父窗体方法&lt;/h3&gt;
&lt;p&gt;父窗体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function selectProduct(commitBrand){	window.open(&amp;quot;${baseURL}/jsp/component/selectlist/SelectProductList.jsp?ecs=ecs&amp;amp;productName=productName&amp;amp;brandId=brandId&amp;amp;brandName=brandName&amp;amp;specification=specification&amp;quot;,&amp;quot;选择产品&amp;quot;,
        &amp;quot;width=1366,height=768,top=0,left=0,scrollbars=YES,resizable=yes&amp;quot;);
}
function setProductValue(ecs,productName,brandId,brandNameDesc,guige,guigeDesc,color,colorDesc,productXinghao,productXinghaoDesc,haveImei,fundCost){
        $(&amp;quot;#ecs&amp;quot;).attr(&amp;quot;value&amp;quot;,ecs);
        $(&amp;quot;#productName&amp;quot;).attr(&amp;quot;value&amp;quot;,productName);
        $(&amp;quot;#brandId&amp;quot;).attr(&amp;quot;value&amp;quot;,brandId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子窗体 SelectProductList.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.opener.setProductValue(content.ecs,content.productName,content.zhongduanPinpai,content.zhongduanPinpaiDesc,content.guige,content.guigeDesc,content.color,content.colorDesc,content.productXinghao,content.productXinghaoDesc,content.haveImei,content.fundCost);
window.close();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;jq-ajax请求demo&#34;&gt;JQ AJAX请求demo&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    $(&#39;#send&#39;).click(function() {
        $.ajax({
            type: &amp;quot;GET&amp;quot;, //GET或POST,
            async:true, //默认设置为true，所有请求均为异步请求。
            url: &amp;quot;http://www.idaima.com/xxxxx.php&amp;quot;,
            data: {
                username: $(&amp;quot;#username&amp;quot;).val(),
                content: $(&amp;quot;#content&amp;quot;).val()
            },
            dataType: &amp;quot;json&amp;quot;, //xml、html、script、jsonp、text
            beforeSend:function(){},
            complete:function(){},
            success: function(data) {
                alert(data)
            },
            error:function(){},
        });
    });
});


$.get(baseURL+&#39;/childorderdeal/childorderdealActAction!getWorkSati.action&#39;, { orderId: &amp;quot;NEW2018425164215552&amp;quot; }, function(data){
             if(data.code==&amp;quot;0&amp;quot;){
                 $(&#39;input:[value=&amp;quot;&#39;+data.data.code+&#39;&amp;quot;]&#39;).attr(&#39;checked&#39;,&#39;true&#39;);
             }
        },&#39;json&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;jq-设置ajax同步&#34;&gt;JQ 设置AJAX同步&lt;/h3&gt;
&lt;p&gt;由于$.post() 和 $.get() 默认是 异步请求，如果需要同步请求，则可以进行如下使用：&lt;br&gt;
在$.post()前把ajax设置为同步：$.ajaxSettings.async = false;&lt;br&gt;
在$.post()后把ajax改回为异步：$.ajaxSettings.async = true;&lt;br&gt;
如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.ajaxSettings.async = false;  
$.post(&amp;quot;/finance/getLastTimeCard&amp;quot;, data, function(result) {  
    // 请求处理  
},&amp;quot;json&amp;quot;);  
$.ajaxSettings.async = true;  
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;页面刷新篇&#34;&gt;页面刷新篇&lt;/h3&gt;
&lt;p&gt;1.刷新&lt;br&gt;
reload 方法，该方法强迫浏览器刷新当前页面。&lt;br&gt;
语法：location.reload([bForceGet]) &lt;br&gt;
参数： bForceGet， 可选参数， 默认为 false，从客户端缓存里取当前页。true, 则以 GET 方式，从服务端取最新的页面, 相当于客户端点击 F5(&amp;ldquo;刷新&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;replace 方法，该方法通过指定URL替换当前缓存在历史里（客户端）的项目，因此当使用replace方法之后，你不能通过“前进”和“后退”来访问已经被替换的URL。&lt;br&gt;
语法： location.replace(URL)&lt;/p&gt;
&lt;p&gt;在实际应用的时候，重新刷新页面的时候，我们通常使用： &lt;!-- raw HTML omitted --&gt;location.reload()&lt;!-- raw HTML omitted --&gt; 或者是 &lt;!-- raw HTML omitted --&gt;history.go(0) &lt;!-- raw HTML omitted --&gt;来做。&lt;br&gt;
因为这种做法就像是客户端点F5刷新页面，所以页面的method=&amp;ldquo;post&amp;quot;的时候，会出现&amp;quot;网页过期&amp;quot;的提示。那是因为Session的安全保护机制。&lt;br&gt;
这里，location.replace() 就可以完成此任务。被replace的页面每次都在服务端重新生成。&lt;br&gt;
你可以这么写： &lt;!-- raw HTML omitted --&gt;location.replace(location.href)&lt;!-- raw HTML omitted --&gt;;&lt;/p&gt;
&lt;p&gt;2.返回并刷新页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location.replace(document.referrer); //document.referre为r前一个页面的URL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不要用 history.go(-1)，或 history.back();来返回并刷新页面，这两种方法不会刷新页面。&lt;/p&gt;
&lt;h4 id=&#34;javascript刷新页面的几种方法&#34;&gt;Javascript刷新页面的几种方法&lt;/h4&gt;
&lt;p&gt;1    history.go(0)&lt;br&gt;
2    location.reload()&lt;br&gt;
3    location=location&lt;br&gt;
4    location.assign(location)&lt;br&gt;
5    document.execCommand(&amp;lsquo;Refresh&amp;rsquo;)&lt;br&gt;
6    window.navigate(location)&lt;br&gt;
7    location.replace(location)&lt;br&gt;
8    document.URL=location.href&lt;/p&gt;
&lt;h4 id=&#34;自动刷新页面的方法&#34;&gt;自动刷新页面的方法&lt;/h4&gt;
&lt;p&gt;1.页面自动刷新：把如下代码加入&lt;!-- raw HTML omitted --&gt;区域中,20秒刷新一次页面.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;20&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.页面自动跳转：把如下代码加入&lt;!-- raw HTML omitted --&gt;区域中,20秒后跳转到https://ianeiu.github.io/页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;20;url=https://ianeiu.github.io/&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.页面自动刷新js版&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; 
    function myrefresh(){  window.location.reload(); }
    setTimeout(&#39;myrefresh()&#39;,1000); //指定1秒刷新一次
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;窗口刷新&#34;&gt;窗口刷新&lt;/h4&gt;
&lt;p&gt;1.JS刷新框架的脚本语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//如何刷新包含该框架的页面用   
&amp;lt;script language=JavaScript&amp;gt;
   parent.location.reload();
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.子窗口刷新父窗口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script language=JavaScript&amp;gt;
    self.opener.location.reload();
&amp;lt;/script&amp;gt;
//或　&amp;lt;a href=&amp;quot;javascript:opener.location.reload()&amp;quot;&amp;gt;刷新&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.如何刷新另一个框架的页面用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script language=JavaScript&amp;gt;
   parent.另一FrameID.location.reload();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.如果想关闭窗口时刷新或者想开窗时刷新的话，在&lt;!-- raw HTML omitted --&gt;中调用以下语句即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body onload=&amp;quot;opener.location.reload()&amp;quot;&amp;gt; 开窗时刷新
&amp;lt;body onUnload=&amp;quot;opener.location.reload()&amp;quot;&amp;gt; 关闭时刷新
&amp;lt;script language=&amp;quot;javascript&amp;quot;&amp;gt;
    window.opener.document.location.reload()
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;jquery对象与dom对象&#34;&gt;jQuery对象与dom对象&lt;/h3&gt;
&lt;p&gt;通过jquery的$()引用元素包括通过id、class、元素名以及元素的层级关系及dom或者xpath条件等方法，且返回的对象为jquery对象（集合对象），不能直接调用dom定义的方法。&lt;br&gt;
转换&lt;br&gt;
普通的dom对象一般可以通过$()转换成jquery对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document.getElementById(&amp;quot;msg&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于jquery对象本身是一个集合。所以如果jquery对象要转换为dom对象则必须取出其中的某一项，一般可通过索引取出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;#msg&amp;quot;)[0]，
$(&amp;quot;div&amp;quot;).eq(1)[0]，
$(&amp;quot;div&amp;quot;).get()[1]，
$(&amp;quot;td&amp;quot;)[5]

$(&amp;quot;#msg&amp;quot;).html();
$(&amp;quot;#msg&amp;quot;)[0].innerHTML;
$(&amp;quot;#msg&amp;quot;).eq(0)[0].innerHTML;
$(&amp;quot;#msg&amp;quot;).get(0).innerHTML;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取jQuery集合的某一项(获取第三个div元素的内容)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;div&amp;quot;).eq(2).html(); //调用jquery对象的方法
$(&amp;quot;div&amp;quot;).get(2).innerHTML; //调用dom的方法属性
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;form表单-注意点&#34;&gt;form表单 注意点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;查询页面，有绑定回车事件提交表单的，要在form中加上onsubmit=&amp;ldquo;return false;&amp;quot;。不然会出现回车查询时页面直接显示JSON数据了。&lt;/li&gt;
&lt;li&gt;直接在form标签中加入属性accept-charset=&amp;lsquo;UTF-8&amp;rsquo;,防止中文乱码。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;js-截取字符串&#34;&gt;js 截取字符串&lt;/h3&gt;
&lt;h4 id=&#34;去除字符串最后一位进化版&#34;&gt;去除字符串最后一位(进化版)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;SCRIPT type=&amp;quot;text/javascript&amp;quot;&amp;gt;
	function delfh(str){
		str=str.replace(&amp;quot;,,&amp;quot;,&amp;quot;,&amp;quot;);
		if(str.substring(str.length-1,str.length)==&amp;quot;,&amp;quot;){
			str2=str.substring(0,str.length-1);
			delfh(str2);
		}else{
			str2=str;
		}
		return str2;
	}
 
	var s2=&amp;quot;1,,,2,,,,3,,,,4,54,454,,,,,,,,,,,,,,,,&amp;quot;;
	var s=&amp;quot;415929,415930,415931,415932,415933,415934,415935,415936,415937,415938,415939,415940,415941,415942,415943,415944,415945,415946,415947,415948,1,2,3&amp;quot;;
	alert(delfh(s2));
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;元素上下居中&#34;&gt;元素上下居中&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
.parent {
	display: flex;
	flex-direction: column;
	justify-content: center; /* 上下 */
	align-items: center; /* 水平 */
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&amp;quot;parent&amp;quot; style=&amp;quot;height: 1000px; border: 1px solid #000&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;child&amp;quot; style=&amp;quot;height: 500px; width: 100px; border: 1px solid #00f&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;检查ie&#34;&gt;检查IE&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; /* 注意：不能使用较新的jquery */
    /* $.browser.msie在1.9以后的jquery中不存在了 */
    /* 2.0 版本中，将不再支持 IE 6/7/8 */
    $(function() {
    	 checkOne();
    	 checkTwo();
    });
    
    function checkOne(){
    	 var userAgent = window.navigator.userAgent.toLowerCase();
    	  
         $.browser.msie10 = $.browser.msie &amp;amp;&amp;amp; /msie 10\.0/i.test(userAgent);
         $.browser.msie9 = $.browser.msie &amp;amp;&amp;amp; /msie 9\.0/i.test(userAgent); 
         $.browser.msie8 = $.browser.msie &amp;amp;&amp;amp; /msie 8\.0/i.test(userAgent);
         $.browser.msie7 = $.browser.msie &amp;amp;&amp;amp; /msie 7\.0/i.test(userAgent);
         $.browser.msie6 = !$.browser.msie8 &amp;amp;&amp;amp; !$.browser.msie7 &amp;amp;&amp;amp; $.browser.msie &amp;amp;&amp;amp; /msie 6\.0/i.test(userAgent);
   
         $(&amp;quot;.info&amp;quot;).html(
             &amp;quot;&amp;lt;h3&amp;gt;userAgent:&amp;lt;/h3&amp;gt;&amp;quot; + userAgent + &amp;quot;&amp;lt;br /&amp;gt;&amp;quot; +
             &amp;quot;&amp;lt;h3&amp;gt;Is IE 10?&amp;lt;/h3&amp;gt;&amp;quot; + $.browser.msie10 +
             &amp;quot;&amp;lt;h3&amp;gt;Is IE 9?&amp;lt;/h3&amp;gt;&amp;quot; + $.browser.msie9 +
             &amp;quot;&amp;lt;h3&amp;gt;Is IE 8?&amp;lt;/h3&amp;gt;&amp;quot; + $.browser.msie8 +
             &amp;quot;&amp;lt;h3&amp;gt;Is IE 7?&amp;lt;/h3&amp;gt;&amp;quot; + $.browser.msie7 +
             &amp;quot;&amp;lt;h3&amp;gt;Is IE 6?&amp;lt;/h3&amp;gt;&amp;quot; + $.browser.msie6
         );
 		if($.browser.msie8){
 			alert(&#39;IE8真让人头疼！！&#39;);
 		}
    }
    
    //new 
    function checkTwo(){
    	$.browser.mozilla = /firefox/.test(navigator.userAgent.toLowerCase());
    	$.browser.webkit = /webkit/.test(navigator.userAgent.toLowerCase());
    	$.browser.opera = /opera/.test(navigator.userAgent.toLowerCase());
    	$.browser.msie = /msie/.test(navigator.userAgent.toLowerCase()); //判断是否是IE
    	
   	 	if(/msie/.test(navigator.userAgent.toLowerCase())){
   	    	console.log(&#39;IE5-10&#39;);
   	 	}
    	
		if (&#39;undefined&#39; == typeof (document.body.style.maxHeight)) {
			console.log(&#39;IE6&#39;);
		}
		
		if (!$.support.leadingWhitespace) {
			console.log(&#39;IE5-8&#39;);
		}
    }
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;文件上传限制&#34;&gt;文件上传限制&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;限制文件类型上传及多文件上传&amp;lt;/h3&amp;gt;
    &amp;lt;input id=&amp;quot;moreFile&amp;quot; type=&amp;quot;file&amp;quot; accept=&amp;quot;.doc,.docx,.xls,.xlsx&amp;quot;
        multiple /&amp;gt; &amp;lt;input type=&amp;quot;button&amp;quot; onclick=&amp;quot;checkFile()&amp;quot; value=&amp;quot;提交&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;限制文件类型上传-显示限制&amp;lt;/h3&amp;gt;
    &amp;lt;br /&amp;gt;浏览时只显示指定文件类型 xls、xlsx、csv &amp;lt;input id=&amp;quot;fileSelect&amp;quot; type=&amp;quot;file&amp;quot;
        accept=&amp;quot;.csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel&amp;quot; /&amp;gt;

    &amp;lt;br /&amp;gt;
    &amp;lt;br /&amp;gt;For CSV files (.csv), use: &amp;lt;br /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;.csv&amp;quot; /&amp;gt; &amp;lt;br /&amp;gt;
    &amp;lt;br /&amp;gt;For Excel Files 2003-2007 (.xls), use: &amp;lt;br /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;application/vnd.ms-excel&amp;quot; /&amp;gt; &amp;lt;br /&amp;gt;
    &amp;lt;br /&amp;gt;For Excel Files 2010 (.xlsx), use: &amp;lt;br /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&amp;quot; /&amp;gt;
    &amp;lt;br /&amp;gt;
    &amp;lt;br /&amp;gt;For Text Files (.txt) use: &amp;lt;br /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;text/plain&amp;quot; /&amp;gt; &amp;lt;br /&amp;gt;
    &amp;lt;br /&amp;gt;For Image Files (.png/.jpg/etc), use: &amp;lt;br /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;image/*&amp;quot; /&amp;gt; &amp;lt;br /&amp;gt;
    &amp;lt;br /&amp;gt;For HTML Files (.htm,.html), use: &amp;lt;br /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;text/html&amp;quot; /&amp;gt; &amp;lt;br /&amp;gt;
    &amp;lt;br /&amp;gt;For Video Files (.avi, .mpg, .mpeg, .mp4), use: &amp;lt;br /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;video/*&amp;quot; /&amp;gt; &amp;lt;br /&amp;gt;
    &amp;lt;br /&amp;gt;For Audio Files (.mp3, .wav, etc), use: &amp;lt;br /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;audio/*&amp;quot; /&amp;gt; &amp;lt;br /&amp;gt;
    &amp;lt;br /&amp;gt;For PDF Files, use: &amp;lt;br /&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;.pdf&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
	function checkFile(){
		var fileAccept = $(&amp;quot;#moreFile&amp;quot;).val().split(&amp;quot;.&amp;quot;)[1];//获取上传文件的后缀  
		if( fileAccept!=&amp;quot;doc&amp;quot; &amp;amp;&amp;amp; fileAccept!=&amp;quot;docx&amp;quot;&amp;amp;&amp;amp; fileAccept!=&amp;quot;xls&amp;quot;&amp;amp;&amp;amp; fileAccept!=&amp;quot;xlsx&amp;quot; ){  
		    alert(&amp;quot;只能上传.doc,.docx,.xls,.xlsx的文件！&amp;quot;);  
		}  
		
		//获取多文件上传的所有文件名  
		var filePaths = $(&amp;quot;#moreFile&amp;quot;)[0].files;//或者这样写 document.getElementById(&amp;quot;id&amp;quot;).files;  
		for( var i=0;i&amp;lt;filePaths.length; i++ ){  
		    alert(filePaths[i].name);  
		}
	}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;输入框input校验&#34;&gt;输入框input校验&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;br /&amp;gt;JS判断只能是数字和小数点 1.文本框只能输入数字代码(小数点也不能输入)
&amp;lt;br /&amp;gt;
&amp;lt;input onkeyup=&amp;quot;this.value=this.value.replace(/\D/g,&#39;&#39;)&amp;quot; onafterpaste=&amp;quot;this.value=this.value.replace(/\D/g,&#39;&#39;)&amp;quot;&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;br /&amp;gt;2.只能输入数字,能输小数点.
&amp;lt;br /&amp;gt;
&amp;lt;input onkeyup=&amp;quot;if(isNaN(value))execCommand(&#39;undo&#39;)&amp;quot; onafterpaste=&amp;quot;if(isNaN(value))execCommand(&#39;undo&#39;)&amp;quot;&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;input name=txt1 onchange=&amp;quot;if(/\D/.test(this.value)){alert(&#39;只能输入数字&#39;);this.value=&#39;&#39;;}&amp;quot;&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;br /&amp;gt;3.数字和小数点方法二
&amp;lt;br /&amp;gt;
&amp;lt;input type=text t_value=&amp;quot;&amp;quot; o_value=&amp;quot;&amp;quot;
    onkeypress=&amp;quot;if(!this.value.match(/^[\+\-]?\d*?\.?\d*?$/))this.value=this.t_value;else this.t_value=this.value;if(this.value.match(/^(?:[\+\-]?\d+(?:\.\d+)?)?$/))this.o_value=this.value&amp;quot;
    onkeyup=&amp;quot;if(!this.value.match(/^[\+\-]?\d*?\.?\d*?$/))this.value=this.t_value;else this.t_value=this.value;if(this.value.match(/^(?:[\+\-]?\d+(?:\.\d+)?)?$/))this.o_value=this.value&amp;quot;
    onblur=&amp;quot;if(!this.value.match(/^(?:[\+\-]?\d+(?:\.\d+)?|\.\d*?)?$/))this.value=this.o_value;else{if(this.value.match(/^\.\d+$/))this.value=0+this.value;if(this.value.match(/^\.$/))this.value=0;this.o_value=this.value}&amp;quot;&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;br /&amp;gt;4.只能输入字母和汉字
&amp;lt;br /&amp;gt;
&amp;lt;input onkeyup=&amp;quot;value=value.replace(/[\d]/g,&#39;&#39;)&amp;quot; maxlength=10 name=&amp;quot;Numbers&amp;quot;
    onbeforepaste=&amp;quot;clipboardData.setData(&#39;text&#39;,clipboardData.getData(&#39;text&#39;).replace(/[\d]/g,&#39;&#39;))&amp;quot;&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;br /&amp;gt;5.只能输入英文字母和数字,不能输入中文
&amp;lt;br /&amp;gt;
&amp;lt;input onkeyup=&amp;quot;value=value.replace(/[^\w\.\/]/ig,&#39;&#39;)&amp;quot;&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;br /&amp;gt;6.只能输入数字和英文
&amp;lt;font color=&amp;quot;Red&amp;quot;&amp;gt;chun&amp;lt;/font&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;input onKeyUp=&amp;quot;value=value.replace(/[^\d|chun]/g,&#39;&#39;)&amp;quot;&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;br /&amp;gt;7.小数点后只能有最多两位(数字,中文都可输入),不能输入字母和运算符号:
&amp;lt;br /&amp;gt;
&amp;lt;input onKeyPress=&amp;quot;if((event.keyCode&amp;lt;48 || event.keyCode&amp;gt;57) &amp;amp;&amp;amp; event.keyCode!=46 || /\.\d\d$/.test(value))event.returnValue=false&amp;quot;&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;br /&amp;gt;8.小数点后只能有最多两位(数字,字母,中文都可输入),可以输入运算符号:
&amp;lt;br /&amp;gt;
&amp;lt;input onkeyup=&amp;quot;this.value=this.value.replace(/^(\-)*(\d+)\.(\d\d).*$/,&#39;$1$2.$3&#39;)&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;contenteditable-进行文本输入编辑&#34;&gt;contenteditable 进行文本输入编辑&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p contenteditable=&amp;quot;true&amp;quot;&amp;gt;这是一段可编辑的段落。请试着编辑该文本。&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;table-模版&#34;&gt;table 模版&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table class=&amp;quot;tableCommon&amp;quot; width=&amp;quot;30%&amp;quot; border=&amp;quot;1&amp;quot; cellspacing=&amp;quot;5&amp;quot; cellpadding=&amp;quot;10&amp;quot;&amp;gt;
    &amp;lt;thead style=&amp;quot;display: block;&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;1&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;2&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;3&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;4&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody style=&amp;quot;display: block; height: 50px; overflow-y: scroll;&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;10&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;30&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;40&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;10&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;30&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;40&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;append追加元素用法例子&#34;&gt;append追加元素用法例子&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul class=&amp;quot;selectUserList&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
	$(function(){
		for(var i = 0;i&amp;lt;10;i++){
			addUser({id: i, userName: i+&#39;a&#39;, name: i+&#39;b&#39;,mobile: i*10});
		}
	})
	function addUser(data) {
	    var _li = $(&amp;quot;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;);//li
	    var _em = $(&amp;quot;&amp;lt;em&amp;gt;&amp;lt;/em&amp;gt;&amp;quot;);//li-em
	    var _a = $(&#39;&amp;lt;a class=&amp;quot;closebtn&amp;quot; href=&amp;quot;javascript:void(0);&amp;quot; onclick=&amp;quot;closeBtnFunc(this)&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&#39;);//li-a
	    var _hiden_username = $(&#39;&amp;lt;input type=&amp;quot;hidden&amp;quot; class=&amp;quot;_hidenUsername&amp;quot;/&amp;gt;&#39;);//li-input name:_hidenUsername
	    var _hiden_tel = $(&#39;&amp;lt;input type=&amp;quot;hidden&amp;quot; class=&amp;quot;_hidenMobile&amp;quot;/&amp;gt;&#39;);//li-input name:_hiden_tel
	    
	    _hiden_username.val(data.userName);
	    _hiden_tel.val(data.mobile);
	    _em.text(data.userName + &amp;quot;(&amp;quot; + data.mobile + &amp;quot;)&amp;quot;);
	    
	    _li.append(_em);
	    _li.append(_a);
	    _li.append(_hiden_username);
	    _li.append(_hiden_tel);
	    $(&amp;quot;.selectUserList&amp;quot;).append(_li);
	}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;a标签-调用方法的正确姿势&#34;&gt;a标签 调用方法的正确姿势&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:xixi();&amp;quot;&amp;gt;a1&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;br&gt;
这是我们平台上常用的方法，但是这种方法在传递this等参数的时候很容易出问题，&lt;br&gt;
而且javascript:协议作为a的href属性的时候不仅会导致不必要的触发window.onbeforeunload事件，&lt;br&gt;
在IE里面更会使gif动画图片停止播放。&lt;br&gt;
W3C标准不推荐在href里面执行javascript语句&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:void(0);&amp;quot; onclick=&amp;quot;xixi()&amp;quot;&amp;gt;a2&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;br&gt;
这种方法是很多网站最常用的方法，也是最周全的方法，onclick方法负责执行js函数，&lt;br&gt;
而void是一个操作符，void(0)返回undefined，地址不发生跳转。&lt;br&gt;
而且这种方法不会像第一种方法一样直接将js方法暴露在浏览器的状态栏。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:;&amp;quot; onclick=&amp;quot;xixi()&amp;quot;&amp;gt;a3&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;br&gt;
这种方法跟跟2种类似，区别只是执行了一条空的js代码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;xixi()&amp;quot;&amp;gt;a4&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;br&gt;
这种方法也是网上很常见的代码，#是标签内置的一个方法，代表top的作用。&lt;br&gt;
所以用这种方法点击后网页后返回到页面的最顶端。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;xixi();return false&amp;quot;&amp;gt;a5&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;br&gt;
这种方法点击执行了js函数后return false，页面不发生跳转，执行后还是在页面的当前位置。&lt;/p&gt;
&lt;p&gt;综合上述，在a中调用js函数最适当的方法推荐使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:void(0);&amp;quot; onclick=&amp;quot;xixi()&amp;quot;&amp;gt;a2&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;
&amp;lt;a href=&amp;quot;javascript:;&amp;quot; onclick=&amp;quot;xixi()&amp;quot;&amp;gt;a3&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;
&amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;xixi();return false&amp;quot;&amp;gt;a5&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;video-h5播放视频不主动弹出&#34;&gt;video h5播放视频不主动弹出&lt;/h3&gt;
&lt;p&gt;x5-playsinline=&amp;ldquo;true&amp;rdquo; playsinline=&amp;ldquo;true&amp;rdquo; webkit-playsinline=&amp;ldquo;true&amp;rdquo;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java笔记之基础篇</title>
        <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
        <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
        <description>&lt;img src="https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/matt-le-SJSpo9hQf7s-unsplash.jpg" alt="Featured image of post Java笔记之基础篇" /&gt;&lt;p&gt;Java基础笔记整理&lt;/p&gt;
&lt;h2 id=&#34;关键字&#34;&gt;关键字&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用于定义数据类型
&lt;ul&gt;
&lt;li&gt;class interface  【引用数据类型：类、接口、数组】&lt;/li&gt;
&lt;li&gt;boolean(1) char(2) byte(1) short(2) int(4) long(8) float(4) double(8) 【8个内置数据类型】&lt;br&gt;
类型转换：&lt;br&gt;
byte→short→int→→(可能丢失精度)float→→(可能丢失精度)long→→(可能丢失精度)double&lt;br&gt;
char→int&lt;br&gt;
int→long&lt;br&gt;
int→double&lt;br&gt;
float→double&lt;/li&gt;
&lt;li&gt;void&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于定义数据类型值
&lt;ul&gt;
&lt;li&gt;true false null&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于定义流程控制
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if else switch case default【选择】&lt;br&gt;
【switch jdk5前：case byte\short\int\char。jdk5：case：enum。jdk7：case String】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;while do for【循环】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;break continue return【流程跳转】&lt;/p&gt;
&lt;p&gt;直接for循环效率最高，其次是迭代器和 ForEach操作。作为语法糖，ForEach底层是使用迭代器实现，反编译后testForEach方法如下，可以看到，只比迭代器遍历多了生成中间变量这一步，因为性能也略微下降了一些。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void testForEach(List list) {  
    for (Iterator iterator = list.iterator(); iterator.hasNext();) {  
        Object t = iterator.next();  
        Object obj = t;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于定义访问权限修饰符
&lt;ul&gt;
&lt;li&gt;private public protected&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于定义类、函数、变量
&lt;ul&gt;
&lt;li&gt;abstract final static synchronized&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类与类之间的关系
&lt;ul&gt;
&lt;li&gt;extends implements&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建立实例、引用实例、判断实例
&lt;ul&gt;
&lt;li&gt;new this super instanceof&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异常处理
&lt;ul&gt;
&lt;li&gt;try catch throw throws finally&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;包
&lt;ul&gt;
&lt;li&gt;package import&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其它
&lt;ul&gt;
&lt;li&gt;native strictfp transient volatile assert&lt;/li&gt;
&lt;li&gt;保留字 goto const&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标识符&#34;&gt;标识符&lt;/h2&gt;
&lt;p&gt;类、接口、方法、变量的名字&lt;br&gt;
合法字符组成：英文字母、数字、$、_【不能以数字开头】&lt;/p&gt;
&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单行 //&lt;/li&gt;
&lt;li&gt;多行 /**/&lt;/li&gt;
&lt;li&gt;文档 /**  */&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;字面值 &amp;ldquo;hello&amp;rdquo;,10.true&lt;/li&gt;
&lt;li&gt;自定义 final int LINK_CODE = 0;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;final 修饰变量（基本类型值不变，引用类型地址值不变）（只能在构造方法执行之前赋值一次）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类变量（静态变量）&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;实例变量（成员变量）&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;局部变量（本地变量）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;位置（代码）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;类中&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;类中方法外&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;方法定义中、方法声明上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;位置（内存）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;方法区中静态区&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;堆&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;生命周期&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;随类加载而加载&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;随对象&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;随方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;this无法存在静态中；&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;静态方法只能访问静态变量&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;运算符&#34;&gt;运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;% + - * / ++  --
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;= += -= *= /= %=
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;比较运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;== != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;= 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;amp; | ^(异或) ! &amp;amp;&amp;amp; || 【&amp;amp;&amp;amp; || 有短路效果】
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;位运算符&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;
&amp;laquo; &amp;raquo; &amp;raquo;&amp;gt;(无符号右移) &amp;amp; | ^ ~(按位取反)
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三元运算符&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;
max = a &amp;gt; b ? a : b
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码块&#34;&gt;代码块&lt;/h2&gt;
&lt;p&gt;代码块加载顺序： 静态代码块（类初始化）&amp;ndash;&amp;gt; 局部代码块 &amp;ndash;&amp;gt; 构造代码块（对象初始化）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Importtant06Code {
    static { System.out.println(&amp;quot;Importtant06Code静态代码块&amp;quot;);}
	
    public static void main(String[] args) {
        System.out.println(&amp;quot;main&amp;quot;);
        User user = new User();
        User user2 = new User();
    }
}

class User{
    static { System.out.println(&amp;quot;User静态代码块&amp;quot;);}
    {System.out.println(&amp;quot;User局部代码块&amp;quot;);}
    public User() {System.out.println(&amp;quot;User构造代码块&amp;quot;);}
	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Importtant06Code静态代码块
main
User静态代码块
User局部代码块
User构造代码块
User局部代码块
User构造代码块
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;java面向对象三大特性&#34;&gt;Java面向对象三大特性&lt;/h2&gt;
&lt;p&gt;封装、继承、多态&lt;/p&gt;
&lt;h2 id=&#34;类与对象&#34;&gt;类与对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类：一组相关属性和行为的集合（抽象）&lt;/li&gt;
&lt;li&gt;对象：改类事物的具体表现形式（具体存在的个体）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;封装&#34;&gt;封装&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口&lt;br&gt;
好处：隐藏实现细节,提供公共访问方式，复用性，安全性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键字：private、this、static、new&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;userName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;wm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Demo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对象构造过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将User.class文件加载到内存&lt;/li&gt;
&lt;li&gt;栈内存放置user，堆内存放置对象&lt;/li&gt;
&lt;li&gt;给成员变量进行初始化
&lt;ul&gt;
&lt;li&gt;默认初始化 name:null  age:0&lt;/li&gt;
&lt;li&gt;显示初始化 name:wm    age:18&lt;/li&gt;
&lt;li&gt;构造初始化 name:sg    age:25&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将地址值赋给变量user&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;从已有类得到继承信息创建新类的过程&lt;br&gt;
好处：复用、维护、多态前提&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键字：extends、this、super&lt;/p&gt;
&lt;h4 id=&#34;重载与重写&#34;&gt;重载与重写&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;重写（Override） 子类重写父类方法,多态的条件之一&lt;/li&gt;
&lt;li&gt;重载（Overload） 同一个类中不同参数的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;子类初始化之前会先进行父类的初始化&lt;/li&gt;
&lt;li&gt;父类没有无参构造，编译会报错&lt;/li&gt;
&lt;li&gt;子类重写父类方法，方法访问权限不能比之更低&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;多态&#34;&gt;多态&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;允许不同子类型的对象对同一消息作出不同的响应&lt;br&gt;
好处： 维护、扩展&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;父类接口指向子类对象，主要体现在抽象类&lt;/p&gt;
&lt;p&gt;Fu f = new Zi();&lt;br&gt;
成员方法：编译看父类，运行看子类。&lt;br&gt;
静态方法：编译看父类，运行看子类。&lt;br&gt;
成员变量：编译看父类，运行看子类。&lt;br&gt;
构造方法：编译看父类，运行看父子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;learn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d1tod4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Fu&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;new Fu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;show Fu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;function Fu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Zi&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;new Zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;show Zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;method zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;function Zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Demo04DuoTai&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nd&#34;&gt;@SuppressWarnings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;static-access&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;父类引用指向子类对象&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;父&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;子&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;找不到符号&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		
		&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;找不到符号&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		
		&lt;span class=&#34;o&#34;&gt;/*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;
		&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*/&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;java多态的实现原理&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;当JVM执行Java字节码时，类型信息会存储在方法区中，为了优化对象的调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。&lt;/p&gt;
&lt;p&gt;方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。
方法区的内存回收目标是针对常量池的回收及对类型的卸载。&lt;/p&gt;
&lt;p&gt;方法表的构造&lt;/p&gt;
&lt;p&gt;由于java的单继承机制，一个类只能继承一个父类，而所有的类又都继承Object类，方法表中最先存放的是Object的方法，接下来是父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。&lt;/p&gt;
&lt;p&gt;由于这样的特性，使得方法表的偏移量总是固定的，例如，对于任何类来说，其方法表的equals方法的偏移量总是一个定值，所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。&lt;/p&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;p&gt;假设Class A是Class B的子类，并且A改写了B的方法的method()，那么B来说，method方法的指针指向B的method方法入口；对于A来说，A的方法表的method项指向自身的method而非父类的。&lt;/p&gt;
&lt;p&gt;流程：调用方法时，虚拟机通过对象引用得到方法区中类型信息的方法表的指针入口，查询类的方法表 ，根据实例方法的符号引用解析出该方法在方法表的偏移量，子类对象声明为父类类型时，形式上调用的是父类的方法，此时虚拟机会从实际的方法表中找到方法地址，从而定位到实际类的方法。&lt;br&gt;
注：所有引用为父类，但方法区的类型信息中存放的是子类的信息，所以调用的是子类的方法表。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;抽象类与接口&#34;&gt;抽象类与接口&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;抽象类&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;接口&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;特点&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1.抽象类与方法需用abstract修饰&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1.接口用interface修饰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2.抽象类不一定有抽象方法，有则为抽象类&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2.类实现接口用implements&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3.不能直接实例化（通过多态可实例化）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3.不能被实例化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;成员特点-属性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;变量、常量&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;常量（任何成员属性都隐含着 public static final）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;成员特点-构造方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;成员特点-成员方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;抽象、非抽象&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;抽象、【JDK8有 default、static方法】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关键字&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不能与private、final、static(无意义)共存&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;java.util.AbstractList&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;java.util.List&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;内部类&#34;&gt;内部类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;成员内部类
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;99&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
       
    &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//30
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//20
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//10
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;局部内部类
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;99&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
       
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//存放于堆内存
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;101&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//随调用产生，随结束消失
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//System.out.println(o.num3);//无法访问，编译报错
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;``&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匿名内部类
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;study&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;PersonDemo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;study&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;PersonDemo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PersonDemo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
            &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;study&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;//dosomething;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;``&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;静态内部类（访问外部数据必须用static修饰）
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;99&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
       
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//30
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//20
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//10
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
           
        &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;``&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/679904/201510/679904-20151025210813989-921927916.jpg&#34; alt=&#34;yc&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Throwable
Throwable是 Java 语言中所有错误或异常的超类。
Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。
Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exception
Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RuntimeException
RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。
编译器不会检查RuntimeException异常。如NullPointerException、IndexOutOfBoundsException,ArithmeticException(除数为零时)，也能通过编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非RuntimeException
Exception类本身，以及Exception的子类中除了&amp;quot;运行时异常&amp;quot;之外的其它子类都属于被检查异常。 如IOException、SQLException，Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Error
和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。如StackOverflowError、OutOfMemoryError，和RuntimeException一样， 编译器也不会检查Error,。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hashcode的作用&#34;&gt;hashCode的作用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;hashCode的存在主要是用于查找的快捷性，作用于像散列集合Hashtable，HashMap等确定对象的存储地址的；&lt;/li&gt;
&lt;li&gt;如果两个对象相同，就是适⽤于equals(java.lang.Object)⽅方法，那么这两个对象的hashCode⼀定要相同；&lt;/li&gt;
&lt;li&gt;如果对象的equals⽅方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals⽅方法中使用的一致，否则就会违反上面提到的第2点；&lt;/li&gt;
&lt;li&gt;两个对象的hashCode相同，并不一定表示两个对象就相同（equals不一定为true），只能够说明这两个对象在散列列存储结构中，它们存放在同一个桶里面。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;collection概述&#34;&gt;Collection概述&lt;/h2&gt;
&lt;p&gt;Collection 是对象集合，继承了超级接口Iterable，使用Iterator迭代器实现遍历。 Collection 有两个子接口 List 和 Set。&lt;/p&gt;
&lt;p&gt;List 可以通过下标 (1,2..) 来取得值，值是有序重复，有自己的迭代器ListIterator，可以通过这个迭代器进行逆序的迭代。&lt;/p&gt;
&lt;p&gt;ArrayList、Vector、LinkedList 是List的实现类。&lt;/p&gt;
&lt;p&gt;ArrayList 是线程不安全的，底层采用数组实现（并且该数组的类型是Object类型的），默认长度为10。&lt;br&gt;
扩容的步长是0.5倍原容量，扩容⽅方式是利用数组的复制，因此有一定的开销。&lt;/p&gt;
&lt;p&gt;Vector 是线程安全的，底层采用数组实现。&lt;/p&gt;
&lt;p&gt;LinkedList 是线程不安全的，底层是由（双向循环Deque）链表实现的。&lt;br&gt;
LinkedList 有一个内部类作为存放元素的单元，⾥里里⾯面有三个属性，⽤用来存放元素本身以及前后2个单元的引用，另外LinkedList内部还有一个header属性，用来标识起始位置，第一个单元和最后一个单元都会指向header，因此形成了一个双向循环链表结构。&lt;/p&gt;
&lt;p&gt;Stack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。&lt;br&gt;
Queue接口：提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList（实现双端队列Deque）、PriorityQueue等。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Set 只能通过游标来取值，并且值是不能重复的。Set中的元素类必须有一个有效的equals方法。&lt;/p&gt;
&lt;p&gt;Set子接口有NavigableSet、SortedSet；Set子类有EnumSet、HashSet、LinkedHashSet、TreeSet、AbstractSet等。&lt;/p&gt;
&lt;p&gt;HashSet 底层是哈希表（元素为链表的数组）实现（方法代码使用了HashMap），由hashcode()和equals()方法保证元素唯一。&lt;br&gt;
TreeSet 底层是红黑树（自平衡的二叉树）实现，元素是可排序的。&lt;/p&gt;
&lt;p&gt;LinkedHashSet 底层由链表和哈希表实现，保证元素有序且唯一。&lt;/p&gt;
&lt;p&gt;TreeSet有两种排序实现。自然排序(内比较器)，类实现Comparable；比较器排序，使用匿名内部方式实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//比较器排序
TreeSet&amp;lt;User&amp;gt; userSet = new TreeSet&amp;lt;&amp;gt;(
	new Comparator&amp;lt;User&amp;gt;(){
		public int compare(User user1, User user2){
			if (user1.getAge() &amp;gt; user2.getAge()) return 1;
			else if (user1.getAge() = user2.getAge()) return 0;
			else  return -1;
		}
	}
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用迭代器Iterator遍历集合时修改添加元素会报并发修改异常，而用ListIterator则不会。&lt;/li&gt;
&lt;li&gt;使用size()获取集合长度&lt;/li&gt;
&lt;li&gt;toString()实现：AbstractColletion使用iterator()迭代器方法得到迭代器，之后使用StringBuilder拼接遍历的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;arraylistlinkedlistvector的底层实现和区别&#34;&gt;ArrayList、LinkedList、Vector的底层实现和区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从同步性来看，ArrayList和LinkedList是不同步的，而Vector是的。所以线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList、LinkedList，使我们也达到同步，但效率可能会有所降低。&lt;/li&gt;
&lt;li&gt;从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。如果你要在集合中保存大量的数据，那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。&lt;/li&gt;
&lt;li&gt;ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或者删除元素那么花费的时间会呈线性增长O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置，因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList底层是由双向循环链表实现的，LinkedList在插入、删除集合中任何位置的元素所花费的时间都是一样的O(1)，但它在索引一个元素的时候比较慢，为O(i)，其中i是索引的位置，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;map概述&#34;&gt;Map概述&lt;/h2&gt;
&lt;p&gt;Map 是键值对集合。HashTable和HashMap是Map的实现类。&lt;/p&gt;
&lt;p&gt;HashMap不是线程安全的，键唯一（哈希表实现），可以存储null值。&lt;br&gt;
HashTable是线程安全的，键唯一，不能存储null值。&lt;/p&gt;
&lt;p&gt;LinkedHashMap键是唯一有序的（哈希表和链表实现）&lt;br&gt;
TreeMap键是可排序的（红黑树实现）&lt;/p&gt;
&lt;h2 id=&#34;常用容器初始值大小&#34;&gt;常用容器初始值大小&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;StringBuffer和StringBuilder初始化默认大小为16个字符&lt;/li&gt;
&lt;li&gt;HashMap初始化默认大小16，自增为2n.&lt;/li&gt;
&lt;li&gt;HashTable默认初始值为11，加载因子为0.75，自增为2n+1&lt;/li&gt;
&lt;li&gt;ArrayList初始化默认值为10，自增为1.5n&lt;/li&gt;
&lt;li&gt;Vector初始化默认值为10，自增为2n&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;io流&#34;&gt;IO流&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;字节流
&lt;ul&gt;
&lt;li&gt;输入
&lt;ul&gt;
&lt;li&gt;InputSream
&lt;ul&gt;
&lt;li&gt;FileInputStream&lt;/li&gt;
&lt;li&gt;BufferedInputStream&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;输出
&lt;ul&gt;
&lt;li&gt;OutputStream
&lt;ul&gt;
&lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;li&gt;BufferedOutputStream&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字符流
&lt;ul&gt;
&lt;li&gt;输入
&lt;ul&gt;
&lt;li&gt;Reader
&lt;ul&gt;
&lt;li&gt;InputStreamReader
&lt;ul&gt;
&lt;li&gt;FileReader&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BufferedReader
&lt;ul&gt;
&lt;li&gt;LineNumberReader&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;输出
&lt;ul&gt;
&lt;li&gt;Writer
&lt;ul&gt;
&lt;li&gt;OutputStreamWriter
&lt;ul&gt;
&lt;li&gt;FileWirter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BufferedWriter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;close()与flush()：&lt;br&gt;
close() 关闭流对象，但会先刷新一次流缓冲区，关闭之后不可使用。&lt;br&gt;
flush() 仅仅刷新缓冲区，刷新之后，流对象还可以继续使用。&lt;/p&gt;
&lt;h2 id=&#34;线程状态&#34;&gt;线程状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新建（New）:创建后尚未启动的线程处于这种状态。线程启动start()。&lt;/li&gt;
&lt;li&gt;就绪/运行(Runnable)：Runnable包括了操作系统状态中的 &lt;!-- raw HTML omitted --&gt;就绪&lt;!-- raw HTML omitted --&gt; Ready和 &lt;!-- raw HTML omitted --&gt;运行&lt;!-- raw HTML omitted --&gt; Running，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间。&lt;/li&gt;
&lt;li&gt;无限期等待（Waiting）:处于这种状态的进程不会被分配CPU执行时间，它们要等待被其他线程显示的唤醒。以下方法会让线程陷入无限期的等待状态：
&lt;ul&gt;
&lt;li&gt;没有设置Timeout参数的Object.wait()方法&lt;/li&gt;
&lt;li&gt;没有设置Timeout参数的Thread.join()方法&lt;/li&gt;
&lt;li&gt;LockSupport.park()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;限期等待（Timed Waiting）:处于这种状态的进程不会被分配CPU执行时间，不过无需等待被其他线程显示的唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
&lt;ul&gt;
&lt;li&gt;Thread.sleep()方法&lt;/li&gt;
&lt;li&gt;设置了Timeout参数的Object.wait()方法&lt;/li&gt;
&lt;li&gt;设置了Timeout参数的Thread.join()方法&lt;/li&gt;
&lt;li&gt;LockSupport.parkNanos()方法&lt;/li&gt;
&lt;li&gt;LockSupport.parkUnitil()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;阻塞（Blocked）:进程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获取到一个排它锁，这个事件将在另一个线程放弃这个锁的时候发生；而等待状态则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。&lt;/li&gt;
&lt;li&gt;结束（Terminated）:已终止线程的线程状态，线程已经结束执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的控制&#34;&gt;线程的控制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;获取线程的名称 &lt;code&gt;public final String getName()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置线程的名称 &lt;code&gt;public final void setName(String name)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回当前正在执行的线程对象(名称) &lt;code&gt;public static Thread currentThread()&lt;/code&gt; -&amp;gt; &lt;code&gt;Thread.currentThread().getName()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;获取线程对象的优先级	 &lt;code&gt;public final int getPriority() &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置线程对象的优先级	 &lt;code&gt;public final void setPriority(int newPriority) &lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;线程默认优先级是5。&lt;/li&gt;
&lt;li&gt;线程优先级的范围是：1-10。&lt;/li&gt;
&lt;li&gt;线程优先级高仅仅表示线程获取的 CPU时间片的几率高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将该线程标记为守护线程或用户线程 &lt;code&gt;public final void setDaemon(boolean on)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程休眠	&lt;code&gt;public static void sleep(long millis)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加入线程	&lt;code&gt;public final void join()&lt;/code&gt;:等待该线程终止。&lt;/li&gt;
&lt;li&gt;礼让线程	&lt;code&gt;public static void yield()&lt;/code&gt;:暂停当前正在执行的线程对象，并执行其他线程。&lt;/li&gt;
&lt;li&gt;后台线程&lt;/li&gt;
&lt;li&gt;终止线程(掌握)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public final void stop()&lt;/code&gt;:让线程停止，过时了，但是还可以使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void interrupt()&lt;/code&gt;:中断线程。 把线程的状态终止，并抛出一个InterruptedException。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多线程相关&#34;&gt;多线程相关&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;多线程实现方案：
&lt;ul&gt;
&lt;li&gt;继承Thread类
&lt;ul&gt;
&lt;li&gt;自定义线程类继承Thread类，重写run()&lt;/li&gt;
&lt;li&gt;调用类 创建自定义线程类对象，启动线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现Runnable接口
&lt;ul&gt;
&lt;li&gt;自定义线程类实现Runable接口，重写run()&lt;/li&gt;
&lt;li&gt;调用类 创建自定义线程类对象&lt;/li&gt;
&lt;li&gt;调用类 以自定义线程类对象作为参数构造创建Thread对象，启动线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现Callable接口结合线程池
&lt;ul&gt;
&lt;li&gt;自定义线程类实现Callable接口，重写call方法
&lt;ul&gt;
&lt;li&gt;1
&lt;ul&gt;
&lt;li&gt;调用类 创建ExecutorService线程池对象,调用submit(Callable&lt;!-- raw HTML omitted --&gt; task)&lt;/li&gt;
&lt;li&gt;调用类 创建Future&lt;!-- raw HTML omitted --&gt;对象，接收上一步返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2
&lt;ul&gt;
&lt;li&gt;调用类 创建ExecutorService线程池对象,调用 submit(Runnable task)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pool.shutdown()结束;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程安全问题产生条件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;多线程环境&lt;/li&gt;
&lt;li&gt;有共享数据&lt;/li&gt;
&lt;li&gt;有多条语句操作共享数据&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;同步的方式：
&lt;ul&gt;
&lt;li&gt;同步代码块 &lt;code&gt;synchronized(对象){//doSomething}&lt;/code&gt; 或 同步锁 Lock
&lt;ul&gt;
&lt;li&gt;当线程访问较多时，每个线程都会去判断同步上的锁，非常消耗资源，降低程序运行效率，而且容易产生死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;run()与start()&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;run():封装了被线程执行的代码,直接调用仅仅是普通方法的调用&lt;/li&gt;
&lt;li&gt;start():启动线程，并由JVM自动调用run()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;sleep()与wait()&lt;br&gt;
sleep()是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时会自动恢复（线程回到就绪（ready）状态），调用sleep 不会释放对象锁。&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;
wait()是Object 类的方法，对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;死锁：两个或两个异常的线程争夺资源过程中，发生的一种互相等待的现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁的等级：方法锁、对象锁、类锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现Runnable接口相比继承Thread类有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以避免由于Java的单继承特性而带来的局限&lt;/li&gt;
&lt;li&gt;增强程序的健壮性，代码能够被多个程序共享，代码与数据是独立的&lt;/li&gt;
&lt;li&gt;适合多个相同程序代码的线程区处理同一资源的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;线程安全需要保证几个基本特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。&lt;/li&gt;
&lt;li&gt;可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。&lt;/li&gt;
&lt;li&gt;有序性，是保证线程内串行语义，避免指令重排等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;socket编程&#34;&gt;Socket编程&lt;/h2&gt;
&lt;p&gt;网络编程三要素： IP、端口、协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP
&lt;ul&gt;
&lt;li&gt;发送数据
&lt;ul&gt;
&lt;li&gt;创建发送端口DatagramSocket对象&lt;/li&gt;
&lt;li&gt;创建数据，并打开数据包&lt;/li&gt;
&lt;li&gt;调用DatagramSocket对象发送方法，发送数据包&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接收数据
&lt;ul&gt;
&lt;li&gt;创建DatagramSocket对象&lt;/li&gt;
&lt;li&gt;创建一个数据包（接收容器）&lt;/li&gt;
&lt;li&gt;调用容器接收数据&lt;/li&gt;
&lt;li&gt;解析数据包&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TCP
&lt;ul&gt;
&lt;li&gt;发送数据
&lt;ul&gt;
&lt;li&gt;创建发送端的Socket对象&lt;/li&gt;
&lt;li&gt;获取输出流，写数据&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接收数据
&lt;ul&gt;
&lt;li&gt;创建接收端的Socket&lt;/li&gt;
&lt;li&gt;监听客户端连接&lt;/li&gt;
&lt;li&gt;获取输入流&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;反射机制&#34;&gt;反射机制&lt;/h2&gt;
&lt;p&gt;反射技术：动态加载一个指定的类，并获取该类中所有的内容。并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;好处：大大增强了程序的扩展性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反射的基本步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获得Class对象，就是获得指定的名称的字节码文件对象&lt;/li&gt;
&lt;li&gt;实例化对象，获得类的属性、方法或者构造函数&lt;/li&gt;
&lt;li&gt;访问属性、调用方法、调用构造函数创建对象&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Java笔记之web篇</title>
        <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bweb%E7%AF%87/</link>
        <pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bweb%E7%AF%87/</guid>
        <description>&lt;p&gt;JavaWeb笔记整理&lt;/p&gt;
&lt;h2 id=&#34;xml&#34;&gt;XML&lt;/h2&gt;
&lt;p&gt;XML(EXtensible Markup Language):可扩展标记型语言，主要是为了存储数据（程序配置文件）、数据交换&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;XML两种文档约束类型： &lt;code&gt;dtd&lt;/code&gt; （file_name.dtd）和&lt;code&gt;schema&lt;/code&gt;（file_name.xsd 可被XML解析器解析）&lt;/p&gt;
&lt;p&gt;XML存储结构化信息，使用&lt;code&gt;DOM&lt;/code&gt;或&lt;code&gt;SAX&lt;/code&gt;（边读边解析）方式解析&lt;br&gt;
Properties存储平面信息，使用Properties类解析&lt;/p&gt;
&lt;p&gt;常见的XML解析器实现：JDOM、DOM4J（首选）、SAX&lt;/p&gt;
&lt;p&gt;XPath:XML路径语言，用来确定XML文档中某部分位置&lt;/p&gt;
&lt;h2 id=&#34;web服务器&#34;&gt;Web服务器&lt;/h2&gt;
&lt;p&gt;Tomcat（Apache）、JBOSS（Redhat）、WebLogic（Oracle）、WebSphere（IBM）等等&lt;/p&gt;
&lt;h2 id=&#34;javaweb三大组件&#34;&gt;JavaWeb三大组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Servlet&lt;/li&gt;
&lt;li&gt;Filter&lt;/li&gt;
&lt;li&gt;Listener&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;servlet&#34;&gt;Servlet&lt;/h2&gt;
&lt;p&gt;Servlet是多线程、单实例。&lt;br&gt;
继承关系：MyServlet &amp;ndash;extends&amp;ndash;&amp;gt; HttpServlet &amp;ndash;extends&amp;ndash;&amp;gt; QenericServlet  &amp;ndash;implements&amp;ndash;&amp;gt; Servlet、ServletConfig&lt;/p&gt;
&lt;h4 id=&#34;servlet生命周期&#34;&gt;Servlet生命周期&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;初始化：服务器在Servlet第一次被访问时或在服务器启动时创建Servlet。创建后，调用init()方法；&lt;/li&gt;
&lt;li&gt;提供服务：当服务器每次接收到请求时，会调用service()方法处理请求；&lt;/li&gt;
&lt;li&gt;销毁：当服务器关闭时，服务器会去销毁Servlet。销毁前会调用destroy()方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;在webxml中配置&#34;&gt;在web.xml中配置&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;...
&amp;lt;servlet&amp;gt;
	&amp;lt;servlet-name&amp;gt;myServlet&amp;lt;/servlet-name&amp;gt;
	&amp;lt;servlet-class&amp;gt;com.ianeiu.web.MyServlet&amp;lt;/servlet-class&amp;gt;
	&amp;lt;!-- 通过ServletConfig获取 --&amp;gt;
	&amp;lt;init-param&amp;gt;
		&amp;lt;param-name&amp;gt;key&amp;lt;/param-name&amp;gt;
		&amp;lt;param-value&amp;gt;value&amp;lt;/param-value&amp;gt;
	&amp;lt;/init-param&amp;gt;
	&amp;lt;!-- 值越小，优先级越大 --&amp;gt;
	&amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
	&amp;lt;servlet-name&amp;gt;myServlet&amp;lt;/servlet-name&amp;gt;
	&amp;lt;url-pattren&amp;gt;/my/*&amp;lt;/url-pattren&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问路径可以使用通配符 &lt;!-- raw HTML omitted --&gt;* /* /myName/* *.do&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;httpservlet&#34;&gt;HttpServlet&lt;/h4&gt;
&lt;p&gt;实现了service(..,..),重写service(HttpServletRequest ..,HttpServletResponse &amp;hellip;),子类只需调用doGet() doPost()。&lt;/p&gt;
&lt;h2 id=&#34;请求request&#34;&gt;请求request&lt;/h2&gt;
&lt;p&gt;URL相关：&lt;br&gt;
&lt;code&gt;http://127.0.0.1:8080/myproject/myServlet?name=admin  &lt;/code&gt;&lt;br&gt;
.getRequestURL()+&amp;quot;?&amp;quot;+ .getQueryString&lt;br&gt;
或者&lt;br&gt;
.getScheme() +&amp;quot;://&amp;quot;+ .getServerName() +&amp;quot;:&amp;quot;+.getServerPort() +&amp;quot;/&amp;quot;+ .getContextPath +&amp;quot;/&amp;quot;+ .getServerPath +&amp;quot;?&amp;quot;+ .getQueryString&lt;br&gt;
/myproject/myServlet 可用 .getRequestURI() 获取&lt;/p&gt;
&lt;h4 id=&#34;get和post&#34;&gt;get和post&lt;/h4&gt;
&lt;p&gt;get：没有请求体，参数在url中显示，长度理论限制1K之内&lt;br&gt;
post: 参数在请求体中，长度无限制&lt;/p&gt;
&lt;h4 id=&#34;请求转发和请求包含&#34;&gt;请求转发和请求包含&lt;/h4&gt;
&lt;p&gt;都是一个请求跨多个Servlet（可以共享request的域属性）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class AServlet extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		RequestDispacter rd = request.getRequestDispacter(&amp;quot;/BServlet&amp;quot;);
		rd.forward(request,response);//A不能输响应体，可设置响应头，最后由B处理
		rd.include(request,response);//无限制，共同处理请求
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;响应response&#34;&gt;响应response&lt;/h2&gt;
&lt;p&gt;可设置响应信息、发送状态码、设置响应正文、重定向（response.sendRedirect(&amp;quot;/myProject/BServlet&amp;quot;)）&lt;/p&gt;
&lt;h4 id=&#34;响应编码&#34;&gt;响应编码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;response.setCharacterEncoding(&amp;ldquo;utf-8&amp;rdquo;); response.getWriter(&amp;quot;..&amp;quot;);&lt;/li&gt;
&lt;li&gt;response.setHeader(&amp;ldquo;content-type&amp;rdquo;,&amp;ldquo;text/html;charset=utf-8&amp;rdquo;);&lt;/li&gt;
&lt;li&gt;response.setContentType(&amp;ldquo;text/html;charset=utf-8&amp;rdquo;);&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;请求转发和重定向302&#34;&gt;请求转发和重定向（302）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;请求转发是一个请求，但是重定向是两个请求。&lt;/li&gt;
&lt;li&gt;请求转发只能是一种请求方式，要么是Get要么是Post ,但是重定向的第二个请求一定是Get。&lt;/li&gt;
&lt;li&gt;请求转发的地址栏并不会发生变化(服务器请求资源)，但是重定向的会变化，因为它是两个请求(浏览器重新请求地址)。&lt;/li&gt;
&lt;li&gt;请求转发只能在本应用下的资源，但是重定向却可以跨应用，比如重定向到百度的主页。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;javaweb四大域对象&#34;&gt;JavaWeb四大域对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PageContext - page    （jsp）&lt;/li&gt;
&lt;li&gt;ServletRequest - request     （servlet、jsp）&lt;/li&gt;
&lt;li&gt;HttpSession - session     （servlet、jsp）&lt;/li&gt;
&lt;li&gt;ServletContext - application     （servlet、jsp）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;servletcontext&#34;&gt;ServletContext&lt;/h2&gt;
&lt;p&gt;ServletContext是Servlet域三大对象之一。&lt;br&gt;
在服务器启动时创建，关闭时销毁，单实例。&lt;br&gt;
用来存取数据、读取web.xml中初始化参数、读取应用资源（文件名、输入流、文件路径集合）&lt;/p&gt;
&lt;h3 id=&#34;响应头&#34;&gt;响应头&lt;/h3&gt;
&lt;p&gt;防盗链：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Referer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;禁用浏览器缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Expies:-1&lt;/li&gt;
&lt;li&gt;Cache-Control:no-cache&lt;/li&gt;
&lt;li&gt;Pragma:no-cache&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三秒后跳转至百度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;Refresh&amp;quot; content=&amp;quot;3;url=http://www.baidu.com&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jsp九大内置对象&#34;&gt;JSP九大内置对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;request - HttpServletRequest&lt;/li&gt;
&lt;li&gt;response - HttpServletResponse&lt;/li&gt;
&lt;li&gt;session - HttpSession&lt;/li&gt;
&lt;li&gt;application - ServletContext&lt;/li&gt;
&lt;li&gt;config - ServletConfig&lt;/li&gt;
&lt;li&gt;exception - 只有在错误页面才可使用&lt;/li&gt;
&lt;li&gt;page - 作用本JSP页面中&lt;/li&gt;
&lt;li&gt;out - JSPWriter&lt;/li&gt;
&lt;li&gt;pageContext - 页面上下文对象（作用域最小）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jsp中的java脚本&#34;&gt;JSP中的Java脚本&amp;lt;%%&amp;gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;脚本
&lt;ul&gt;
&lt;li&gt;&amp;lt;% .. %&amp;gt; 脚本片段&lt;/li&gt;
&lt;li&gt;&amp;lt;%= ..%&amp;gt; 表达式&lt;/li&gt;
&lt;li&gt;&amp;lt;%! ..%&amp;gt; 声明，定义成员&lt;/li&gt;
&lt;li&gt;示例：&lt;code&gt;&amp;lt;% int a=10; %&amp;gt; &amp;lt;%= a %&amp;gt; &amp;lt;%! private String hello=&amp;quot;hello&amp;quot;;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释
&lt;ul&gt;
&lt;li&gt;&amp;lt;%&amp;ndash; ..  &amp;ndash;%&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令
&lt;ul&gt;
&lt;li&gt;&amp;lt;%@ .. %&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jsp原理&#34;&gt;JSP原理&lt;/h2&gt;
&lt;p&gt;客户端 访问 index.jsp,服务器将jsp文件编译成java文件，JVM将java文件编译成class文件。&lt;br&gt;
服务器初始化jsp实例，创建该类对象，调用service()。&lt;br&gt;
客户端再次访问则直接调用service()。&lt;/p&gt;
&lt;h2 id=&#34;jsp三大指令&#34;&gt;JSP三大指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;page&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;错误页面配置 &lt;code&gt;&amp;lt;%@ page language=&amp;quot;java&amp;quot; contentType=&amp;quot;text/html; charset=UTF-8&amp;quot;  pageEncoding=&amp;quot;UTF-8&amp;quot; isErrorPage=&amp;quot;true&amp;quot;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;脚本获取错误 &lt;code&gt;&amp;lt;%= exception.getMessage()%&amp;gt;&lt;/code&gt; [exception为jsp内置对象，error页面独有]&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;include&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;静态包含&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;taglib&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;%@ taglib uri=&amp;quot;&amp;quot; prefix=&amp;quot;c&amp;quot;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在webxml中配置错误页面&#34;&gt;在web.xml中配置错误页面&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 默认的错误处理页面 --&amp;gt;  
&amp;lt;error-page&amp;gt;  
	&amp;lt;error-code&amp;gt;403&amp;lt;/error-code&amp;gt;  
	&amp;lt;location&amp;gt;/403.html&amp;lt;/location&amp;gt;  
&amp;lt;/error-page&amp;gt;  
&amp;lt;error-page&amp;gt;  
	&amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;  
	&amp;lt;location&amp;gt;/404.html&amp;lt;/location&amp;gt;  
&amp;lt;/error-page&amp;gt;  
&amp;lt;!-- 仅仅在调试的时候注视掉,在正式部署的时候不能注释 --&amp;gt;  
&amp;lt;!-- 这样配置也是可以的，表示发生500错误的时候，转到500.jsp页面处理。 --&amp;gt;  
&amp;lt;error-page&amp;gt;   
	&amp;lt;error-code&amp;gt;500&amp;lt;/error-code&amp;gt;   
	&amp;lt;location&amp;gt;/500.html&amp;lt;/location&amp;gt;   
&amp;lt;/error-page&amp;gt;
&amp;lt;!-- 这样的配置表示如果jsp页面或者servlet发生java.lang.Exception类型（当然包含子类）的异常就会转到500.jsp页面处理。 --&amp;gt;  
&amp;lt;error-page&amp;gt;   
	&amp;lt;exception-type&amp;gt;java.lang.Exception&amp;lt;/exception-type&amp;gt;   
	&amp;lt;location&amp;gt;/500.jsp&amp;lt;/location&amp;gt;   
&amp;lt;/error-page&amp;gt;   
  
&amp;lt;error-page&amp;gt;   
	&amp;lt;exception-type&amp;gt;java.lang.Throwable&amp;lt;/exception-type&amp;gt;   
	&amp;lt;location&amp;gt;/500.jsp&amp;lt;/location&amp;gt;   
&amp;lt;/error-page&amp;gt;  
&amp;lt;!--   
当error-code和exception-type都配置时，exception-type配置的页面优先级高  
及出现500错误，发生异常Exception时会跳转到500.jsp  
 --&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;在webxml中配置jstl&#34;&gt;在web.xml中配置jstl&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;...  
&amp;lt;jsp-config&amp;gt;  
   &amp;lt;taglib&amp;gt;  
	   &amp;lt;taglib-uri&amp;gt;myjstl&amp;lt;/taglib-uri&amp;gt;  
	   &amp;lt;taglib-location&amp;gt;/WEB-INF/tld/c.tld&amp;lt;/taglib-location&amp;gt;  
   &amp;lt;/taglib&amp;gt;  
&amp;lt;/jsp-config&amp;gt;  
...  
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;jsp基本动作&#34;&gt;JSP基本动作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;include&lt;/li&gt;
&lt;li&gt;useBean&lt;/li&gt;
&lt;li&gt;setProperty&lt;/li&gt;
&lt;li&gt;getProperty&lt;/li&gt;
&lt;li&gt;forward&lt;/li&gt;
&lt;li&gt;plugin&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态包含和静态包含&#34;&gt;动态包含和静态包含&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;动态包含&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;jsp:include page=&amp;quot;navigation.jsp&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求处理阶段执行&lt;/li&gt;
&lt;li&gt;会检查所含文件变化，用于动态页面&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;静态包含&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;%@ include file=&amp;quot;resource.html&amp;quot;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;翻译阶段执行（合并再编译）&lt;/li&gt;
&lt;li&gt;不检查所含文件变化，用于静态页面&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cookie&#34;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;Cookie是Http协议的规范之一，是服务端和客户端之间传输的小数据。
特点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大小4KB（实际上不止）&lt;/li&gt;
&lt;li&gt;服务器最多在客户端浏览器上保存20个&lt;/li&gt;
&lt;li&gt;浏览器最多保存300个&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;httpsession&#34;&gt;HttpSession&lt;/h2&gt;
&lt;p&gt;用来会话跟踪的类。session是服务端对象，保存在服务端。&lt;br&gt;
HttpSession底层依赖Cookie或是URL重写。&lt;/p&gt;
&lt;p&gt;会话的实现依赖于容器，大多数容器采用基于Cookie的实现机制，使用名字为JSESSIONID的cookie作为session的唯一标识。&lt;/p&gt;
&lt;h4 id=&#34;url重写&#34;&gt;URL重写&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href =&amp;quot;/myproject/myjsp.jsp;jsessionid=&amp;lt;%=session.getId()%&amp;gt;&amp;quot;&amp;gt;跳转&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href =&amp;quot;&amp;lt;response.encodeURL(&#39;/myproject/myjsp.jsp&#39;)&amp;gt;&amp;quot;&amp;gt;跳转&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;el表达式&#34;&gt;EL表达式&lt;/h2&gt;
&lt;p&gt;EL表达式主要是用来替代JSP页面中的脚本表达式，获取JavaBean、Map、List、数组及域内置对象属性。也可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;${标识符}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取数据&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;List/数组 &lt;code&gt;${userList[0]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Bean &lt;code&gt;${user.userName}&lt;/code&gt;或&lt;code&gt;${user[&#39;userName&#39;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Map &lt;code&gt;${paramMap.key}&lt;/code&gt;或&lt;code&gt;${paramMap[&#39;key&#39;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内置对象 &lt;code&gt;${sessionScope.userName}&lt;/code&gt;、&lt;code&gt;${initParam[&#39;maxNum&#39;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果Map的键或Bean的属性名中包含&lt;code&gt;_&lt;/code&gt;或&lt;code&gt;-&lt;/code&gt;时，只有${initParam[&amp;lsquo;max_num&amp;rsquo;]}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;运算&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${1+2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${3&amp;gt;5}&lt;/code&gt;或&lt;code&gt;${3 gt 5}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${isSuccess &amp;amp;&amp;amp; length&amp;gt;0}&lt;/code&gt; 或&lt;code&gt;${isSuccess and length&amp;gt;0}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${!isSuccess}&lt;/code&gt; 或&lt;code&gt;${not isSuccess}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;empty判断字符串、数组、集合的长度是否为0(可与not或!连用)	&lt;code&gt;${empty &amp;quot;&amp;quot;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;el-11个内置对象&#34;&gt;EL 11个内置对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pageScope：获取pageContext域属性，相当于pageContext.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;requestScope：获取request域属性，相当于request.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;sessionScope：获取session域属性，相当于session.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;applicationScope：获取application域属性，相当于application.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;param：对应参数，它是一个Map，其中key是参数，value是参数值，适用于单值的参数，相当于request.getParameter(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;paramValues：对应参数，她是一个Map，其中key是参数，value是多个参数值，适用于多值的参数，相当于request.getParameterValues(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;header：对应请求头，它是一个Map，其中key表示头名称，value是单个头值，适用于单值的请求头，相当于request.getHeader(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;headerValues：对应请求头，它是一个Map，其中key表示头名称，value是多个头值，适用于多值的请求头，相当于request.getHeaders(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;initParam：获取web.xml中&lt;!-- raw HTML omitted --&gt;内的参数，${ initParam.xxx}，xxx就是&lt;!-- raw HTML omitted --&gt;标签内的值，进而得到&lt;!-- raw HTML omitted --&gt;中的值&lt;/li&gt;
&lt;li&gt;cookie：用于获取cookie，Map&amp;lt;String,Cookie&amp;gt;，其中key是cookie的name，value是cookie对象，例如${cookie.JSESSIONID.value }就是获取sessionId&lt;/li&gt;
&lt;li&gt;pageContext：可以获取JSP九大内置对象，相当于使用该对象调用getxxx()方法，例如pageContext.getRequest()可以写为${pageContext.request)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jstl&#34;&gt;JSTL&lt;/h2&gt;
&lt;p&gt;JSTL是一个不断完善的开放源代码的JSP标签库，依赖于EL，使用需要导入jstl.jar。&lt;/p&gt;
&lt;p&gt;JSTL标签库可分为四种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;core&lt;/li&gt;
&lt;li&gt;fmt&lt;/li&gt;
&lt;li&gt;sql&lt;/li&gt;
&lt;li&gt;xml&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中sql标签库和xml标签库已过时。使用标签的JSP页面中使用taglib指令导入标签库，如下：&lt;br&gt;
&lt;code&gt;&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot;uri=&amp;quot;http://java.sun.com/jstl/core&amp;quot; %&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prefix=&amp;quot;c&amp;quot;&lt;/code&gt;：指定标签库的前缀，这个前缀可以随便给值，但大家都会在使用core标签库时指定前缀为c；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uri=&amp;quot;http://java.sun.com/jstl/core&amp;quot;&lt;/code&gt;：指定标签库的uri，它不一定是真实存在的网址，但它可以让JSP找到标签库的描述文件；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;core标签库常用标签&#34;&gt;core标签库常用标签&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;out&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:out value=&amp;quot;aaa&amp;quot;/&amp;gt;&lt;/code&gt; 输出aaa字符串常量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:out value=&amp;quot;${aaa}&amp;quot;/&amp;gt;&lt;/code&gt; 	与${aaa}相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:out value=&amp;quot;${aaa}&amp;quot; default=&amp;quot;xxx&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:set var=&amp;quot;a&amp;quot; value=&amp;quot;hello&amp;quot;/&amp;gt;&lt;/code&gt; 在pageContext中添加name为a，value为hello的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:set var=&amp;quot;a&amp;quot; value=&amp;quot;hello&amp;quot; scope=&amp;quot;session&amp;quot;/&amp;gt;&lt;/code&gt; 在session中添加name为a，value为hello的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;remove&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; &amp;lt;c: remove var=&amp;quot;a&amp;quot;/&amp;gt;&lt;/code&gt; 删除所有域中name为a的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:remove var=&amp;quot;a&amp;quot; scope=&amp;quot;page&amp;quot;/&amp;gt;&lt;/code&gt; 删除pageContext中name为a的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;url&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/&amp;quot;/&amp;gt;&lt;/code&gt; 输出上下文路径：/项目名/&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/&amp;quot; var=&amp;quot;a&amp;quot; scope=&amp;quot;request&amp;quot;/&amp;gt;&lt;/code&gt; 把本该输出的结果赋给变量a。范围为request&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/AServlet&amp;quot;/&amp;gt;&lt;/code&gt;   输出：/项目名/AServlet&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/AServlet&amp;quot;&amp;gt; &amp;lt;c:param name=&amp;quot;username&amp;quot; value=&amp;quot;abc&amp;quot;/&amp;gt; &amp;lt;c:param name=&amp;quot;password&amp;quot; value=&amp;quot;123&amp;quot;/&amp;gt; &lt;/code&gt; 输出：/项目名/AServlet?username=abc&amp;amp;password=123。如果参数中包含中文，那么会自动使用URL编码！&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:if test=&amp;quot;条件&amp;quot;&amp;gt;满足条件执行的JSP代码&amp;lt;/c:if&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;choose&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:choose&amp;gt; &amp;lt;c:when test=&amp;quot;条件&amp;quot;&amp;gt;处理&amp;lt;/c:when&amp;gt; &amp;lt;c:when test=&amp;quot;条件&amp;quot;&amp;gt;处理&amp;lt;/c:when&amp;gt; &amp;lt;c:otherwise&amp;gt;处理&amp;lt;/c:otherwise&amp;gt; &amp;lt;/c:choose&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;forEach&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:forEach var=&amp;quot;名字(i)&amp;quot; begin=&amp;quot;开始数字(1)&amp;quot; end=&amp;quot;结束数字(5)&amp;quot;&amp;gt; ${i} &amp;lt;/c:forEach&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:forEach var=&amp;quot;item&amp;quot; items=&amp;quot;数组/集合&amp;quot;&amp;gt; ${item} &amp;lt;/c:forEach&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;:forTokens&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:forTokens items=&amp;quot;google,runoob,taobao&amp;quot; delims=&amp;quot;,&amp;quot; var=&amp;quot;name&amp;quot;&amp;gt; &amp;lt;c:out value=&amp;quot;${name}&amp;quot;/&amp;gt;&amp;lt;p&amp;gt; &amp;lt;/c:forTokens&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;fmt标签库&#34;&gt;fmt标签库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;fmt:formatNumber value=”被格式化的数据”[type=”number|currency|percent”]

                                               [pattern=”pattern”]

                                               [currencyCode=”code”]

                                               [currencySymbol=”symbol”]

                                               [groupingUsed=”true|false”]

                                               [maxIntergerDigits=”maxDigits”]

                                               [minIntergerDigits=”minDigits”]

                                               [maxFractionDigits=”maxDigits”]

                                               [minFractionDigits=”minDigits”]

                                               [var=”name”]

                                               [scope=page|request|session|application]

/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;详见 &lt;!-- raw HTML omitted --&gt;fmt&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;jstl自定义标签&#34;&gt;JSTL自定义标签&lt;/h2&gt;
&lt;p&gt;JSP中使用自定义标签移除只需要完成以下两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写一个实现Tag接口的java类（标签处理类）；&lt;/li&gt;
&lt;li&gt;编写标签库描述符（tld）文件，在tld文件中对标签处理类进行描述。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;详见 &lt;!-- raw HTML omitted --&gt;JSTL自定义标签&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;jdbc&#34;&gt;JDBC&lt;/h2&gt;
&lt;p&gt;JDBC核心类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DriverManager&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;注册驱动&lt;/li&gt;
&lt;li&gt;获取Connection&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Connection&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;与数据库通讯&lt;/li&gt;
&lt;li&gt;获取Statement&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Statement&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;向数据库发送SQL语句&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;ResultSet&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;结果集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JDBC编写顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册驱动层序&lt;/li&gt;
&lt;li&gt;获取数据库连接&lt;/li&gt;
&lt;li&gt;创建Statement/PreparedStatement&lt;/li&gt;
&lt;li&gt;发送执行sql语句&lt;/li&gt;
&lt;li&gt;处理结果集（如果有）&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;statement&#34;&gt;Statement&lt;/h4&gt;
&lt;p&gt;con.createStatement()（结果集不滚动、不敏感、不可更新）&lt;br&gt;
con.createStatement(int,int)&lt;/p&gt;
&lt;h2 id=&#34;jdbc之statementpreparedstatementcallablestatement&#34;&gt;JDBC之Statement,PreparedStatement,CallableStatement&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Statement、PreparedStatement和CallableStatement都是接口(interface)。&lt;/li&gt;
&lt;li&gt;Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。&lt;/li&gt;
&lt;li&gt;Statement接口提供了执行语句和获取结果的基本方法；&lt;br&gt;
PreparedStatement接口添加了处理 IN 参数的方法；&lt;br&gt;
CallableStatement接口添加了处理 OUT 参数的方法。&lt;/li&gt;
&lt;li&gt;特性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Statement
&lt;ul&gt;
&lt;li&gt;普通的不带参的查询SQL；&lt;/li&gt;
&lt;li&gt;支持批量更新,批量删除;&lt;/li&gt;
&lt;li&gt;Statement每次执行sql语句，数据库都要执行sql语句的编译;用于仅执行一次查询并返回结果的情形时，效率高于PreparedStatement。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PreparedStatement
&lt;ul&gt;
&lt;li&gt;可变参数的SQL,编译一次,执行多次,效率高;安全性好，有效防止Sql注入等问题&lt;/li&gt;
&lt;li&gt;支持批量更新,批量删除;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CallableStatement
&lt;ul&gt;
&lt;li&gt;继承自PreparedStatement,支持带参数的SQL操作;&lt;/li&gt;
&lt;li&gt;支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用PreparedStatement有几个好处&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。&lt;/li&gt;
&lt;li&gt;安全性好，有效防止Sql注入等问题。&lt;/li&gt;
&lt;li&gt;对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；&lt;/li&gt;
&lt;li&gt;代码的可读性和可维护性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;execute&#34;&gt;execute&amp;hellip;&lt;/h4&gt;
&lt;p&gt;executeQuery：返回结果集(ResultSet)。&lt;br&gt;
executeUpdate: 执行给定SQL语句,该语句可能为 INSERT、UPDATE 或 DELETE 语句，或者不返回任何内容的SQL语句（如 SQL DDL 语句）。&lt;br&gt;
execute: 可用于执行任何SQL语句，返回一个boolean值，表明执行该SQL语句是否返回了ResultSet。如果执行后第一个结果是ResultSet，则返回true，否则返回false。&lt;/p&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;事务的四大特性及隔离级别&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据库连接池&#34;&gt;数据库连接池&lt;/h2&gt;
&lt;p&gt;DBCP（hibernate3不再支持）&lt;/p&gt;
&lt;p&gt;C3P0&lt;/p&gt;
</description>
        </item>
        <item>
        <title>TCP与UDP笔记</title>
        <link>https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;tcpip协议&#34;&gt;tcp/ip协议&lt;/h2&gt;
&lt;p&gt;TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据链路层负责帧数据的传递;&lt;/li&gt;
&lt;li&gt;网络层责数据怎样传递过去;&lt;/li&gt;
&lt;li&gt;传输层负责传输数据的控制（准确性、安全性）;&lt;/li&gt;
&lt;li&gt;应用层负责数据的展示和获取。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;物理层：  为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。&lt;/p&gt;
&lt;h2 id=&#34;tcp协议&#34;&gt;TCP协议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Transmission Control Protocol，传输控制协议&lt;/li&gt;
&lt;li&gt;面向连接的协议&lt;/li&gt;
&lt;li&gt;需要三次握手建立连接&lt;/li&gt;
&lt;li&gt;需要四次挥手断开连接&lt;/li&gt;
&lt;li&gt;TCP报头最小长度：20字节&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp与udp&#34;&gt;TCP与UDP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;面向报文的传输方式&lt;/strong&gt;是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。
&lt;strong&gt;面向字节流&lt;/strong&gt;的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。&lt;/p&gt;
&lt;h3 id=&#34;tcp与udp的区别&#34;&gt;TCP与UDP的区别&lt;/h3&gt;
&lt;p&gt;1、基于连接与无连接;&lt;br&gt;
2、TCP要求系统资源较多，UDP较少;  &lt;br&gt;
3、UDP程序结构较简单;&lt;br&gt;
4、流模式（TCP）与数据报模式(UDP);&lt;br&gt;
5、TCP保证数据正确性，UDP可能丢包;&lt;br&gt;
6、TCP保证数据顺序，UDP不保证。&lt;/p&gt;
&lt;h4 id=&#34;三次握手的过程&#34;&gt;三次握手的过程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送：SYN = 1, SEQ = X, 端口号&lt;/li&gt;
&lt;li&gt;服务器回复：SYN = 1, ACK = X + 1, SEQ = Y&lt;/li&gt;
&lt;li&gt;客户端发送：ACK = Y + 1, SEQ = X + 1&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;确认应答信号ACK = 收到的SEQ + 1。连接建立中，同步信号SYN始终为1。连接建立后，同步信号SYN=0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/Tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B.png&#34; data-size=&#34;696x444&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/Tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B_hud7960ab7730bead344e303715fec81b3_129972_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/Tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B_hud7960ab7730bead344e303715fec81b3_129972_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/Tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B.png&#34; width=&#34;696&#34; height=&#34;444&#34; loading=&#34;lazy&#34;
				alt=&#34;Tcp建立连接的过程&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Tcp建立连接的过程&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;四次挥手过程&#34;&gt;四次挥手过程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A向B提出停止连接请求，FIN = 1&lt;/li&gt;
&lt;li&gt;B收到，ACK = 1&lt;/li&gt;
&lt;li&gt;B向A提出停止连接请求，FIN = 1&lt;/li&gt;
&lt;li&gt;A收到，ACK = 1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/Tcp%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B.png&#34; data-size=&#34;741x363&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/Tcp%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B_hua3a1cad0f9424442d8b857ec4ef9460d_88615_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/Tcp%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B_hua3a1cad0f9424442d8b857ec4ef9460d_88615_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/tcp%E4%B8%8Eudp%E7%AC%94%E8%AE%B0/Tcp%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B.png&#34; width=&#34;741&#34; height=&#34;363&#34; loading=&#34;lazy&#34;
				alt=&#34;Tcp断开连接的过程&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Tcp断开连接的过程&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可靠，稳定&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;传递数据前，会有三次握手建立连接&lt;/li&gt;
&lt;li&gt;传递数据时，有确认、窗口、重传、拥塞控制&lt;/li&gt;
&lt;li&gt;传递数据后，会断开连接节省系统资源&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传输慢，效率低，占用系统资源高&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;传递数据前，建立连接需要耗时&lt;/li&gt;
&lt;li&gt;传递数据时，确认、重传、拥塞等会消耗大量时间以及CPU和内存等硬件资源&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;易被攻击
1、因为有确认机制，三次握手等机制，容易被人利用，实现DOS 、DDOS攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;如何保证接收的顺序性：&lt;/strong&gt;
TCP协议使用SEQ和ACK机制保证了顺序性
TCP的每个报文都是有序号的。确认应答信号ACK=收到的SEQ+1&lt;/p&gt;
&lt;h2 id=&#34;udp协议&#34;&gt;UDP协议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;User Data Protocol，用户数据包协议&lt;/li&gt;
&lt;li&gt;面向无连接的协议&lt;/li&gt;
&lt;li&gt;UDP报头只有8字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快的把它扔到网络上&lt;/li&gt;
&lt;li&gt;在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制&lt;/li&gt;
&lt;li&gt;在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段&lt;/li&gt;
&lt;li&gt;由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息&lt;/li&gt;
&lt;li&gt;UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小&lt;/li&gt;
&lt;li&gt;吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制&lt;/li&gt;
&lt;li&gt;UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。&lt;/li&gt;
&lt;li&gt;UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传输速率快&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;传输数据前，不需要像TCP一样建立连接&lt;/li&gt;
&lt;li&gt;传输数据时，没有确认、窗口、重传、拥塞控制等机制&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;较安全&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;由于没有了TCP的一些机制，被攻击者利用的漏洞就少了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可靠，不稳定
1、由于没有了TCP的机制，在数据传输时如果网络不好，很可能丢包&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;用UDP协议通讯时怎样得知目标机是否获得了数据包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仿造TCP的做法，每发一个UDP包，都在里面加一个SEQ序号，接收方收到包后，将SEQ序号回复给发送方。如果发送方在指定时间以内没有收到回应，说明丢包了。&lt;/p&gt;
&lt;h2 id=&#34;tcp与udp的区别-1&#34;&gt;TCP与UDP的区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;TCP&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;UDP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP面向有链接的通信服务&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UDP面向无连接的通信服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP提供可靠的通信传输&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UDP不可靠,会丢包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP保证数据顺序&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UDP不保证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP数据无边界&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UDP有边界&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP速度快&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UDP速度慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP面向字节流&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UDP面向报文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP一对一&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UDP可以一对一，一对多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP报头至少20字节&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UDP报头8字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP有流量控制，拥塞控制&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UDP没有&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;为什么UDP比TCP快&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;TCP需要三次握手&lt;/li&gt;
&lt;li&gt;TCP有拥塞控制，控制流量等机制&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;为什么TCP比UDP可靠&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;TCP是面向有连接的，建立连接之后才发送数据；而UDP则不管对方存不存在都会发送数据。&lt;/li&gt;
&lt;li&gt;TCP有确认机制，接收端每收到一个正确包都会回应给发送端。超时或者数据包不完整的话发送端会重传。UDP没有。因此可能丢包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;什么时候使用TCP&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。
在日常生活中，常见使用TCP协议的应用如下：
浏览器，用的HTTP
FlashFXP，用的FTP
Outlook，用的POP、SMTP
Putty，用的Telnet、SSH
QQ文件传输&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么时候应该使用UDP：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。
比如，日常生活中，常见使用UDP协议的应用如下：
QQ语音
QQ视频
TFTP&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP无边界，UDP有边界&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;TCP无边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端分多次发送数据给服务器，若服务器的缓冲区够大，那么服务器端会在客户端发送完之后一次性接收过来，所以是无边界的；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UDP有边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端每发送一次，服务器端就会接收一次，也就是说发送多少次就会接收多少次，因此是有边界的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>计算机网络基础汇总</title>
        <link>https://ianeiu.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</link>
        <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</guid>
        <description>&lt;h1 id=&#34;计算机网络体系分类&#34;&gt;计算机网络体系分类：&lt;/h1&gt;
&lt;p&gt;计算机网络整个体系有两个大的分类：一个是国际组织制定的OSI七层模型，一种是实际使用中的TCP/IP四层模型。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OSI七层模型&lt;/th&gt;
&lt;th&gt;TCP/IP四层模型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表示层&lt;/td&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;会话层&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据链路层&lt;/td&gt;
&lt;td&gt;物理接入层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;物理层&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;物理层&#34;&gt;物理层：&lt;/h1&gt;
&lt;p&gt;物理层主要是实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。&lt;/p&gt;
&lt;h2 id=&#34;通信方式&#34;&gt;通信方式：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**单工通信：**只能由A主机向B主机发送消息，通信是单向的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**半双工通信：**同一时间只能是由A主机向B主机或者是B主机向A主机发送信息，不能同时发送消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全双工通信：&lt;/strong&gt; A主机和B主机可以实现在同一时间内既接收消息，又发送消息，极大的提升了通信效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见引导型传输媒体&#34;&gt;常见引导型传输媒体：&lt;/h2&gt;
&lt;h3 id=&#34;双绞线&#34;&gt;双绞线：&lt;/h3&gt;
&lt;p&gt;分为屏蔽双绞线（STP）和非屏蔽双绞线（UTP），屏蔽双绞线就是在非屏蔽双绞线外边又加了一层屏蔽层&lt;/p&gt;
&lt;p&gt;tips：为什么双绞线要两根线绞起来，两个线绞起来可以有效的减少相互之间的电磁干扰。&lt;/p&gt;
&lt;h3 id=&#34;同轴电缆&#34;&gt;同轴电缆：&lt;/h3&gt;
&lt;p&gt;由内导体铜制芯线，绝缘层，网状编织的外导体屏蔽层，以及塑料保护外层组成。有良好的抗干扰性，被广泛用于较高速率的传输。&lt;/p&gt;
&lt;h3 id=&#34;光缆&#34;&gt;光缆：&lt;/h3&gt;
&lt;p&gt;由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通讯柱。可以分为单模光纤和多模光纤。&lt;/p&gt;
&lt;h2 id=&#34;信道复用技术&#34;&gt;信道复用技术：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**频分复用：**根据传输的波的频率的不同，将不同频段的波用于不同的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;时分复用：&lt;strong&gt;将时间分割为时间段，规定在某个时间段内发送什么样的信息，根据时间段来进行信息类别的区分。也称为&lt;/strong&gt;同步时分复用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计时分复用：&lt;strong&gt;基于时分复用的一种改进，由于基本的时分复用并没有考虑到每个时间段内是否有信息发出，例如说每个时间段是20，但是发送消息只占用其中的2，那么剩下的18就处于空闲时间。统计时分复用就是基于这种考虑而设计的，他允许用户有数据时就将数据发送到缓存中，然后会依次扫描输入缓存，把缓存中的数据放入到STMD帧中，若没有就跳过，每当一个帧满了就把这个帧发出去。STMD帧不是分配的固定时序，而是根据需要动态的分配时隙，也称之为&lt;/strong&gt;异步时分复用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;光分复用：就是光的频分复用，根据光谱中频率的不同，用不同频率的光来携带不同的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据链路层&#34;&gt;数据链路层：&lt;/h1&gt;
&lt;p&gt;数据链路层主要是将上层的数据转化为数据帧发送到链路上，以及把接受到的帧中的数据取出并交给网络层。&lt;/p&gt;
&lt;h2 id=&#34;通信方式-1&#34;&gt;通信方式：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**点对点通信：**通信方式是点到点的，也就是只能是两个点之间的通信。常见的就是PPP协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**广播通信：**广播通讯，也就是可以同时实现一对多的通信。常见的就是CSMA/CD（载波监听多点访问/冲突检测）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;核心要解决的问题&#34;&gt;核心要解决的问题：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**封装成帧：**在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在接受到后就可以方便准确的确定帧的首尾，也称为帧定界符。同时定义出了最大传输单元（MTU）&amp;ndash;表示一次可以传输的最大长度上限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;透明传输：&lt;/strong&gt; 由于使用特定的字符来表示帧的开始和结束，所以传输的内容中不能出现和帧定界符相同的字符，但这显然是不可能的，为了解决这个办法，就可以在内容中和帧定界符一样的字符前边加上规定好的转义字符，这种方法称为字符填充或者是字节填充。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;差错检测：&lt;/strong&gt; 比特在传输过程中可能产生差错，差错检测就是用于检测出现的差错，以便及时的重传，最常用的差错检测算法就是&lt;a class=&#34;link&#34; href=&#34;http://baike.sogou.com/v7730112.htm?fromTitle=CRC%E6%A0%A1%E9%AA%8C&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CRC（循环冗余检验）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;网络层&#34;&gt;网络层&lt;/h1&gt;
&lt;p&gt;网络层主要是向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。&lt;/p&gt;
&lt;h2 id=&#34;ip协议网际协议&#34;&gt;IP协议（网际协议）：&lt;/h2&gt;
&lt;p&gt;IP协议是TCP/IP体系中最主要的协议之一，一切在IP之下，一切又在IP之上。我们常说的应该是IP协议族，还包含配套的协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ARP（地址解析协议）：将网络的IP地址转化为实际的物理地址（MAC地址），并存储在MAC地址表中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ICMP（网际控制报文协议）：用于进行差错情况和异常情况的反馈，分为询问报文和差错报告报文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IGMP（网际组管理协议）：用于控制和管理多播和组播的协议。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络地址（IP地址）主要分为五类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A类：前8位为网络位，后24位为主机位，首位为0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B类：前16位为网络位，后16位为主机位，前两位为10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C类：前24位为网络位，后8位位主机位，前三位为110&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;D类：前四位为1110，用于多播地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;E类：前四位为1111，保留为以后使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;路由选择协议&#34;&gt;路由选择协议：&lt;/h2&gt;
&lt;p&gt;路由选择协议分为&lt;strong&gt;内部网关协议（IGP）&lt;strong&gt;和&lt;/strong&gt;外部网关协议（EGP）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;内部网关协议&#34;&gt;内部网关协议：&lt;/h3&gt;
&lt;p&gt;主要是有RIP协议和OSPF协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**RIP协议（路由信息协议）：**基于距离矢量的协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**OSPF（开放最短路径优先协议）：**基于链路状态的协议&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;外部网关协议&#34;&gt;外部网关协议：&lt;/h3&gt;
&lt;p&gt;主要是&lt;strong&gt;边界网关协议（BGP）&lt;/strong&gt;，将一个大的网络分为多个小的自治域，每个自治域内有一个网关路由负责和其他的自治域的网关进行通讯。&lt;/p&gt;
&lt;h1 id=&#34;传输层&#34;&gt;传输层&lt;/h1&gt;
&lt;p&gt;网络层主要是为主机之间提供逻辑通讯，而传输层为应用程序之间提供端到端的逻辑通讯。主要是两种类型的通讯方式，面向连接的TCP协议和面向无连接的UDP。&lt;/p&gt;
&lt;h2 id=&#34;端口号&#34;&gt;端口号：&lt;/h2&gt;
&lt;p&gt;端口号按照使用地方的不同分为两大类：服务端端口号，客户端端口号。
按照占用时长又可以分为熟知端口号（0~1023），登记端口号（1024~49151），短暂端口号（49152~65535）&lt;/p&gt;
&lt;h3 id=&#34;常见端口&#34;&gt;常见端口：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FTP（文件传输协议）：20，21&amp;mdash;&amp;mdash;其中20端口用于传输数据，21端口用于命令控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Telnet（远程登录协议）：23&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNS（域名解析服务）：53&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TFTP（简单文件传输协议）：69&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP（超文本传输协议）：80&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;两种协议&#34;&gt;两种协议：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UDP（用户数据报协议）：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP是无连接的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP使用尽最大努力交付，但是不保证可靠交付&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP是面向报文的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP没有拥塞控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP支持一对一，一对多，多对一，多对一的交互通讯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP首部的开销小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TCP（传输控制协议）：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP是面向连接的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一条TCP连接只能由两个端点，每一条TCP连接只能是点对点的$TCP连接：：= { socket_1,socket_2 } ={ (IP_1:port_1),(IP_2:port_2)}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP提供可靠交付的服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP提供全双工通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向字节流&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;可靠传输的实现机制&#34;&gt;可靠传输的实现机制：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;停止等待协议：&lt;/strong&gt; 每发完一个分组就停止发送，直到收到上一个分组的确认信息。若超过规定时间没有接收到确认信息，边认为是分组丢失，开始重传。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连续ARQ协议：&lt;/strong&gt;  发送方采用滑动窗口的形式，处于滑动窗口的分组可以直接发送出去；接收方一般采用累积确认的方式，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认，而发送方每接收到一个确认，窗口就向前滑动一定距离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**流量控制：**协调发送方和接收方的收发速率，利用滑动窗口来协调，使用探测报文来探测当前应该发送的速率，采用&lt;a class=&#34;link&#34; href=&#34;http://baike.sogou.com/v10500918.htm?fromTitle=Nagle%E7%AE%97%E6%B3%95&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Nagle算法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;拥塞控制：&lt;/strong&gt;
当网络中某一资源的需求超出了该资源所能提供的可用部分，这时网络的性能就要开始变坏，这种情况就叫做拥塞。而拥塞控制就是为了减少或者避免拥塞对网络性能的影响而做出的一种控制手段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;拥塞控制思路：&lt;strong&gt;发送方维持一个叫做&lt;/strong&gt;拥塞窗口&lt;/strong&gt;的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的变化。发送方让自己的发送窗口等于拥塞窗口，如果在考虑接收方的接收能力，一般发送窗口还要小于拥塞窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**慢开始：**当主机开始发送数据的时候，由小到大的增大发送窗口，也就是由小到大的增大拥塞窗口。接收方接收到一个报文之后就回传一个确认报文，发送方每接收到一个确认报文，就将拥塞窗口加1，这样每经过一个传输轮次之后，拥塞窗口就增大一倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**拥塞避免：**思路是让拥塞窗口缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口加1，而不是加倍，这样拥塞窗口就是线性缓慢增加，比慢开始的增长速率缓慢的多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**慢开始门限：**为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个慢开始门限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拥塞窗口&amp;lt;慢开始门限时，使用慢开始算法&lt;/li&gt;
&lt;li&gt;拥塞窗口&amp;gt;慢开始门限时，使用拥塞避免算法&lt;/li&gt;
&lt;li&gt;拥塞窗口=慢开始门限时，两种算法都可以&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**快重传：**要求收到方每收到一个时序的报文段之后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。而发送方只要一连收到三个重复确认就应当立即重传对方尚未接受到的报文，而不必等待为报文设置的重传计时器到期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**快回复：**与快重传配合使用，当发送方连续收到三个重复确认的时候，就执行“乘法减小”算法，将慢开始门限减半。将拥塞窗口设置为慢开始门限减半之后的值，并开始指向拥塞避免算法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp的连接管理&#34;&gt;TCP的连接管理：&lt;/h3&gt;
&lt;h4 id=&#34;连接三次握手&#34;&gt;连接三次握手：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;客户端请求建立连接：SYN=1，seq=x；&lt;/li&gt;
&lt;li&gt;服务器对客户端的请求进行响应：SYN=1，ACK=1，seq=y，ack=x+1&lt;/li&gt;
&lt;li&gt;客户端对服务器端的响应信息进行回应：ACK=1，seq=x+1，ack=y+1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; SYN为同步信息，在建立连接过程中始终为1&lt;/p&gt;
&lt;h4 id=&#34;断开连接四次握手&#34;&gt;断开连接四次握手：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;客户端请求断开连接： FIN=1，seq = u；&lt;/li&gt;
&lt;li&gt;服务端对客户端的请求应答：ACK=1，seq=v，ack=u+1；&lt;/li&gt;
&lt;li&gt;服务端请求断开连接：FIN=1，ACK=1，seq=w，ack=u+1；&lt;/li&gt;
&lt;li&gt;客户端对服务端的请求应答：ACK=1，seq=u+1，ack=w+1；&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;应用层&#34;&gt;应用层&lt;/h1&gt;
&lt;p&gt;应用层有多种协议，常用到的就是HTTP以及HTTPS。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP协议报文格式&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;请求报文&lt;/th&gt;
&lt;th&gt;相应报文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;请求行（用于区分是请求报文还是响应报文，在响应报文中为状态行）&lt;/td&gt;
&lt;td&gt;状态行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;首部行（用来说明浏览器，服务器或者是报文主体的一些信息）&lt;/td&gt;
&lt;td&gt;首部行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空行（用于隔开请求实体和首部行）&lt;/td&gt;
&lt;td&gt;空行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;实体主体（用于一些请求或者是响应的的参数内容等）&lt;/td&gt;
&lt;td&gt;实体主体&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;常见状态码&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1xx：表示通知信息，例如表示收到或者是正在处理
2xx：表示成功，例如表示接受或知道了
3xx：表示重定向，例如表示完成请求还需要采取进一步的行动
4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成
5xx：表示服务器端的差错：例如表示服务器失效无法完成请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTPS协议就是对HTTP协议的加密，更加安全可靠，采用HTTP+SSL（安全套接字层）来保证数据的安全性。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java面试之基础题（Integer、String、内部类与final）</title>
        <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%A2%98integerstring%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8Efinal/</link>
        <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%A2%98integerstring%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8Efinal/</guid>
        <description>&lt;h2 id=&#34;integer&#34;&gt;Integer&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Integer a = 1000,b=1000;
Integer c = 100,d=100;    
@Test
public void testIntegerDD(){
    System.out.println(a==b);//false  
    System.out.println(c==d);//true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行代码，我们会得到 false  true。这道题笔试用经常出现，原理也很简单
,可看Integer源码valueOf(int i)方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Integer valueOf(int i) {
	if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
	return IntegerCache.cache[i + (-IntegerCache.low)];
	return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Integer 的缓存范围虽然默认是 -128 到 127，但是在特别的应用场景，比如我们明确知道应用会频繁使用更大的数值，这时候应该怎么办呢？&lt;br&gt;
缓存上限值实际是可以根据需要调整的，JVM 提供了参数设置：&lt;br&gt;
&lt;code&gt;-XX:AutoBoxCacheMax=N&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来，简单的扩展几个Integer的关系运算符==的比较。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testIntegerDD(){
	
    Integer a = 1000,b=1000;
    Integer c = 100,d=100;   
    Integer e = new Integer(100);
    Integer f = new Integer(100);
    int g = 1000;
    Integer h = new Integer(1000);	


    //1、进行自动装箱操作；2、Integer中把-128-127 缓存了下来
    System.out.println(a==b);//false  
    System.out.println(c==d);//true
	
    //这里并不是用的缓存，而是new创建的对象存放在堆内存中，俩个变量指向不同引用，所以结果是false
    System.out.println(e==f);//false
    //当int和Integer进行==比较的时候，Java会把Integer进行自动拆箱为int类型的值
    System.out.println(g==h);//true
	
    //进行自动装箱操作
    System.out.println(c==e);//false
    System.out.println(a==h);//false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;string&#34;&gt;String&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;==如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testStringDD() {
    String s1 = &amp;quot;hello&amp;quot;;
    String s2 = &amp;quot;hello&amp;quot;;
    String s3 = new String(&amp;quot;hello&amp;quot;);
	
    System.out.println(s1==s2); // true
    System.out.println(s1==s3); // false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文章解释：&lt;br&gt;
一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，而堆内存中则存放new出来的对象和数组。然而除此之外还有一块区域叫做常量池。&lt;br&gt;
像我们通常想String s1 = &amp;ldquo;hello&amp;rdquo;; 这样申明的字符串对象，其值就是存储在常量池中。&lt;br&gt;
当我们创建String s1 =&amp;ldquo;hello&amp;quot;这样一个对象之后，&amp;ldquo;hello&amp;quot;就存储到了常量池（也可叫做字符串池）中，当我们创建引用String s2  = &amp;ldquo;hello&amp;rdquo; 的时候，Java底层会优先在常量池中查找是否存在&amp;quot;hello&amp;rdquo;，如果存在则让s2指向这个值，不会重新创建，如果常量池中没有则创建并添加的池中。这就是为什么答案是true 和false的原因。&lt;/p&gt;
&lt;p&gt;接下来，还是简单的扩展几个String的关系运算符==的比较。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void testStringDD() {
    String s1 = &amp;quot;hello&amp;quot;;
    String s2 = &amp;quot;hello&amp;quot;;
    String s3 = new String(&amp;quot;hello&amp;quot;);
	
    //都存储在常量池中,指向同一常量
    System.out.println(s1==s2); // true
    //存储在常量池中,存储在堆内存中
    System.out.println(s1==s3); // false
	
    String s4 = &amp;quot;helloo&amp;quot;;
    /**
     * 会重新在常量池创建常量（String不可变属性）
     */
    String s5 = s1+&amp;quot;o&amp;quot;;
    //字符串拼接有变量参与，底层调用StringBuffer处理，相当于在堆内存中开辟了新空间
    System.out.println(s4 == s5); // false
    //常量相加，先在常量池找，找到即用
    System.out.println(s4 == &amp;quot;hello&amp;quot;+&amp;quot;o&amp;quot;);//true

    //hello
    String s6 = s4.substring(0, s4.length() - 1);
    //substring返回的也是new出来的String对象
    System.out.println(s1 == s6); // false
    //地址值不一样
    System.out.println(s3 == s6); // false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;扩展：equals方法。equals方法不能作用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。&lt;/p&gt;
&lt;h2 id=&#34;内部类与final&#34;&gt;内部类与final&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public void mRun(final String name){
    new Runnable() {
        public void run() {
            try {
              Thread.sleep(1000);
           } catch (InterruptedException e) {
             // TODO Auto-generated catch block
            e.printStackTrace();
           }  
           System.out.println(name);
        }
    }.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文章解释：&lt;br&gt;
这种代码相信大家写过很多，当内部类访问局部变量的时候，需要在局部变量前加final修饰符，不然编译器就会报错。通常我们也是这么干的。&lt;/p&gt;
&lt;p&gt;为什么要加final修饰符？&lt;br&gt;
首先内部类的生命周期是成员级别的，而局部变量的生命周期实在方法体之类。也就是说会出现这样一种情况，当mRun方法执行，new 的线程运行，新线程里面会睡一秒。&lt;br&gt;
主线程会继续执行，mRun执行完毕，name属性生命周期结束。1秒之后，Syetem.out.printh(name)执行。然而此时name已经寿终正寝，不在内存中了。&lt;/p&gt;
&lt;p&gt;Java就是为了杜绝这种错误，严格要求内部类中方位局部变量，必须使用final关键字修饰。&lt;br&gt;
局部变量被final修饰之后，此时会在内存中保有一份局部变得的复制品，当内部类访问的时候其实访问的是这个复制品。这就好像是把局部变量的生命周期变长了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SpringBoot初体验</title>
        <link>https://ianeiu.github.io/p/springboot%E5%88%9D%E4%BD%93%E9%AA%8C/</link>
        <pubDate>Thu, 01 Nov 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/springboot%E5%88%9D%E4%BD%93%E9%AA%8C/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;如非说明，皆是使用1.5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文只进行简单的代码提示，具体内容可自行百度&lt;/p&gt;
&lt;h3 id=&#34;cxf&#34;&gt;CXF&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;@Bean
public ServletRegistrationBean CXFServlet() {
    ServletRegistrationBean cxfBean = new ServletRegistrationBean(new CXFServlet(), &amp;quot;/webservice/*&amp;quot;);
    cxfBean.setName(&amp;quot;CXFServlet&amp;quot;);
    cxfBean.setLoadOnStartup(1);
    return cxfBean;
}

@Configuration
public class CXFConfig {
    @Autowired
    private Bus bus;
    @Autowired
    private SSOService sSOService;
	
    @Bean
    public Endpoint endpointSSO() {
        EndpointImpl endpoint = new EndpointImpl(bus, sSOService);
        endpoint.publish(&amp;quot;/sso&amp;quot;);
        return endpoint;
    }
	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;错误页面配置&#34;&gt;错误页面配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 跳转至错误页面
 * add 2018.07.11
 * @author wm
 * @param code
 * @return
 */
@RequestMapping(&amp;quot;/error/{code}&amp;quot;)
public String goToErrorPage(@PathVariable(value=&amp;quot;code&amp;quot;) String code){
    return code;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新增拦截器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 错误页面拦截器
 * 替代EmbeddedServletContainerCustomizer在war中不起作用的方法
 * @author wm
 */
@Component
public class ErrorPageInterceptor extends HandlerInterceptorAdapter {
    private List&amp;lt;Integer&amp;gt; errorCodeList = Arrays.asList(404,500);
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws
        Exception {
       if (errorCodeList.contains(response.getStatus())) {
            response.sendRedirect(request.getContextPath()+&amp;quot;/error/&amp;quot; + response.getStatus());
            return false;
        }
        return super.preHandle(request, response, handler);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新增拦截配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(errorPageInterceptor);//.addPathPatterns(&amp;quot;/action/**&amp;quot;, &amp;quot;/mine/**&amp;quot;);默认所有
    super.addInterceptors(registry);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;兼容jsp&#34;&gt;兼容JSP&lt;/h3&gt;
&lt;p&gt;pom新增：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    ...
    &amp;lt;!--jsp支持 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 配置jsp-jstl的支持 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;javax.servlet.jsp.jstl&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jstl-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    ...
&amp;lt;/dependencies&amp;gt;

&amp;lt;build&amp;gt; 
    ...
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/webapp&amp;lt;/directory&amp;gt;
            &amp;lt;!-- 处理jar包启动无法访问jsp的问题 --&amp;gt;
            &amp;lt;targetPath&amp;gt;META-INF/resources&amp;lt;/targetPath&amp;gt;
            &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/**&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
        &amp;lt;/resource&amp;gt; 
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新增配置类（处理jar包启动无法访问jsp的问题）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.catalina.Context;
import org.apache.catalina.Lifecycle;
import org.apache.catalina.LifecycleEvent;
import org.apache.catalina.LifecycleListener;
import org.apache.catalina.WebResourceRoot.ResourceSetType;
import org.springframework.util.ResourceUtils;

/**
 * Add main class fat jar/exploded directory into tomcat ResourceSet.
 *
 * @author hengyunabc 2017-07-29
 *
 */
public class StaticResourceConfigurer implements LifecycleListener {

    private final Context context;

    public StaticResourceConfigurer(Context context) {
        this.context = context;
    }

    @Override
    public void lifecycleEvent(LifecycleEvent event) {
        if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
            URL location = this.getClass().getProtectionDomain().getCodeSource().getLocation();

            if (ResourceUtils.isFileURL(location)) {
                // when run as exploded directory
                String rootFile = location.getFile();
                if (rootFile.endsWith(&amp;quot;/BOOT-INF/classes/&amp;quot;)) {
                    rootFile = rootFile.substring(0, rootFile.length() - &amp;quot;/BOOT-INF/classes/&amp;quot;.length() + 1);
                }
                if (!new File(rootFile, &amp;quot;META-INF&amp;quot; + File.separator + &amp;quot;resources&amp;quot;).isDirectory()) {
                    return;
                }

                try {
                    location = new File(rootFile).toURI().toURL();
                } catch (MalformedURLException e) {
                    throw new IllegalStateException(&amp;quot;Can not add tomcat resources&amp;quot;, e);
                }
            }

            String locationStr = location.toString();
            if (locationStr.endsWith(&amp;quot;/BOOT-INF/classes!/&amp;quot;)) {
                // when run as fat jar
                locationStr = locationStr.substring(0, locationStr.length() - &amp;quot;/BOOT-INF/classes!/&amp;quot;.length() + 1);
                try {
                    location = new URL(locationStr);
                } catch (MalformedURLException e) {
                    throw new IllegalStateException(&amp;quot;Can not add tomcat resources&amp;quot;, e);
                }
            }
            this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &amp;quot;/&amp;quot;, location,
                    &amp;quot;/META-INF/resources&amp;quot;);

        }
    }
}

import org.apache.catalina.Context;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;
import org.springframework.boot.context.embedded.tomcat.TomcatContextCustomizer;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import cn.com.do1.component.config.assembly.StaticResourceConfigurer;

/**
 * 处理jar包启动无法访问jsp的问题
 * &amp;lt;p&amp;gt;Title: TomcatConfig&amp;lt;/p&amp;gt;  
 * &amp;lt;p&amp;gt;Description: &amp;lt;/p&amp;gt;  
 * @author wm  
 * @date 2018年7月24日
 */
@Configuration
@ConditionalOnProperty(name = &amp;quot;tomcat.staticResourceCustomizer.enabled&amp;quot;, matchIfMissing = true)
public class TomcatConfig {
    @Bean
    public EmbeddedServletContainerCustomizer staticResourceCustomizer() {
        return new EmbeddedServletContainerCustomizer() {
            @Override
            public void customize(ConfigurableEmbeddedServletContainer container) {
                if (container instanceof TomcatEmbeddedServletContainerFactory) {
                    ((TomcatEmbeddedServletContainerFactory) container)
                            .addContextCustomizers(new TomcatContextCustomizer() {
                                @Override
                                public void customize(Context context) {
                                    context.addLifecycleListener(new StaticResourceConfigurer(context));
                                }
                            });
                }
            }

        };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;静态资源&#34;&gt;静态资源&lt;/h3&gt;
&lt;p&gt;方式一：&lt;br&gt;
pom新增配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;resources&amp;gt;
    &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src/main/webapp&amp;lt;/directory&amp;gt;
        &amp;lt;!--注意此次必须要放在此目录下才能被访问到--&amp;gt;
        &amp;lt;targetPath&amp;gt;META-INF/resources&amp;lt;/targetPath&amp;gt;
        &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;**/**&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
    &amp;lt;/resource&amp;gt;
&amp;lt;/resources&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新增配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler(&amp;quot;/js/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/META-INF/resources/WEB-INF/js/&amp;quot;);
    registry.addResourceHandler(&amp;quot;/css/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/META-INF/resources/WEB-INF/css/&amp;quot;);
    registry.addResourceHandler(&amp;quot;/images/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/META-INF/resources/WEB-INF/images/&amp;quot;);
    registry.addResourceHandler(&amp;quot;/common/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/META-INF/resources/WEB-INF/common/&amp;quot;);
    registry.addResourceHandler(&amp;quot;/register/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/META-INF/resources/WEB-INF/register/&amp;quot;);
    registry.addResourceHandler(&amp;quot;/plugin/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/META-INF/resources/WEB-INF/plugin/&amp;quot;);
    super.addResourceHandlers(registry);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式二（推荐）：&lt;br&gt;
将静态资源文件放到resouce/static目录下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler(&amp;quot;/js/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/static/js/&amp;quot;);
    registry.addResourceHandler(&amp;quot;/css/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/static/css/&amp;quot;);
    registry.addResourceHandler(&amp;quot;/images/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/static/images/&amp;quot;);
    registry.addResourceHandler(&amp;quot;/register/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/static/register/&amp;quot;);
    registry.addResourceHandler(&amp;quot;/plugin/**&amp;quot;).addResourceLocations(&amp;quot;classpath:/static/plugin/&amp;quot;);
    super.addResourceHandlers(registry);
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文件上传&#34;&gt;文件上传&lt;/h3&gt;
&lt;p&gt;现象：上传文件返回异常java.lang.ClassCastException:   org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile cannot be cast to org.springframework.web.multipart.commons.CommonsMultipartFile&lt;br&gt;
原因：FileUtil中multipartToFile的代码片段  CommonsMultipartFile cf = (CommonsMultipartFile)multfile  与springboot自带的org.springframework.web.multipart.MultipartFile冲突&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import org.springframework.web.multipart.commons.CommonsMultipartResolver;//这是旧项目引入的  
import org.springframework.web.multipart.MultipartFile;//这是springboot整合的  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决：采用输入流方式获取File对象，具体代码自行百度&lt;/p&gt;
&lt;p&gt;配置文件新增：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#upload
spring.http.multipart.enabled=true
spring.http.multipart.file-size-threshold=0  #0-ALLFILE
spring.http.multipart.location=D:/fsrzfw/temp
spring.http.multipart.max-file-size=10Mb
spring.http.multipart.max-request-size=10Mb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新增配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 配置上传文件大小的配置
 * @return
 */
@Bean
public MultipartConfigElement multipartConfigElement() {
   MultipartConfigFactory factory = new MultipartConfigFactory();
   //  单个数据大小
   factory.setMaxFileSize(&amp;quot;102400KB&amp;quot;);
   /// 总上传数据大小
   factory.setMaxRequestSize(&amp;quot;102400KB&amp;quot;);
   return factory.createMultipartConfig();
}

/**
 * MultipartFile 转换成File
 * update by wm 2018.07.12
 * @param multfile 原文件类型
 * @return File
 * @throws IOException
 */
public static File multipartToFile(MultipartFile multfile) throws IOException {
    //Springboot自带上传不支持CommonsMultipartFile
    //CommonsMultipartFile cf = (CommonsMultipartFile)multfile;
    //这个myfile是MultipartFile的
    //DiskFileItem fi = (DiskFileItem) cf.getFileItem();
    //return fi.getStoreLocation();

    File f = null;
    if (&amp;quot;&amp;quot;.equals(multfile) || multfile.getSize() &amp;lt;= 0) {
        multfile = null;
    } else {
        InputStream ins = multfile.getInputStream();
        f = new File(multfile.getOriginalFilename());
        StreamUtil.streamSaveAsFile(ins, f);
    }
    return f;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打jar包运行&#34;&gt;打JAR包运行&lt;/h3&gt;
&lt;p&gt;pom新增配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;finalName&amp;gt;fsrzfw&amp;lt;/finalName&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
                &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
                &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;mainClass&amp;gt;cn.com.do1.component.Application&amp;lt;/mainClass&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
            &amp;lt;dependencies&amp;gt;
                &amp;lt;!-- spring热部署 --&amp;gt;
                &amp;lt;dependency&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;springloaded&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;1.2.6.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;
            &amp;lt;/dependencies&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-resources-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;nonFilteredFileExtensions&amp;gt;
                    &amp;lt;nonFilteredFileExtension&amp;gt;ttf&amp;lt;/nonFilteredFileExtension&amp;gt;
                    &amp;lt;nonFilteredFileExtension&amp;gt;woff&amp;lt;/nonFilteredFileExtension&amp;gt;
                    &amp;lt;nonFilteredFileExtension&amp;gt;woff2&amp;lt;/nonFilteredFileExtension&amp;gt;
                &amp;lt;/nonFilteredFileExtensions&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/**&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
        &amp;lt;/resource&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/resource&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/**&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
        &amp;lt;/resource&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/webapp&amp;lt;/directory&amp;gt;
            &amp;lt;!-- 处理jar包启动无法访问jsp的问题 --&amp;gt;
            &amp;lt;targetPath&amp;gt;META-INF/resources&amp;lt;/targetPath&amp;gt;
            &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/**&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
        &amp;lt;/resource&amp;gt; 
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;shiro-自定义-filter-匹配异常无限拦截重定向&#34;&gt;Shiro 自定义 filter 匹配异常，无限拦截重定向&lt;/h3&gt;
&lt;p&gt;参考：&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.hillfly.com/2017/179.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Shiro 自定义 filter 匹配异常&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
原因：自定义Filter注册为了 Bean交给 Spring托管,它会被自动注册到  FilterChain中。请求先经过自定义Filter，导致请求被其先消费掉了，而ShiroFilter成了摆设。 &lt;br&gt;
解决：FUN1、利用 FilterRegistrationBean 注册自定义 Filter （建议使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ex：
    @Bean
    public CasFilter casFilter(){
        CasFilter cf = new CasFilter();
        cf.setSuccessUrl(successUrl);
        cf.setFailureUrl(failureUrl);
        return cf;
    }
	
    /**
     * 注册casFilter
     * @param casFilter
     * @return
     */
    @Bean
    public FilterRegistrationBean registCasFilter(CasFilter casFilter) {
        FilterRegistrationBean cas = new FilterRegistrationBean();
        cas.setFilter(casFilter);
        cas.setEnabled(false);	//该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理  x
        return cas;
    }
	
    /**
     * 注册shiroFilter
     * @param securityManager
     * @param casFilter
     * @param logoutFilter
     * @return
     */
    @Bean
    public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager,
            CasFilter casFilter,LogoutFilter logoutFilter) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        ...
        Map&amp;lt;String,Filter&amp;gt; filters = new HashMap&amp;lt;&amp;gt;();
        filters.put(&amp;quot;casFilter&amp;quot;,casFilter);
        filters.put(&amp;quot;logoutFilter&amp;quot;, logoutFilter);
        shiroFilterFactoryBean.setFilters(filters);		//添加casFilter到shiroFilter
        ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FUN2、将 CasFilter注册为了 Bean交给 Spring托管,它会被自动注册到 FilterChain中，那我们如果不把它注册为 Bean就可以避免这个问题了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    ex:
    /**
     * 注册shiroFilter
     * @param securityManager
     * @return
     */
    @Bean
    public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        ...
        Map&amp;lt;String,Filter&amp;gt; filters = new HashMap&amp;lt;&amp;gt;();
        filters.put(&amp;quot;casFilter&amp;quot;,new CasFilter());
        filters.put(&amp;quot;logoutFilter&amp;quot;, new LogoutFilter());
        shiroFilterFactoryBean.setFilters(filters);		//添加casFilter到shiroFilter
        ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;日志&#34;&gt;日志&lt;/h3&gt;
&lt;p&gt;现象：启动报错Caused by: java.lang.NoClassDefFoundError: ch/qos/logback/classic/turbo/TurboFilter&lt;br&gt;
原因:springboot1.3.x和1.3.x以下版本才支持log4j的日志配置，1.3.x以上版本只支持log4j2和logback的日志配置&lt;br&gt;
解决：使用log4j2或logback&lt;/p&gt;
&lt;h3 id=&#34;jar包运行获取某个包下的class对象集合&#34;&gt;jar包运行获取某个包下的class对象集合&lt;/h3&gt;
&lt;p&gt;现象：项目mvn install后jar包，启动报错，未获取到某个包下的class对象集合&lt;br&gt;
原因：springboot项目打包后获取包资源所在路径与启动main不一样&lt;br&gt;
ex：//jarPaht:file:/E:/IDEABuilder/fs/tyrz-springboot/tyrz-front/target/fsrzfw.jar!/BOOT-INF/classes!/cn/com/do1/component/identitySource/service/impl&lt;br&gt;
解决：逐一分割路径获取类对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 获得包下面的所有的class
 * @author FengHuayuan
 * @date 2018年4月21日 下午12:25:20.
 * @param pack
 * @return
 */
public static List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; getClassesFromPackage(String pack) {
    List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; clazzs = new ArrayList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();
    // 是否循环搜索子包
    boolean recursive = true;
    // 包名字
    String packageName = pack;
    // 包名对应的路径名称
    String packageDirName = packageName.replace(&#39;.&#39;, &#39;/&#39;);
    Enumeration&amp;lt;URL&amp;gt; dirs;
    try {
        dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);
        while (dirs.hasMoreElements()) {
            URL url = dirs.nextElement();
            String protocol = url.getProtocol();
            if (&amp;quot;file&amp;quot;.equals(protocol)) {
                log.debug(&amp;quot;*****【File类型】的扫描！&amp;quot;);
                String filePath = URLDecoder.decode(url.getFile(), &amp;quot;UTF-8&amp;quot;);
                findClassInPackageByFile(packageName, filePath, recursive, clazzs);
            } else if (&amp;quot;jar&amp;quot;.equals(protocol)) {
                log.debug(&amp;quot;*****【Jar类型】的扫描！&amp;quot;);
                String filePath = URLDecoder.decode(url.getFile(), &amp;quot;UTF-8&amp;quot;);
                getClasssFromJarFile(filePath, clazzs);//wm add
            }
        }

    } catch (Exception e) {
        log.error(e.getMessage(),e);
    }
    return clazzs;
}

/** 
 * 从jar文件中读取指定目录下面的所有的class文件 
 * springboot打jar包专用
 * @author wm
 * @param jarPaht   jar文件存放的位置 
 * @param filePaht    指定的文件目录 
 * @param clazzs 所有的的class的对象 
 */  
public static void getClasssFromJarFile(String jarPath,List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; clazzs) {  

    log.info(&amp;quot;getClasssFromJarFile - jarPath:&amp;quot;+jarPath);//wm
    //jarPaht:file:/E:/IDEABuilder/fs/tyrz-springboot/tyrz-front/target/fsrzfw.jar!/BOOT-INF/classes!/cn/com/do1/component/identitySource/service/impl
    String[] jarPaths = jarPath.split(&amp;quot;!&amp;quot;);
    String jarPaht=jarPaths[0].substring(6);//去掉file:/
    String startDir = (jarPaths[1]+jarPaths[2]).substring(1);//去掉/
	
    JarFile jarFile = null;  
    try {  
        jarFile = new JarFile(jarPaht);  
    } catch (IOException e1) {  
        e1.printStackTrace();  
    }  
  
    List&amp;lt;JarEntry&amp;gt; jarEntryList = new ArrayList&amp;lt;JarEntry&amp;gt;();  
  
    Enumeration&amp;lt;JarEntry&amp;gt; ee = jarFile.entries();  
    while (ee.hasMoreElements()) {  
        JarEntry entry = (JarEntry) ee.nextElement();  
        if (entry.getName().startsWith(startDir) &amp;amp;&amp;amp; entry.getName().endsWith(&amp;quot;.class&amp;quot;)) {  
            log.info(&amp;quot;getClasssFromJarFile - entry:&amp;quot;+entry.getName());//wm
            jarEntryList.add(entry);  
        }  
    }  
    for (JarEntry entry : jarEntryList) {  
        String className = entry.getName().replace(&#39;/&#39;, &#39;.&#39;);  
        //   BOOT-INF/classes/cn/com/do1/component/identitySource/service/impl/XXX.class
        className = className.substring(17, className.length() - 6);//去掉  BOOT-INF/classes/     .class
        try {  
            clazzs.add(Thread.currentThread().getContextClassLoader().loadClass(className));  
        } catch (ClassNotFoundException e) {  
            e.printStackTrace();  
        }  
    }  
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;诡异的异常&#34;&gt;诡异的异常&lt;/h3&gt;
&lt;p&gt;启动项目报错ClassNotFoundException: javax.ws.rs.core.Response$StatusType&lt;br&gt;
解决：pom引入jsr311-api（g:javax.ws.rs）(a:jsr311-api)（v:1.1.1）&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Spring拦截器</title>
        <link>https://ianeiu.github.io/p/spring%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
        <pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/spring%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;接到一个需求，将已开发完成的系统接入权限系统。其中需要在多处请求返回的ModelAndView中添加权限代码集合，方便显示层做菜单按钮的显示控制。所以当时想法是新建一个拦截器对这几个请求做统一处理（放入权限代码集合），类似之前项目的错误页面拦截器。&lt;/p&gt;
&lt;h2 id=&#34;拦截器简介&#34;&gt;拦截器简介&lt;/h2&gt;
&lt;p&gt;Spring 框架实现拦截器功能主要有两种方法，第一种是实现&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口，第二种是实现&lt;code&gt;WebRequestInterceptor&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;HandlerInterceptor接口&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;通过实现HandlerInterceptor接口，重写方法&lt;code&gt;preHandle()&lt;/code&gt;、&lt;code&gt;postHandle()&lt;/code&gt;和&lt;code&gt;afterCompletion()&lt;/code&gt;拦截请求。Spring 框架中还提供了另外一个接口和一个抽象类，实现了对HandlerInterceptor接口的功能扩展，分别为：AsyncHandlerInterceptor和HandlerInterceptorAdapter。&lt;/p&gt;
&lt;p&gt;对于AsyncHandlerInterceptor接口，其在继承HandlerInterceptor接口的同时，又声明了一个新的方法&lt;code&gt;afterConcurrentHandlingStarted()&lt;/code&gt;；&lt;br&gt;
而HandlerInterceptorAdapter抽象类，在其继承AsyncHandlerInterceptor接口的同时，又复写了preHandle方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)&lt;/code&gt;方法，该方法在请求处理之前进行调用。SpringMVC 中的 Interceptor 是链式调用的，在一个应用中或者说是在一个请求中可以同时存在多个 Interceptor 。每个 Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是 Interceptor 中的 preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求做一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值 Boolean 类型的，当它返回为 false 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 true 时，就会继续调用下一个 Interceptor 的 preHandle 方法，如果已经是最后一个 Interceptor 的时候，就会是调用当前请求的 Controller 中的方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)&lt;/code&gt;方法，通过 preHandle 方法的解释咱们知道这个方法包括后面要说到的 afterCompletion 方法都只能在当前所属的 Interceptor 的 preHandle 方法的返回值为 true 的时候，才能被调用。postHandle 方法在当前请求进行处理之后，也就是在 Controller 中的方法调用之后执行，但是它会在 DispatcherServlet 进行视图返回渲染之前被调用，所以咱们可以在这个方法中对 Controller 处理之后的 ModelAndView 对象进行操作。postHandle 方法被调用的方向跟 preHandle 是相反的，也就是说，先声明的 Interceptor 的 postHandle 方法反而会后执行。这和 Struts2 里面的 Interceptor 的执行过程有点类型，Struts2 里面的 Interceptor 的执行过程也是链式的，只是在 Struts2 里面需要手动调用 ActionInvocation 的 invoke 方法来触发对下一个 Interceptor 或者是 action 的调用，然后每一个 Interceptor 中在 invoke 方法调用之前的内容都是按照声明顺序执行的，而 invoke 方法之后的内容就是反向的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)&lt;/code&gt;方法，也是需要当前对应的 Interceptor 的 preHandle 方法的返回值为 true 时才会执行。因此，该方法将在整个请求结束之后，也就是在 DispatcherServlet 渲染了对应的视图之后执行，这个方法的主要作用是用于进行资源清理的工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;WebRequestInterceptor接口&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;在WebRequestInterceptor接口中也定义了 3 个方法，方法名同HandlerInterceptor接口相同，3 个方法都传递了同一个参数 WebRequest。WebRequest 是 Spring 中定义的一个接口，它里面的方法定义跟 HttpServletRequest 类似，在WebRequestInterceptor中对 WebRequest 进行的所有操作都将同步到 HttpServletRequest 中，然后在当前请求中依次传递。&lt;/p&gt;
&lt;p&gt;Spring框架中还提供了WebRequestInterceptorAdapter，其实现了AsyncHandlerInterceptor接口，并在内部调用了WebRequestInterceptor接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;preHandle(WebRequest request)&lt;/code&gt;方法，该方法在请求处理之前进行调用，也就是说，其会在 Controller 中的方法调用之前被调用。这个方法跟 HandlerInterceptor 中的 preHandle 不同，主要区别在于该方法的返回值是void 类型的，也就是没有返回值，因此我们主要用它来进行资源的准备工作，比如我们在使用 Hibernate 的时候，可以在这个方法中准备一个 Hibernate 的Session 对象，然后利用 WebRequest 的 setAttribute(name, value, scope) 把它放到 WebRequest 的属性中。在这里，进一步说说 setAttribute 方法的第三个参数 scope ，该参数是一个Integer 类型的。在 WebRequest 的父层接口 RequestAttributes 中对它定义了三个常量，分别为：
&lt;ul&gt;
&lt;li&gt;SCOPE_REQUEST ，它的值是 0，表示只有在 request 中可以访问。&lt;/li&gt;
&lt;li&gt;SCOPE_SESSION，它的值是1，如果环境允许的话，它表示的是一个局部的隔离的 session，否则就代表普通的 session，并且在该 session 范围内可以访问。&lt;/li&gt;
&lt;li&gt;SCOPE_GLOBAL_SESSION，它的值是 2，如果环境允许的话，它表示的是一个全局共享的 session，否则就代表普通的 session，并且在该 session 范围内可以访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postHandle(WebRequest request, ModelMap model)&lt;/code&gt;方法，该方法在请求处理之后，也就是在 Controller 中的方法调用之后被调用，但是会在视图返回被渲染之前被调用，所以可以在这个方法里面通过改变数据模型 ModelMap 来改变数据的展示。该方法有两个参数，WebRequest 对象是用于传递整个请求数据的，比如在 preHandle 中准备的数据都可以通过 WebRequest 来传递和访问；ModelMap 就是 Controller 处理之后返回的 Model 对象，咱们可以通过改变它的属性来改变返回的 Model 模型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;afterCompletion(WebRequest request, Exception ex)&lt;/code&gt;方法，该方法会在整个请求处理完成，也就是在视图返回并被渲染之后执行。因此可以在该方法中进行资源的释放操作。而 WebRequest 参数就可以把咱们在 preHandle 中准备的资源传递到这里进行释放。Exception 参数表示的是当前请求的异常对象，如果在 Controller 中抛出的异常已经被 Spring 的异常处理器给处理了的话，那么这个异常对象就是是 null.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;来源：&lt;!-- raw HTML omitted --&gt;作者：维C果糖 | 文章：述 Spring MVC 框架中拦截器 Interceptor 的使用方法&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;拦截器code&#34;&gt;拦截器CODE&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;实现HandlerInterceptor 接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    import cn.com.do1.component.core.shirocas.model.UserVO;
    import cn.com.do1.component.util.HttpPermissionUtil;
    import org.apache.shiro.SecurityUtils;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.stereotype.Component;
    import org.springframework.web.servlet.HandlerInterceptor;
    import org.springframework.web.servlet.ModelAndView;

    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.util.List;

    /**
     * 点击菜单拦截器
     * @author wm
     * @date 2018.10.29
     */
    @Component
    public class ClickMenuInterceptor implements HandlerInterceptor {

        @Value(&amp;quot;${qxws.identifier}&amp;quot;)
        private String systemId;

        @Override
        public boolean preHandle(HttpServletRequest request,
                                 HttpServletResponse response, Object handler) throws Exception {
            return true;
        }

        @Override
        public void postHandle(HttpServletRequest request,
                               HttpServletResponse response, Object handler,
                               ModelAndView modelAndView) throws Exception {
            UserVO user = (UserVO) SecurityUtils.getSubject().getSession().getAttribute(&amp;quot;user&amp;quot;);
            List&amp;lt;String&amp;gt; buttonList = HttpPermissionUtil.getButtonPermission(user.getUserId(), systemId);
            modelAndView.addObject(&amp;quot;buttonList&amp;quot;,buttonList);
        }

        @Override
        public void afterCompletion(HttpServletRequest request,
                                    HttpServletResponse response, Object handler, Exception ex)
                throws Exception {

        }

    } 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;`&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现WebRequestInterceptor接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    import org.springframework.ui.ModelMap;
    import org.springframework.web.context.request.WebRequest;
    import org.springframework.web.context.request.WebRequestInterceptor;

    /**
     * @author wm
     * @Description ClinkMenuInterceptor2
     * @date 2018/10/30 15:34
     * @Version 1.0
     */
    public class ClinkMenuInterceptor2 implements WebRequestInterceptor {
           
        @Override
        public void preHandle(WebRequest request) throws Exception {
               
        }

        @Override
        public void postHandle(WebRequest request, ModelMap model) throws Exception {

        }

        @Override
        public void afterCompletion(WebRequest request, Exception ex) throws Exception {

        }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;`&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继承HandlerInterceptorAdapter类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    import java.util.Arrays;
    import java.util.List;

    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;

    import org.springframework.stereotype.Component;
    import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
    /**
     * 错误页面拦截器
     * 替代EmbeddedServletContainerCustomizer在war中不起作用的方法
     * @author wm
     */
    @Component
    public class ErrorPageInterceptor extends HandlerInterceptorAdapter {
        private List&amp;lt;Integer&amp;gt; errorCodeList = Arrays.asList(404,500);
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws
            Exception {
           if (errorCodeList.contains(response.getStatus())) {
                response.sendRedirect(request.getContextPath()+&amp;quot;/error/&amp;quot; + response.getStatus());
                return false;
            }
            return super.preHandle(request, response, handler);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;`&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SpringMVC&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;!--权限接入：拦截器--&amp;gt;
    &amp;lt;mvc:interceptors&amp;gt;
        &amp;lt;mvc:interceptor&amp;gt;
            &amp;lt;mvc:mapping path=&amp;quot;/identitySource/goIdentitySourceList&amp;quot;/&amp;gt;
            &amp;lt;mvc:mapping path=&amp;quot;/userManager/goUserManagerListPage&amp;quot;/&amp;gt;
            &amp;lt;mvc:mapping path=&amp;quot;/schedulemgr/goScheduleListPage&amp;quot;/&amp;gt;
            &amp;lt;bean class=&amp;quot;cn.com.do1.component.security.interceptor.ClickMenuInterceptor&amp;quot;/&amp;gt;
        &amp;lt;/mvc:interceptor&amp;gt;
    &amp;lt;/mvc:interceptors&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SpringBoot&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Bean
    public ClickMenuInterceptor getClickMenuInterceptor() {
        return new ClickMenuInterceptor();
    }
    /**
     * 新增security拦截器
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(getClickMenuInterceptor()).
                addPathPatterns(&amp;quot;/identitySource/goIdentitySourceList&amp;quot;,
                        &amp;quot;/userManager/goUserManagerListPage&amp;quot;,
                        &amp;quot;/schedulemgr/goScheduleListPage&amp;quot;);
        super.addInterceptors(registry);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;      @Autowired
      private ErrorPageInterceptor errorPageInterceptor;//错误拦截器（拦截404，500）
      /**
       * 新增拦截器
       */
      @Override
      public void addInterceptors(InterceptorRegistry registry) {
          registry.addInterceptor(errorPageInterceptor);//默认拦截所有
          super.addInterceptors(registry);
      }
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>JVM笔记之JVM类加载机制</title>
        <link>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
        <description>&lt;h1 id=&#34;虚拟机类加载机制&#34;&gt;虚拟机类加载机制&lt;/h1&gt;
&lt;p&gt;虚拟机把描述类的数据从Class文件&lt;strong&gt;加载&lt;/strong&gt;到内存，并对数据进行&lt;strong&gt;校验&lt;/strong&gt;、&lt;strong&gt;转换（准备）&lt;/strong&gt;、&lt;strong&gt;解析&lt;/strong&gt;和&lt;strong&gt;初始化&lt;/strong&gt;，最终形成可以被Java虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。&lt;/p&gt;
&lt;p&gt;类从被加载到虚拟内存中开始，到卸载内存为止，它的整个生命周期包括了：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)七个阶段。&lt;br&gt;
其中，验证，准备和解析三个部分统称为连接(Linking)。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;类加载的过程&#34;&gt;类加载的过程&lt;/h3&gt;
&lt;p&gt;类加载的全过程，加载，验证，准备，解析和初始化这五个阶段。&lt;/p&gt;
&lt;h4 id=&#34;加载&#34;&gt;加载&lt;/h4&gt;
&lt;p&gt;在加载阶段，虚拟机需要完成以下三件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过一个类的全限定名来获取定义此类的二进制字节流&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构&lt;/li&gt;
&lt;li&gt;在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等&lt;/p&gt;
&lt;h4 id=&#34;验证&#34;&gt;验证&lt;/h4&gt;
&lt;p&gt;这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能有所不同，但大致上都会完成下面四个阶段的检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件格式验证&lt;/strong&gt; 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元数据验证&lt;/strong&gt; 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节码验证&lt;/strong&gt; 整个验证过程中最复杂的一个阶段，主要工作是数据流和控制流的分析。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号引用验证&lt;/strong&gt; 发生在虚拟机将符号引用直接转化为直接引用的时候，这个转化动作将在连接的第三个阶段－解析阶段产生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;准备&#34;&gt;准备&lt;/h4&gt;
&lt;p&gt;正式为类变量分配内存并设置类变量初始值的阶段（创建类或接口中的静态变量，并初始化静态变量的初始值），这些内存都将在方法区进行分配。&lt;/p&gt;
&lt;h4 id=&#34;解析&#34;&gt;解析&lt;/h4&gt;
&lt;p&gt;解析阶段是虚拟机将常量池的符号引用转换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。&lt;/p&gt;
&lt;h4 id=&#34;初始化&#34;&gt;初始化&lt;/h4&gt;
&lt;p&gt;前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由Java虚拟机主导和控制。&lt;br&gt;
到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。
在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者说初始化阶段是执行类构造器&lt;!-- raw HTML omitted --&gt;()方法的过程。&lt;/p&gt;
&lt;p&gt;真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;准备阶段-常量和不同静态变量有什么区别&#34;&gt;准备阶段 常量和不同静态变量有什么区别&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class CLPreparation {
    public static int a = 100;
    public static final int INT_CONSTANT = 1000;
    public static final Integer INTEGER_CONSTANT = Integer.valueOf(10000);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译并反编译一下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javac CLPreparation.java
javap –v CLPreparation.class
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;static {};
    descriptor: ()V
    flags: ACC_STATIC
    Code:
      stack=1, locals=0, args_size=0
         0: bipush        100
         2: putstatic     #2                  // Field a:I
         5: sipush        10000
         8: invokestatic  #3                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        11: putstatic     #4                  // Field INTEGER_CONSTANT:Ljava/lang/Integer;
        14: return
      LineNumberTable:
        line 2: 0
        line 4: 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;普通原始类型静态变量和引用类型（即使是常量），是需要额外调用putstatic 等 JVM 指令的，
这些是在显式初始化阶段执行，而不是准备阶段调用；而原始类型常量，则不需要这样的步骤。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;类加载器&#34;&gt;类加载器&lt;/h3&gt;
&lt;h4 id=&#34;类与类加载器&#34;&gt;类与类加载器&lt;/h4&gt;
&lt;p&gt;虚拟机设计团队把类加载阶段中的&amp;quot;通过一个类的全限定名来获取描述此类的二进制字节流&amp;quot;这个动作放到Java虚拟机外部去实现，以便让程序自己决定如何去获取所需的类。实现这个动作的代码模块被称为&amp;quot;类加载器&amp;quot;。&lt;/p&gt;
&lt;h4 id=&#34;双亲委派模型&#34;&gt;双亲委派模型&lt;/h4&gt;
&lt;p&gt;站在Java虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。从Java开发人员的角度来看，类加载器还可以分得更细致一些，绝大部分Java程序都会使用到以下三种系统提供的类加载器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动类加载器
&lt;ul&gt;
&lt;li&gt;加载 jre/lib 下面的 jar 文件，如 rt.jar。&lt;/li&gt;
&lt;li&gt;即使是在开启了 Security Manager 的时候，JDK 仍赋予了它加载的程序AllPermission。&lt;/li&gt;
&lt;li&gt;通过 java -Xbootclasspath :(替换)、/a（追加）、/p（前置）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扩展类加载器
&lt;ul&gt;
&lt;li&gt;负责加载我们放到 jre/lib/ext/ 目录下面的 jar 包，这就是所谓的 extension 机制。&lt;/li&gt;
&lt;li&gt;可以通过设置 “java.ext.dirs”来覆盖，&lt;code&gt;java -Djava.ext.dirs=your_ext_dir HelloWorld&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序类加载器
&lt;ul&gt;
&lt;li&gt;也叫系统（System）类加载器，是加载我们最熟悉的 classpath 的内容。通常来说，其默认就是 JDK 内建的应用类加载器;&lt;/li&gt;
&lt;li&gt;它同样是可能修改的，比如：&lt;code&gt;java -Djava.system.class.loader=com.yourcorp.YourClassLoader HelloWorld&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果我们指定了这个参数，JDK 内建的应用类加载器就会成为定制加载器的父亲，这种方式通常用在类似需要改变双亲委派模式的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;双亲委派模型-1&#34;&gt;双亲委派模型&lt;/h4&gt;
&lt;p&gt;双亲委派模型（⾃底向上检查类是否已经加载、⾃顶向下尝试加载类），简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，尽量将这个任务代理给当前加载器的父加载器去做（除非父加载器找不到相应类型）。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常&lt;/p&gt;
&lt;p&gt;使用委派模型的目的是避免重复加载 Java类型；考虑到安全因素，避免自定义的类去替代系统类，如String。&lt;/p&gt;
&lt;p&gt;JVM不仅要判断两个类名是否相同，⽽且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。&lt;/p&gt;
&lt;h4 id=&#34;类加载机制有三个基本特征&#34;&gt;类加载机制有三个基本特征&lt;/h4&gt;
&lt;p&gt;双亲委派模型。&lt;/p&gt;
&lt;p&gt;但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的。&lt;br&gt;
用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。&lt;br&gt;
例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。&lt;/p&gt;
&lt;p&gt;可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许。&lt;/p&gt;
&lt;p&gt;单一性，父加载器中加载过的类型，就不会在子加载器中重复加载。&lt;/p&gt;
&lt;h4 id=&#34;jdk9-模块化&#34;&gt;JDK9 模块化&lt;/h4&gt;
&lt;p&gt;在 JDK 9 中，由于 Jigsaw 项目引入了 Java 平台模块化系统（JPMS），JPMS），Java SE 的源代码被划分为一系列模块。-Xbootclasspath 参数不可用了。&lt;/p&gt;
&lt;p&gt;扩展类加载器被重命名为平台类加载器（Platform Class-Loader），而且 extension 机制则被移除。也就意味着，如果我们指定 java.ext.dirs 环境变量，或者 lib/ext 目录存在，JVM将直接返回错误！建议解决办法就是将其放入 classpath 里。&lt;/p&gt;
&lt;p&gt;rt.jar 和 tools.jar 同样是被移除了！JDK 的核心类库以及相关资源，被存储在 jimage 文件中，并通过新的 JRT 文件系统访问，而不是原有的 JAR 文件系统。虽然看起来很惊人，但幸好对于大部分软件的兼容性影响，其实是有限的，更直接地影响是 IDE 等软件，通常只要升级到新版本就可以了。&lt;/p&gt;
&lt;p&gt;增加了 Layer 的抽象， JVM 启动默认创建 BootLayer，开发者也可以自己去定义和实例化Layer，可以更加方便的实现类似容器一般的逻辑抽象。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JVM笔记之引用、GC及OOM</title>
        <link>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%95%E7%94%A8gc%E5%8F%8Aoom/</link>
        <pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%95%E7%94%A8gc%E5%8F%8Aoom/</guid>
        <description>&lt;h2 id=&#34;强引用软引用弱引用和虚引用&#34;&gt;强引用、软引用、弱引用和虚引用&lt;/h2&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;强引用（Strong Reference）&lt;!-- raw HTML omitted --&gt;
只有这个引用被释放之后，对象才会被释放掉。只要引用存在，垃圾回收器永远不会回收。&lt;/p&gt;
&lt;p&gt;我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。&lt;br&gt;
当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。&lt;br&gt;
对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，
具体回收时机还是要看垃圾收集策略。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;软引用（Soft Reference）&lt;!-- raw HTML omitted --&gt;
内存溢出之前通过代码回收的引用。
通常用来实现内存敏感的缓存（图片缓存框架中，“内存缓存”中的图片是以这种引用来保存）。&lt;br&gt;
软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；
当内存不足时，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象，自动删除这部分缓存数据，从真正的来源查询这些数据。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;弱引用（Weak Reference）&lt;!-- raw HTML omitted --&gt;
第二次垃圾回收时回收的引用，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
同样可用于内存敏感的缓存（在静态内部类中，经常会使用虚引用。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏） &lt;br&gt;
弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;虚引用（Phantom Reference) &lt;!-- raw HTML omitted --&gt;
又称幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例的任何属性或函数。&lt;br&gt;
可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。&lt;br&gt;
当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。&lt;br&gt;
虚引用和软引用弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有&lt;/p&gt;
&lt;h2 id=&#34;java内存回收机制&#34;&gt;Java内存回收机制&lt;/h2&gt;
&lt;p&gt;不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。&lt;/p&gt;
&lt;p&gt;Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。&lt;/p&gt;
&lt;p&gt;在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，另一个是给对象赋予了新值，这样重新分配了内存空间。&lt;/p&gt;
&lt;h2 id=&#34;gc算法分类&#34;&gt;GC算法分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;引用计数法(没有被java采⽤用)&lt;/li&gt;
&lt;li&gt;标记清除法（通过根节点标记所有从根节点开始的可达对象，清除没标记过的对象，标记和清除两个过程效率不高，产生内存碎⽚）&lt;/li&gt;
&lt;li&gt;标记压缩法（压缩：将所有存活对象压缩到内存的一端，清除边界外所有的空间）&lt;/li&gt;
&lt;li&gt;复制回收算法&lt;/li&gt;
&lt;li&gt;分代回收法（根据对象存活周期的不同将内存划分几块，一般是新生代和老年代，新⽣代基本采用复制算法，老年代采⽤用标记清除算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;minorgc--fullgc&#34;&gt;MinorGC &amp;amp; FullGC&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Minor GC通常发生在新生代的Eden区，一般采用复制回收算法（对象生存期短，发生GC的频率较高，回收速度比较快）。&lt;/li&gt;
&lt;li&gt;Full GC/Major GC 发生在老年代，所采用的是标记清除算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;内存泄漏&#34;&gt;内存泄漏&lt;/h2&gt;
&lt;p&gt;内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示Out of memory。&lt;/p&gt;
&lt;p&gt;Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：&lt;/p&gt;
&lt;p&gt;1、静态集合类引起内存泄漏&lt;/p&gt;
&lt;p&gt;像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static Vector v = new Vector(10);
for (int i = 1; i&amp;lt;100; i++){
	Object o = new Object();
	v.add(o);
	o = null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，循环创建Object 对象，并将所创建的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。&lt;/p&gt;
&lt;p&gt;2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args){
	Set&amp;lt;Person&amp;gt; set = new HashSet&amp;lt;Person&amp;gt;();
	Person p1 = new Person(&amp;quot;唐僧&amp;quot;,&amp;quot;pwd1&amp;quot;,25);
	Person p2 = new Person(&amp;quot;孙悟空&amp;quot;,&amp;quot;pwd2&amp;quot;,26);
	Person p3 = new Person(&amp;quot;猪八戒&amp;quot;,&amp;quot;pwd3&amp;quot;,27);
	set.add(p1);
	set.add(p2);
	set.add(p3);
	System.out.println(&amp;quot;总共有:&amp;quot;+set.size()+&amp;quot; 个元素!&amp;quot;); //结果：总共有:3 个元素!
	p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变

	set.remove(p3); //此时remove不掉，造成内存泄漏

	set.add(p3); //重新添加，居然添加成功
	System.out.println(&amp;quot;总共有:&amp;quot;+set.size()+&amp;quot; 个元素!&amp;quot;); //结果：总共有:4 个元素!
	for (Person person : set){
		System.out.println(person);
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、监听器&lt;/p&gt;
&lt;p&gt;在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。&lt;/p&gt;
&lt;p&gt;4、各种连接&lt;/p&gt;
&lt;p&gt;比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。&lt;/p&gt;
&lt;p&gt;5、内部类和外部模块的引用&lt;/p&gt;
&lt;p&gt;内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：
public void registerMsg(Object b);
这种调用就要小心，传入了一个对象，可能模块B就保持了对该对象的引用，需要注意模块B 是否提供相应的操作去除引用。&lt;/p&gt;
&lt;p&gt;6、单例模式&lt;/p&gt;
&lt;p&gt;不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A{
	public A(){
		B.getInstance().setA(this);
	}
	....
}
//B类采用单例模式
class B{
	private A a;
	private static B instance = new B();
	public B(){}
	public static B getInstance(){
		return instance;
	}
	public void setA(A a){
		this.a=a;
	}
	//getter...
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况&lt;/p&gt;
&lt;h2 id=&#34;其他oom&#34;&gt;其他OOM&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;OutOfMemoryError异常&lt;/p&gt;
&lt;p&gt;除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能，&lt;/p&gt;
&lt;p&gt;Java Heap 溢出，一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess&lt;/p&gt;
&lt;p&gt;java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。&lt;/p&gt;
&lt;p&gt;出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。&lt;/p&gt;
&lt;p&gt;如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。&lt;/p&gt;
&lt;p&gt;如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟机栈和本地方法栈溢出&lt;/p&gt;
&lt;p&gt;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如递归方法没有退出条件&lt;/p&gt;
&lt;p&gt;如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常&lt;/p&gt;
&lt;p&gt;这里需要注意当栈的大小越大可分配的线程数就越少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行时常量池溢出&lt;/p&gt;
&lt;p&gt;异常信息：java.lang.OutOfMemoryError:PermGen space&lt;br&gt;
如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。&lt;/p&gt;
&lt;p&gt;对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法区溢出&lt;/p&gt;
&lt;p&gt;方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。&lt;/p&gt;
&lt;p&gt;异常信息：java.lang.OutOfMemoryError:PermGen space&lt;br&gt;
方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。&lt;/p&gt;
&lt;p&gt;随着&lt;!-- raw HTML omitted --&gt;元数据区&lt;!-- raw HTML omitted --&gt;的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何监控和诊断-jvm-堆内和堆外内存使用&#34;&gt;如何监控和诊断 JVM 堆内和堆外内存使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以使用综合性的图形化工具，如 JConsole&lt;/li&gt;
&lt;li&gt;也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。&lt;/li&gt;
&lt;li&gt;使用 jmap 等提供的命令，生成堆转储（Heap Dump）文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。&lt;/li&gt;
&lt;li&gt;如果使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。&lt;/li&gt;
&lt;li&gt;另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Http笔记</title>
        <link>https://ianeiu.github.io/p/http%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 29 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/http%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;浏览器输入url到返回页面的过程&#34;&gt;浏览器输入URL到返回页面的过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;根据域名，进行DNS域名解析&lt;/li&gt;
&lt;li&gt;拿到解析的IP地址，建立TCP连接&lt;/li&gt;
&lt;li&gt;向IP地址发送HTTP请求&lt;/li&gt;
&lt;li&gt;服务器处理请求&lt;/li&gt;
&lt;li&gt;返回响应结果&lt;/li&gt;
&lt;li&gt;关闭TCP连接&lt;/li&gt;
&lt;li&gt;浏览器解析HTML&lt;/li&gt;
&lt;li&gt;浏览器布局渲染&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;HTTP即超文本传输协议（HTTP，Hyper Text Transport Protocol）。HTTP协议默认监听80端口，主要用于描述请求和响应的数据格式。&lt;/p&gt;
&lt;h2 id=&#34;版本&#34;&gt;版本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;0.9　已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。&lt;/li&gt;
&lt;li&gt;HTTP/1.0　建立连接后只能请求响应一次&lt;/li&gt;
&lt;li&gt;HTTP/1.1　持久连接（可以进行多次请求和响应）被默认采用，能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度
&lt;ul&gt;
&lt;li&gt;维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;刷新页面不需要重新建立 SSL 连接&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;和服务器建立多个 TCP 连接&lt;/li&gt;
&lt;li&gt;Pipelining 实现同一时刻只能处理一个请求
&lt;ul&gt;
&lt;li&gt;浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的&lt;/li&gt;
&lt;li&gt;一些代理服务器不能正确的处理 HTTP Pipelining&lt;/li&gt;
&lt;li&gt;Head-of-line Blocking 连接头阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP/2   多个 HTTP 请求可以在同一个 TCP 连接中并行进行（Multiplexing ）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;浏览器对同一-host-建立-tcp-连接到数量有没有限制&#34;&gt;浏览器对同一 Host 建立 TCP 连接到数量有没有限制&lt;/h2&gt;
&lt;p&gt;有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。&lt;/p&gt;
&lt;h2 id=&#34;消息头&#34;&gt;消息头&lt;/h2&gt;
&lt;p&gt;请求的资源中含有 &lt;code&gt;&amp;lt;img &amp;gt; &amp;lt;link&amp;gt; &amp;lt;script&amp;gt;&lt;/code&gt;浏览器会自动发出请求&lt;/p&gt;
&lt;p&gt;请求消息头：一个请求行，多个消息头， 一个空行&lt;br&gt;
请求行：请求类型(GET/POST) 请求资源 HTTP版本  如(GET /app/2.html HTTP/1.1)&lt;/p&gt;
&lt;p&gt;响应消息头：一个响应头（状态行），多个消息头，一个空行，响应内容&lt;/p&gt;
&lt;p&gt;GET与POST方式对比&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GET提交数据有长度限制,1K，而POST没有长度限制&lt;/li&gt;
&lt;li&gt;GET皎在地址栏可见，所以不安全。POST提交数据在主体内容中不可见，所以安全&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请求消息头&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Accept:告知服务器，浏览器可接受的MIME类型 (Multipurpose Internet Mail Extensation) 多用途互联网邮件扩展类型
	MIME 类型:文件系统文件类型用文件的扩展名来区分
	MIME类型由大类型/小类型组成的.比如text/html text/css text/javascript image/bmp image/jpeg (Tomcat conf/web.xml
Accpept-Charset:支持的字符集
Accept-Language:浏览器所希望的语言类型
Accpet-Encoding:gzip,deflate
*Referer:包含一个URL,该URL表示当前页来源(用于防盗链,统计广告投放效果)
Content-Type:请求正文内容的MIME类型(适应于Post请求)
	默认是application/x-www-form-urlencoded(username=sa&amp;amp;age=30)
	还有：application/json、multipart/form-data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;响应消息头&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*Location:http://www.itheima.com/index.jsp 告知浏览器，新的资源的位置(302跳转)
*Content-Encoding: gzip代表服务器采用什么方式进行数据压缩
*Content-Length:  服务器发送的数据长度
Content-Language: zh-cn服务发送的文本的语言
*Content-Type: text/html; charset=GB2312服务器发送的内容的MIME类型
Last-Modified:服务器最后修改资源的时间
*Refresh：指定服务器刷新  Refresh: 1;url=http://www.it315.org指示客户端刷新频率。单位是秒
*Content-Disposition: attachment; filename=aaa.zip指示客户端下载文件

*Expires: -1清理缓存
*Cache-Control: no-cache (1.1)  没有缓存
*Pragma: no-cache   (1.0) 没有缓存

*Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;https&#34;&gt;HTTPS&lt;/h2&gt;
&lt;p&gt;HTTP：互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。&lt;/p&gt;
&lt;p&gt;HTTPS：以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用;&lt;/li&gt;
&lt;li&gt;http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议;&lt;/li&gt;
&lt;li&gt;http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443;&lt;/li&gt;
&lt;li&gt;http的连接很简单，是无状态的；HTTPS是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如果不用httpshttp协议如何安全的传输密码信息&#34;&gt;如果不用HTTPS，HTTP协议如何安全的传输密码信息？&lt;/h2&gt;
&lt;p&gt;HTTP协议是纯文本协议，没有任何加密措施。通过HTTP协议传输的数据都可以在网络上被完全监听。如果用户登陆时将用户名和密码直接明文通过HTTP协议传输过去了，那么密码可能会被黑客窃取。&lt;/p&gt;
&lt;p&gt;一种方法是使用非对称加密。GET登陆页面时，将公钥以Javascript变量的形式暴露给浏览器。然后用公钥对用户的密码加密后，再将密码密文、用户名和公钥一起发送给服务器。&lt;/p&gt;
&lt;p&gt;服务器会提前存储公钥和私钥的映射信息，通过客户端发过来的公钥就可以查出对应的私钥，然后对密码密文进行解密就可以还原出密码的明文。&lt;/p&gt;
&lt;p&gt;为了加强公钥私钥的安全性，服务器应该动态生成公钥私钥对，并且使用后立即销毁。但是动态生成又是非常耗费计算资源的，所以一般服务器会选择Pool方法提供有限数量的公钥私钥对池，然后每隔一段时间刷新一次Pool。&lt;/p&gt;
&lt;h2 id=&#34;文件路径攻击&#34;&gt;文件路径攻击&lt;/h2&gt;
&lt;p&gt;很多操作系统都会使用..符号表示上层目录。如果黑客在URL的路径里面使用..符号引用上层目录，而服务器没有做好防范的话就有可能导致黑客可以直接访问权限之外的文件。比如使用多级..符号就可以引用到根目录，进一步就可以访问任意文件。
所以很多服务器都禁止在URL路径里出现..符号以避免被攻击。&lt;/p&gt;
&lt;p&gt;文件路径攻击也是很多黑客非常喜爱使用的攻击方法之一。如果你的服务器有一定的访问量，打开你的nginx日志，你就会偶尔发现有一些奇怪的URL里面有一堆..符号，这种URL的出现就表示网络上的黑客正在尝试攻击你的服务器。&lt;/p&gt;
&lt;h2 id=&#34;dns欺骗&#34;&gt;DNS欺骗&lt;/h2&gt;
&lt;p&gt;HTTP协议严重依赖于DNS域名解析。任意一个域名类网址的访问都需要经过域名解析的过程得到目标服务的IP地址才能成功继续下去。&lt;/p&gt;
&lt;p&gt;如果掌管DNS服务的运营商作恶将域名解析到不正确的IP，指向一个钓鱼的网页服务。用户如果没有觉察，就可能会将自己的敏感信息提交给冒牌的服务器。&lt;/p&gt;
&lt;h2 id=&#34;谨慎使用外部的http代理中间人攻击&#34;&gt;谨慎使用外部的HTTP代理（中间人攻击）&lt;/h2&gt;
&lt;p&gt;HTTP代理作为客户端到服务器之间的中间路由节点，它起到传话人和翻译官的角色。
如果这个翻译官不靠谱的话，客户端是会拿到错误的返回数据的。它同DNS欺骗一样，是可以对客户端进行钓鱼攻击的。&lt;/p&gt;
&lt;p&gt;如果这个翻译官口风不严的话，它可能会将它听到的敏感信息泄露给别人。&lt;/p&gt;
&lt;h2 id=&#34;csrfcross-site-request-forgery&#34;&gt;CSRF(Cross-Site Request Forgery)&lt;/h2&gt;
&lt;p&gt;CSRF跨站请求伪造有很多别名，比如One-Click Attack(一键攻击)，比如Session Riding(搭便车攻击)&lt;/p&gt;
&lt;p&gt;假设在在一个社区博客网站中，删除个人的文章只需要一个URL就可以，Cookie中的会话权限信息会自动附加到请求上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 123456为文章的ID
http://example.com/blog/123456/delete
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么当别人伪造了一个上面的链接地址诱惑你去点击，比如通过站内信件、私聊、博客评论、图片链接或者在别的什么网站上随机制造的一个链接。&lt;/p&gt;
&lt;p&gt;你不经意点了一下，就丢了你的文章。所以它被称为一键攻击。因为这是借用了你当前登陆的会话信息来搞事，所以也被称为搭便车攻击。&lt;/p&gt;
&lt;p&gt;如果在一个金融系统中，转账要是也可以通过一个简单的URL进行的话，那这种危险就非同小可。&lt;/p&gt;
&lt;p&gt;这就要求修改性的操作务必不得使用简单的GET请求进行处理。但是即使这种情况下你改成了POST请求，黑客依然有办法伪造请求，那就是通过iframe。&lt;/p&gt;
&lt;p&gt;黑客在别的什么网站上伪造了一个POST表单，诱惑你去submit。如果只是普通的内嵌进HTML网页的表单，用户提交时会出现跨域问题。因为当前网站的域名和表单提交的目标域名不一致。但是如果通过iframe来内嵌表单，则可以绕过跨域的问题，而用户却完全没有任何觉察。&lt;/p&gt;
&lt;p&gt;为了防范CSRF攻击，聪明的网站的POST表单里都会带上CSRF_TOKEN这个隐藏字段。CSRF_TOKEN是根据用户的会话信息生成的。当表单提交时，会将token和用户的会话信息做比对。如果匹配就是有效的提交请求。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form method=&amp;quot;POST&amp;quot; action=&amp;quot;/blog/delete&amp;quot;&amp;gt;
&amp;lt;label for=&amp;quot;blog_id&amp;quot;&amp;gt;博客ID&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;blog_id&amp;quot; value=&amp;quot;12345&amp;quot;&amp;gt;
&amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;csrf_token&amp;quot; value=&amp;quot;xxxxxxxxxxxx&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;黑客必须拿到CSRF_TOKEN才可以借用用户的会话信息实施CSRF攻击，但是CSRF_TOKEN又必须由用户的会话信息才可以生成。黑客没有用户的会话信息，从而无法实施CSRF攻击。&lt;/p&gt;
&lt;h2 id=&#34;xsscross-site-scripting&#34;&gt;XSS(Cross Site Scripting)&lt;/h2&gt;
&lt;p&gt;如果黑客可以在你的网页中植入任意Javascript脚本，那他就可以随意鱼肉你的账户。通过Javascript可以获取Cookie的信息，可以借用你的会话去调用一些隐秘的API，而这一些行为都是在偷偷的进行，你根本完全不知道。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
# 用户内容Start
&amp;lt;script&amp;gt;send_to_hacker(document.cookie)&amp;lt;/script&amp;gt;
# 用户内容END

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这类攻击在一些UGC网站中非常常见，常见的博客类网站就是UGC网站，用户可以通过编辑内容来生成网页。&lt;/p&gt;
&lt;p&gt;黑客也是用户。他可以编辑一段Javascript脚本作为内容提交上去。如果服务器没有做好防范，这段脚本就会在生成的网页中运行起来。当其它用户在登陆的状态下来浏览这个网页的时候，就悲剧了。&lt;/p&gt;
&lt;p&gt;防范XSS一般是通过对输出的内容进行内容替换做到的。在HTML页面中不同的位置会有不同的内容替换规则。
比较常见的是使用HTML entity编码将HTML标签之间的内容中的一些特殊的字符进行转码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
# safe now
&amp;amp;lt;script&amp;amp;gt;send_to_hacker(document.cookie)&amp;amp;lt;/script&amp;amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有些UGC内容在HTML标签的属性中、Javascript的变量中、URL、css代码中，他们转码的规则并不一样，具体方法可以去Google相关文档。&lt;/p&gt;
&lt;h2 id=&#34;跨域&#34;&gt;跨域&lt;/h2&gt;
&lt;p&gt;跨域是个很头痛的问题。&lt;/p&gt;
&lt;p&gt;当你有多个后端服务，但是只有一个前端的时候，你想做前后端分离，就会遇到跨域问题。你发现你的前端js调用后端服务时控制台告诉你不ok。然后只好把这些服务都挂在了同一个nginx域名下面，通过url前缀区分。&lt;/p&gt;
&lt;p&gt;这时候你会想，跨域太TM讨厌了。既然跨域这么讨厌，那为什么浏览器非要限制跨域呢？&lt;/p&gt;
&lt;p&gt;还是安全原因。&lt;/p&gt;
&lt;p&gt;让我们回到上文的搭便车攻击(Session Riding)，也就是骑着别人的会话来搞事情。&lt;/p&gt;
&lt;p&gt;假设现在你的浏览器开了一个站点A，登陆了进去，于是cookie便记录了会话id。
然后你又不小心开了另一个站点B，这个站点页面一打开就开始执行一些恶意代码。这些代码的逻辑是调用站点A的API来获取站点A的数据，因为可以骑着(Ride)站点A的会话cookie。而这些数据正好是用户私密性的。于是用户在站点A上的私有信息就被站点B上的代码窃走了。这就是跨域的风险。&lt;/p&gt;
&lt;p&gt;但是有时候我们又希望共享数据给不同的站点，该怎么办呢？&lt;/p&gt;
&lt;p&gt;答案是JSONP &amp;amp; CORS&lt;/p&gt;
&lt;h2 id=&#34;jsonpjson-padding&#34;&gt;JSONP(JSON Padding)&lt;/h2&gt;
&lt;p&gt;JSONP通过HTML的script标记实现了跨域共享数据的方式。JSON通过在网页里定义一个回调方法，然后在页面上插入一个动态script标签，指向目标调用地址。服务器会返回一段javascript代码，一般是some_callback(data)这种形式的回调。该段代码会在浏览器里自动执行，于是网页就得到了跨域服务器返回的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
function some_callback(data) {
   console.log(data)
}
&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;http://example.com/someapi?callback=some_callback&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为JSONP是不携带cookie信息的，所以能有效避免搭便车攻击。JSONP是否可以获取到数据还需要服务器对这种调用提供显示支持，服务器必须将数据以javascript代码的形式返回才可以传递给浏览器。&lt;/p&gt;
&lt;h2 id=&#34;corscross-origin-resource-sharing&#34;&gt;CORS(Cross-Origin Resource Sharing)&lt;/h2&gt;
&lt;p&gt;JSONP的不足在于它只能发送GET请求，并且不能携带cookie。而CORS则可以发送任意类型的请求，可以选择性携带cookie。&lt;/p&gt;
&lt;p&gt;CORS是通过Ajax发送的跨域请求技术。CORS的请求分为两种，一种是简单请求，一种是复杂请求。简单请求就是头部很少很简单的GET/HEAD/POST请求。复杂请求就是非简单请求。&lt;/p&gt;
&lt;p&gt;浏览器发现Ajax的请求是跨域的，就会在请求头添加一个Origin参数，指明当前请求的发起站点来源。服务器根据Origin参数来决定是否授权。&lt;/p&gt;
&lt;p&gt;如果是简单请求，Ajax直接请求服务器。服务器会当成普通的请求直接返回内容，不同的是还会在响应头部添加几个重要的头部，其中最重要的头部是Access-Control-Allow-Origin: &lt;code&gt;http://example.com&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;浏览器如果在响应中没有读到这个头部，就会通知Ajax请求失败。虽然服务器返回了数据，浏览器也不让脚本读到数据，这就保证了跨域的安全。服务器就是通过请求的Origin参数来决定要不要响应Access-Control-Allow-Origin头部来决定是否允许指定网站的跨域请求。&lt;/p&gt;
&lt;p&gt;如果是复杂请求，要走一个预检的流程。预检就是浏览器先向服务器发送一个Method为Options的请求，如果服务器允许跨域请求，浏览器再发起这个Ajax请求。所以CORS的复杂请求会比简单请求额外耗费一个TTL的时间。&lt;/p&gt;
&lt;h2 id=&#34;ref&#34;&gt;REF&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/V9hqwkq1uEApbya4pl3EVQ&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HTTP协议又冷又实用的技能大全!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java笔记之名词简介</title>
        <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E7%AE%80%E4%BB%8B/</link>
        <pubDate>Sat, 29 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E7%AE%80%E4%BB%8B/</guid>
        <description>&lt;h2 id=&#34;web容器&#34;&gt;web容器&lt;/h2&gt;
&lt;p&gt;给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。&lt;/p&gt;
&lt;h2 id=&#34;ejb容器&#34;&gt;EJB容器&lt;/h2&gt;
&lt;p&gt;Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jdbc&#34;&gt;JDBC&lt;/h2&gt;
&lt;p&gt;用来访问数据库的API（规范）&lt;/p&gt;
&lt;h2 id=&#34;jndijava-naming--directory-interface&#34;&gt;JNDI：（Java Naming &amp;amp; Directory Interface）&lt;/h2&gt;
&lt;p&gt;JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。&lt;/p&gt;
&lt;h2 id=&#34;jmsjava-message-service&#34;&gt;JMS：（Java Message Service）&lt;/h2&gt;
&lt;p&gt;JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。&lt;/p&gt;
&lt;h2 id=&#34;jtajava-transaction-api&#34;&gt;JTA：（Java Transaction API）&lt;/h2&gt;
&lt;p&gt;JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。&lt;/p&gt;
&lt;h2 id=&#34;jafjava-action-framework&#34;&gt;JAF：（Java Action FrameWork）&lt;/h2&gt;
&lt;p&gt;JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。&lt;/p&gt;
&lt;h2 id=&#34;rmiiiopremote-method-invocation-internet对象请求中介协议&#34;&gt;RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）&lt;/h2&gt;
&lt;p&gt;他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。&lt;/p&gt;
&lt;h2 id=&#34;jsp&#34;&gt;JSP&lt;/h2&gt;
&lt;p&gt;Jsp页面由HTML和前去其中的Java代码组成，用来实现动态视图&lt;/p&gt;
&lt;h2 id=&#34;javamail&#34;&gt;JavaMail&lt;/h2&gt;
&lt;p&gt;JavaMail利用JAF来初拉力MIME编码的邮件附件&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;mvc&#34;&gt;MVC&lt;/h2&gt;
&lt;p&gt;标准主流现在的编程方式都是采用MVC综合设计模式，MVC本身不属于设计模式的一种，它描述的是一种结构，最终目的达到解耦（更改某一层代码不会影响我其他层代码）。&lt;br&gt;
视图层如jsp调用控制层，控制层action调用业务层service，业务层调用数据dao访问层。&lt;/p&gt;
&lt;h2 id=&#34;dao层&#34;&gt;DAO层&lt;/h2&gt;
&lt;p&gt;DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，DAO层的设计首先是设计DAO的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。&lt;/p&gt;
&lt;h2 id=&#34;service层&#34;&gt;Service层&lt;/h2&gt;
&lt;p&gt;Service层主要负责业务模块的逻辑应用设计。同样是首先设计接口，再设计其实现的类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。&lt;/p&gt;
&lt;h2 id=&#34;controller层&#34;&gt;Controller层&lt;/h2&gt;
&lt;p&gt;Controller层负责具体的业务模块流程的控制，在此层里面要调用Serice层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;vo&#34;&gt;VO&lt;/h2&gt;
&lt;p&gt;即value object值对象。主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象。然后用一个VO对象在控制层与视图层进行传输交换。&lt;/p&gt;
&lt;h2 id=&#34;dto&#34;&gt;DTO&lt;/h2&gt;
&lt;p&gt;Data Transfer Object数据传输对象，经过处理后的PO，可能增加或者减少PO的属性，主要用于远程调用等需要大量传输对象的地方。&lt;/p&gt;
&lt;h2 id=&#34;pojo&#34;&gt;POJO&lt;/h2&gt;
&lt;p&gt;POJO（plain ordinary java object）即简单java对象，是一种概念或者接口，身份及作用随环境变化而变化。
它不包含业务逻辑或持久逻辑等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;springmvc&#34;&gt;SpringMVC&lt;/h2&gt;
&lt;p&gt;Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。&lt;/p&gt;
&lt;h2 id=&#34;ioc容器&#34;&gt;IOC容器&lt;/h2&gt;
&lt;p&gt;IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。在Spring中BeanFactory是IOC容器的实际代表者。&lt;/p&gt;
&lt;h2 id=&#34;aop-面向切面&#34;&gt;AOP (面向切面)&lt;/h2&gt;
&lt;p&gt;简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系&lt;/p&gt;
&lt;h2 id=&#34;mybatis&#34;&gt;Mybatis&lt;/h2&gt;
&lt;p&gt;MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。&lt;/p&gt;
&lt;h2 id=&#34;dubbo&#34;&gt;Dubbo&lt;/h2&gt;
&lt;p&gt;Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC（远程过程调用协议）远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。&lt;/p&gt;
&lt;h2 id=&#34;maven&#34;&gt;Maven&lt;/h2&gt;
&lt;p&gt;项目管理和构建自动化工具&lt;/p&gt;
&lt;h2 id=&#34;rabbitmq&#34;&gt;RabbitMQ&lt;/h2&gt;
&lt;p&gt;消息队列一般是在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。&lt;/p&gt;
&lt;h2 id=&#34;log4jlog4j2logback&#34;&gt;Log4j、Log4j2、Logback&lt;/h2&gt;
&lt;p&gt;日志记录框架&lt;/p&gt;
&lt;h2 id=&#34;ehcache&#34;&gt;Ehcache&lt;/h2&gt;
&lt;p&gt;EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展，缓存异常处理程序，一个gzip缓存servlet过滤器，支持REST和SOAP api等特点。&lt;/p&gt;
&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;
&lt;p&gt;redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。Redis数据库完全在内存中，使用磁盘仅用于持久性。Redis可以将数据复制到任意数量的从服务器。&lt;/p&gt;
&lt;h2 id=&#34;shiro&#34;&gt;Shiro&lt;/h2&gt;
&lt;p&gt;Apache Shiro是Java的一个安全框架，旨在简化身份验证和授权。Shiro在JavaSE和JavaEE项目中都可以使用。它主要用来处理身份认证，授权，企业会话管理和加密等。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;分布式系统&#34;&gt;分布式系统&lt;/h2&gt;
&lt;p&gt;若干独立计算机（相关系统）的集合。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用可以按业务类型拆分成多个应用，再按结构分成接口层、服务层；我们也可以按访问入口分，如移动端、PC端等定义不同的接口应用；&lt;/li&gt;
&lt;li&gt;数据库可以按业务类型拆分成多个实例，还可以对单表进行分库分表；&lt;/li&gt;
&lt;li&gt;增加分布式缓存、搜索、文件、消息队列、非关系型数据库等中间件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分布式系统虽好，也带来了系统的复杂性，如分布式事务、分布式锁、分布式session、数据一致性等都是现在分布式系统中需要解决的难题，虽然已经有很多成熟的方案，但都不完美。分布式系统也增加了开发测试运维成本，工作量增加，分布式系统管理不好反而会变成一种负担。&lt;/p&gt;
&lt;h2 id=&#34;cdn&#34;&gt;CDN&lt;/h2&gt;
&lt;p&gt;全称为Content Delivery Network，即内容分发网络。&lt;/p&gt;
&lt;p&gt;其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。&lt;/p&gt;
&lt;p&gt;现在CDN一般都以缓存网站的静态内容为主，如果静态网页页面、JS、CSS、图片等静态文件。如用户访问一个动态网站，首先从服务器请求到动态数据，再从CDN上请求下载静态数据的，因为CDN能就近网络取材，从而减少了下载静态数据的时间，加快了网页的显示速度。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可扩展性，能应对激增的大量用户请求的扩展能力。&lt;/li&gt;
&lt;li&gt;安全性，CDN可以减少DDOS攻击及其他恶意攻击行为，避免对网站业务造成中断。&lt;/li&gt;
&lt;li&gt;可靠性，CDN通过负载均衡能及时提供网络的容错机制能力。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式：简单工厂模式（抽象工厂模式），工厂方法模式，建造者模式，原型模式，单例模式√。(5个)&lt;/li&gt;
&lt;li&gt;结构型模式：外观模式、适配器模式、代理模式、装饰模式、桥接模式、组合模式、享元模式。(7个)&lt;/li&gt;
&lt;li&gt;行为型模式：模版方法模式、观察者模式、状态模式、职责链模式、命令模式、访问者模式、策略模式、备忘录模式、迭代器模式、解释器模式、 中介者模式。(11个)&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Java面试之HashMap</title>
        <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/</link>
        <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/</guid>
        <description>&lt;h3 id=&#34;hashmap数组链表&#34;&gt;HashMap（数组+链表）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。&lt;/li&gt;
&lt;li&gt;当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象。&lt;/li&gt;
&lt;li&gt;当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/HashMap%E4%B9%8Bput%E6%96%B9%E6%B3%95.png&#34; data-size=&#34;929x735&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/HashMap%E4%B9%8Bput%E6%96%B9%E6%B3%95_hu8b8321e01761ab5d0950dba8bd066dc5_262910_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/HashMap%E4%B9%8Bput%E6%96%B9%E6%B3%95_hu8b8321e01761ab5d0950dba8bd066dc5_262910_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8Bhashmap/HashMap%E4%B9%8Bput%E6%96%B9%E6%B3%95.png&#34; width=&#34;929&#34; height=&#34;735&#34; loading=&#34;lazy&#34;
				alt=&#34;&amp;nbsp;&#34;&gt;
		&lt;/a&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    //1. 如果当前table为空，新建默认大小的table
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    //2. 获取当前key对应的节点
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
         //3. 如果不存在，新建节点
        tab[i] = newNode(hash, key, value, null);
    //4. 存在节点
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        //5. key的hash相同，key的引用相同或者key equals，则覆盖
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        //6.如果当前节点是一个红黑树树节点，则添加树节点
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        //7.不是红黑树节点，也不是相同节点，则表示为链表结构
        else {
            //遍历链表
            for (int binCount = 0; ; ++binCount) {
                //8. 找到最后那个节点
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    //9. 如果链表长度超过8转成红黑树
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                //10.如果链表中有相同的节点，则覆盖
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    //是否超过容量，超过需要扩容
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;仔细观察哈希值的源头，我们会发现，它并不是 key 本身的 hashCode，
而是来自于HashMap 内部的另外一个 hash 方法。&lt;/p&gt;
&lt;h3 id=&#34;为什么这里需要将高位数据移位到低位进行异或算呢&#34;&gt;为什么这里需要将高位数据移位到低位进行异或算呢？&lt;/h3&gt;
&lt;p&gt;这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，
那么这种处理就可以有效避免类似情况下的哈希碰撞。&lt;/p&gt;
&lt;h3 id=&#34;resize-方法的源码设计&#34;&gt;resize 方法的源码设计&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;final Node&amp;lt;K,V&amp;gt;[] resize() {
    // ...
    else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACIY &amp;amp;&amp;amp;
    oldCap &amp;gt;= DEFAULT_INITIAL_CAPAITY)
        newThr = oldThr &amp;lt;&amp;lt; 1; // double there
    // ...
    else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {
        // zero initial threshold signifies using defaultsfults
        newCap = DEFAULT_INITIAL_CAPAITY;
        newThr = (int)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；
    }
    if (newThr ==0) {
        float ft = (float)newCap * loadFator;
        newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?(int)ft : Intege
    }
    threshold = neThr;
    Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newap];
    table = n；
    // 移动到新的数组结构 e 数组结构
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;依据 resize 源码，不考虑极端情况（容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&amp;laquo;30，也就是 2 的 30 次方），
我们可以归纳为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;门限值等于（负载因子）*（容量），如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。&lt;/li&gt;
&lt;li&gt;门限通常是以倍数进行调整 （newThr = oldThr &amp;laquo; 1），我前面提到，根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。&lt;/li&gt;
&lt;li&gt;扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;容量负载因子和树化&#34;&gt;容量、负载因子和树化&lt;/h3&gt;
&lt;p&gt;容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。
极端情况下，假设只有一个桶，那么它就退化成了链表，完全不能提供所谓常数时间存的性能。&lt;/p&gt;
&lt;p&gt;如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。
具体数值我们可以根据扩容发生的条件来做简单预估，根据前面的代码分析，我们知道它需要符合计算条件：负载因子 * 容量 &amp;gt; 元素数量，
所以，预先设置的容量需要满足，大于“预估元素数量 / 负载因子”，同时它是 2 的幂数，结论已经非常清晰了。&lt;/p&gt;
&lt;p&gt;对于负载因子如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。 &lt;br&gt;
如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap的性能。 &lt;br&gt;
如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。&lt;/p&gt;
&lt;p&gt;树化改造，对应逻辑主要在 putVal 和 treeifyBin 中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash) {
    int n, index; Node&amp;lt;K,V&amp;gt; e;
    if (tab == null || (n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) &amp;amp; hash]) != null) {
        // 树化改造逻辑
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;综合这两个方法，树化改造的逻辑就非常清晰了，可以理解为，当 bin 的数量大于 TREEIFY_THRESHOLD 时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容。&lt;/li&gt;
&lt;li&gt;如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，为什么 HashMap 要树化呢？&lt;br&gt;
本质上这是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，
我们知道链表查询是线性的，会严重影响存取的性能。&lt;br&gt;
而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，
导致服务器端 CPU 大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。&lt;/p&gt;
&lt;h3 id=&#34;当两个对象的hashcode相同&#34;&gt;当两个对象的hashcode相同&lt;/h3&gt;
&lt;p&gt;它们会储存在同一个bucket位置的链表中。因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。
因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。&lt;/p&gt;
&lt;p&gt;HashMap 内部的结构，它可以看作是数组（Node[] table）和链表结合组成的复合结构，
数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；
哈希值相同的键值对，则以链表形式存储。
这里需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），的链表就会被改造为树形结构。&lt;/p&gt;
&lt;h3 id=&#34;两个键的hashcode相同如何获取值对象&#34;&gt;两个键的hashcode相同,如何获取值对象&lt;/h3&gt;
&lt;p&gt;当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。&lt;/p&gt;
&lt;h3 id=&#34;hashmap的大小超过了负载因子load-factor定义的容量会发生什么&#34;&gt;HashMap的大小超过了负载因子(load factor)定义的容量，会发生什么？&lt;/h3&gt;
&lt;p&gt;对象会进行rehashing，调用hash方法找到新的bucket位置。&lt;br&gt;
默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。&lt;/p&gt;
&lt;h3 id=&#34;调整hashmap大小存在什么问题&#34;&gt;调整HashMap大小存在什么问题&lt;/h3&gt;
&lt;p&gt;多线程的情况下，可能产生条件竞争(race condition)。如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。&lt;/p&gt;
&lt;h3 id=&#34;为什么string-interger这样的wrapper类适合作为键&#34;&gt;为什么String, Interger这样的wrapper类适合作为键&lt;/h3&gt;
&lt;p&gt;因为wrapper类如String是不可变的，也是final的，而且重写了equals()和hashCode()方法了，防止计算hashCode()改变键值。&lt;/p&gt;
&lt;p&gt;如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。&lt;/p&gt;
&lt;p&gt;也可以使用自定义的对象作为键，条件是遵守equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。&lt;/p&gt;
&lt;h3 id=&#34;hashmap与hashset&#34;&gt;HashMap与HashSet&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;HashMap&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;HashSet&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实现了Map接口&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实现了Set接口（构造new HashMap）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;put()存键值对&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;add()存储对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用键对象来计算hashcode值&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;hashmap与hashtable&#34;&gt;HashMap与Hashtable&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;HashMap几乎等于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。&lt;/li&gt;
&lt;li&gt;HashMap是非synchronized，而Hashtable是synchronized。Java 5提供了ConcurrentHashMap，可以替代HashTable&lt;/li&gt;
&lt;li&gt;HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器非fail-fast。所以当有其它线程通过map对象改变了HashMap的结构（增加或者移除元素），会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出这个异常。&lt;/li&gt;
&lt;li&gt;由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。&lt;/li&gt;
&lt;li&gt;HashMap不能保证随着时间的推移Map中的元素次序是不变的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如何保证容器是线程安全的concurrenthashmap-如何实现高效地线程安全&#34;&gt;如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？&lt;/h3&gt;
&lt;p&gt;Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 Hashtable 等同步容器，
还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用 Collections 工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap），
但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。&lt;/p&gt;
&lt;p&gt;另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList。&lt;/li&gt;
&lt;li&gt;各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue。&lt;/li&gt;
&lt;li&gt;各种有序容器的线程安全版本等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体保证线程安全的方式，包括有从简单的 synchronize 方式，
到基于更加精细化的，比如基于分离锁实现的 ConcurrentHashMap 等并发实现等。&lt;br&gt;
具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。&lt;/p&gt;
&lt;h3 id=&#34;cocurrenthashmap与hashtable-为什么需要-concurrenthashmap&#34;&gt;CocurrentHashMap与Hashtable (为什么需要 ConcurrentHashMap？)&lt;/h3&gt;
&lt;p&gt;Hashtable是synchronized的(基本就是将 put、get、size 等各种方法加上“synchronized”)，
简单来说，这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其他线程只能等待，大大降低了并发操作的效率。&lt;/p&gt;
&lt;p&gt;同步包装器只是利用输入 Map 构造了另一个同步版本，所有操作虽然不再声明成为 synchronized 方法，
但是还是利用了“this”作为互斥的 mutex，没有真正意义上的改进。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static class SynchronizedMap&amp;lt;K,V&amp;gt;
        implements Map&amp;lt;K,V&amp;gt;, Serializable {
        private static final long serialVersionUID = 1978198479659022715L;

        private final Map&amp;lt;K,V&amp;gt; m;     // Backing Map
        final Object      mutex;        // Object on which to synchronize
        ...
        public int size() {
            synchronized (mutex) {return m.size();}
        }
        public boolean isEmpty() {
            synchronized (mutex) {return m.isEmpty();}
        }
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以Hashtable 或者同步包装版本，都只是适合在非高度并发的场景下。&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。
ConcurrentHashMap的设计实现其实一直在演化，在 Java 8 中就发生了非常大的变化（ava 7 其实也有不少更新）。&lt;/p&gt;
&lt;p&gt;早期 ConcurrentHashMap，其实现是基于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分离锁，也就是将内部进行分段（Segment），里面则是 HashEntry 的数组，和 HashMap类似，哈希相同的条目也是以链表形式存放。&lt;/li&gt;
&lt;li&gt;HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在构造的时候，Segment 的数量由所谓的 concurrentcyLevel 决定，默认是 16，也可以在相应构造函数直接指定。
注意，Java 需要它是 2 的幂数值，如果输入是类似 15 这种非幂值，会被自动调整到 16 。&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap(JDK7)并发写操作时：&lt;br&gt;
ConcurrentHashMap 会获取再入锁，以保证数据一致性，Segment 本身就是基于ReentrantLock 的扩展实现，
所以，在并发修改期间，相应 Segment 是被锁定的。
在最初阶段，进行重复性的扫描，以确定相应 key 值是否已经在数组里面，进而决定是更新还是放置操作。
重复扫描、检测冲突是ConcurrentHashMap 的常见技巧。
ConcurrentHashMap进行的不是整体的扩容，而是单独对 Segment进行扩容。&lt;/p&gt;
&lt;p&gt;Map 的 size 方法同样需要关注，它的实现涉及分离锁的一个副作用。
如果不进行同步，简单的计算所有 Segment 的总值，可能会因为并发 put，导致结果不准确，
但是直接锁定所有 Segment 进行计算，就会变得非常昂贵。&lt;br&gt;
所以，ConcurrentHashMap 的实现是通过重试机制（RETRIES_BEFORE_LOCK，指定重试次数 2），来试图获得可靠值。
如果没有监控到发生变化（通过对比 Segment.modCount），就直接返回，否则获取锁进行操作。&lt;/p&gt;
&lt;h3 id=&#34;在-java-8-和之后的版本中concurrenthashmap-发生了哪些变化呢&#34;&gt;在 Java 8 和之后的版本中，ConcurrentHashMap 发生了哪些变化呢&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;总体结构上，它的内部存储变得和 HashMap 结构非常相似，同样是大的桶（bucket）数组，然后内部也是一个个所谓的链表结构（bin），同步的粒度要更细致一些。&lt;/li&gt;
&lt;li&gt;其内部仍然有 Segment 定义，但仅仅是为了保证序列化时的兼容性而已，不再有任何结构上的用处。&lt;/li&gt;
&lt;li&gt;因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销，解决了老版本很多人抱怨的这一点。&lt;/li&gt;
&lt;li&gt;数据存储利用 volatile 来保证可见性。&lt;/li&gt;
&lt;li&gt;使用 CAS 等操作，在特定场景进行无锁并发操作。&lt;/li&gt;
&lt;li&gt;使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Mybatis之参数篇</title>
        <link>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E5%8F%82%E6%95%B0%E7%AF%87/</link>
        <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E5%8F%82%E6%95%B0%E7%AF%87/</guid>
        <description>&lt;h3 id=&#34;参数传递符号&#34;&gt;参数传递符号&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;#{}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${}&lt;/p&gt;
&lt;p&gt;select * from tbl_employee where id=${id} and last_name=#{userName}
Preparing: select * from tbl_employee where id=&amp;lsquo;admin&amp;rsquo; and last_name=?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别：&lt;br&gt;
#{}:是以预编译的形式，将参数设置到sql语句中。通过PreparedStatement可防止sql注入。&lt;br&gt;
大多情况下，取参数的值都应该使用#{}。&lt;/p&gt;
&lt;p&gt;${}:取出的值直接拼装在sql语句中；会有安全问题；&lt;br&gt;
原生jdbc不支持占位符的地方我们就可以使用${}进行取值，比如分表、排序；按照年份分表拆分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from ${year}_salary where xxx;
select * from tb_sys_user order by ${f_name} ${order}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;更丰富的用法&#34;&gt;#{}更丰富的用法&lt;/h3&gt;
&lt;p&gt;规定参数的一些规则：
javaType、 jdbcType、 mode（存储过程）、 numericScale、resultMap、 typeHandler、 jdbcTypeName、 expression（未来准备支持的功能）；&lt;/p&gt;
&lt;p&gt;jdbcType通常需要在某种特定的条件下被设置：在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）；
JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不能正确处理;&lt;/p&gt;
&lt;p&gt;由于全局配置中：jdbcTypeForNull=OTHER；oracle不支持；有以下两种办法解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;#{email,jdbcType=OTHER}&lt;/li&gt;
&lt;li&gt;jdbcTypeForNull=NULL &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;参数传递&#34;&gt;参数传递&lt;/h3&gt;
&lt;h4 id=&#34;单个参数&#34;&gt;单个参数&lt;/h4&gt;
&lt;p&gt;#{参数名/任意名}：取出参数值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- TbSysUser getUserById(String id); --&amp;gt;
&amp;lt;!-- parameterType=&amp;quot;java.lang.String&amp;quot; 可不加 --&amp;gt;
&amp;lt;select id=&amp;quot;getUserById&amp;quot; resultType=&amp;quot;com.wm.demo.mybatis.model.TbSysUser&amp;quot;&amp;gt;
    select * from tb_sys_user where user_id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;多个参数&#34;&gt;多个参数&lt;/h4&gt;
&lt;p&gt;mybatis会做特殊处理。多个参数会被封装成一个map。&lt;br&gt;
key：param1&amp;hellip;paramN,或者参数的索引也可以&lt;br&gt;
value：传入的参数值&lt;br&gt;
#{}就是从map中获取指定的key的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- TbSysUser getUserByIdAndName(String id, String userName); --&amp;gt;
&amp;lt;select id=&amp;quot;getUserByIdAndName&amp;quot; resultType=&amp;quot;com.wm.demo.mybatis.model.TbSysUser&amp;quot;&amp;gt;
    select * from tb_sys_user where user_id = #{0} and user_name like #{1}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;map封装多个参数&#34;&gt;Map封装多个参数&lt;/h4&gt;
&lt;p&gt;#{key}：取出map中对应的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- TbSysUser getUserByMap(Map&amp;lt;String, Object&amp;gt; map); --&amp;gt;
&amp;lt;select id=&amp;quot;getUserByMap&amp;quot; resultType=&amp;quot;com.wm.demo.mybatis.model.TbSysUser&amp;quot;&amp;gt;
    select * from tb_sys_user where user_id = #{userId} and user_name like #{userName}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;pojo作为参数&#34;&gt;POJO作为参数&lt;/h4&gt;
&lt;p&gt;#{属性名}：取出传入的pojo的属性值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- boolean updateUser(TbSysUser user); --&amp;gt;
&amp;lt;update id=&amp;quot;updateUser&amp;quot;&amp;gt;
    update tb_sys_user 
    set password=#{password},status=#{status}
    where user_id=#{userId}
&amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;to作为参数&#34;&gt;TO作为参数&lt;/h4&gt;
&lt;p&gt;如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO（Transfer Object）数据传输对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Page{
    int index;
    int size;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;注解方式&#34;&gt;注解方式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- TbSysUser getUserAnnoationByIdAndName(@Param(&amp;quot;id&amp;quot;) String id, @Param(&amp;quot;userName&amp;quot;) String userName); --&amp;gt;
&amp;lt;select id=&amp;quot;getUserAnnoationByIdAndName&amp;quot; resultType=&amp;quot;com.wm.demo.mybatis.model.TbSysUser&amp;quot;&amp;gt;
    select * from tb_sys_user where user_id = #{id} and user_name like #{userName}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;list封装数据集合涉及动态sql&#34;&gt;List封装数据集合（涉及动态SQL）&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- List&amp;lt;TbSysUser&amp;gt; getUsersByConditionForeach(@Param(&amp;quot;ids&amp;quot;)List&amp;lt;String&amp;gt; ids); --&amp;gt;
&amp;lt;select id=&amp;quot;getUsersByConditionForeach&amp;quot; resultType=&amp;quot;com.wm.demo.mybatis.model.TbSysUser&amp;quot;&amp;gt;
    select * from tb_sys_user
    &amp;lt;!--
        collection：指定要遍历的集合：
            list类型的参数会特殊处理封装在map中，map的key就叫list
        item：将当前遍历出的元素赋值给指定的变量
        separator:每个元素之间的分隔符
        open：遍历出所有结果拼接一个开始的字符
        close:遍历出所有结果拼接一个结束的字符
        index:索引。遍历list的时候是index就是索引，item就是当前值
                      遍历map的时候index表示的就是map的key，item就是map的值
 		
        #{变量名}就能取出变量的值也就是当前遍历出的元素
      --&amp;gt;
    &amp;lt;foreach collection=&amp;quot;ids&amp;quot; item=&amp;quot;user_id&amp;quot; separator=&amp;quot;,&amp;quot; open=&amp;quot;where user_id in(&amp;quot; close=&amp;quot;)&amp;quot;&amp;gt;
        #{user_id}
    &amp;lt;/foreach&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;复杂情况&#34;&gt;复杂情况&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public TbSysUser getUser(@Param(&amp;quot;id&amp;quot;)Integer id,String userName);
取值：id==&amp;gt;#{id/param1}   userName==&amp;gt;#{param2}

public TbSysUser getUser(Integer id,@Param(&amp;quot;u&amp;quot;)TbSysUser user);
取值：id==&amp;gt;#{param1}    userName===&amp;gt;#{param2.userName/u.userName}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是Collection（List、Set）类型或者是数组，也会特殊处理。也是把传入的list或者数组封装在map中。&lt;br&gt;
key：Collection（collection）,如果是List还可以使用这个key(list) 数组(array)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;TbSysUser&amp;gt; getUsersByConditionForeach(@Param(&amp;quot;ids&amp;quot;)List&amp;lt;String&amp;gt; ids);
取值：取出第一个id的值：   #{list[0]}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;处理参数源码&#34;&gt;处理参数源码&lt;/h3&gt;
&lt;p&gt;总结：参数多时会封装map，为了不混乱，我们可以使用@Param来指定封装时使用的key；#{key}就可以取出map中的值；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TbSysUser getUserAnnoationByIdAndName(@Param(&amp;quot;id&amp;quot;) String id, @Param(&amp;quot;userName&amp;quot;) String userName);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ParamNameResolver解析参数封装map的；
//1、names：{0=id, 1=userName}；构造器的时候就确定好了&lt;/p&gt;
&lt;p&gt;确定流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取每个标了param注解的参数的@Param的值：id，userName赋值给name;&lt;/li&gt;
&lt;li&gt;每次解析一个参数给map中保存信息：（key：参数索引，value：name的值）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;name的值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标注了param注解：注解的值&lt;/li&gt;
&lt;li&gt;没有标注：&lt;/li&gt;
&lt;li&gt;全局配置：useActualParamName（jdk1.8）：name=参数名&lt;/li&gt;
&lt;li&gt;name=map.size()；相当于当前元素的索引&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试数据：args[ &amp;lsquo;admin&amp;rsquo;，&amp;ldquo;测试%&amp;quot;]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Object getNamedParams(Object[] args) {
    final int paramCount = names.size();
    //1、参数为null直接返回
    if (args == null || paramCount == 0) {
      return null;
	 
    //2、如果只有一个元素，并且没有Param注解；args[0]：单个参数直接返回
    } else if (!hasParamAnnotation &amp;amp;&amp;amp; paramCount == 1) {
      return args[names.firstKey()];
	  
    //3、多个元素或者有Param标注
    } else {
      final Map&amp;lt;String, Object&amp;gt; param = new ParamMap&amp;lt;Object&amp;gt;();
      int i = 0;
	  
      //4、遍历names集合；{0=id, 1=userName}
      for (Map.Entry&amp;lt;Integer, String&amp;gt; entry : names.entrySet()) {
	  
        //names集合的value作为key;  names集合的key又作为取值的参考args[0]
        //eg:{id=args[0]:admin,lastName=args[1]:测试%}
        param.put(entry.getValue(), args[entry.getKey()]);
		
		
        // add generic param names (param1, param2, ...)param
        //额外的将每一个参数也保存到map中，使用新的key：param1...paramN
        //效果：有Param注解可以#{指定的key}，或者#{param1}
        final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1);
        // ensure not to overwrite parameter named with @Param
        if (!names.containsValue(genericParamName)) {
          param.put(genericParamName, args[entry.getKey()]);
        }
        i++;
      }
      return param;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Mybatis之开发异常篇</title>
        <link>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E5%BC%80%E5%8F%91%E5%BC%82%E5%B8%B8%E7%AF%87/</link>
        <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/mybatis%E4%B9%8B%E5%BC%80%E5%8F%91%E5%BC%82%E5%B8%B8%E7%AF%87/</guid>
        <description>&lt;h2 id=&#34;mapped-statements-collection-does-not-contain&#34;&gt;mapped Statements collection does not contain&lt;/h2&gt;
&lt;p&gt;初次接触使用Mybatis会出现“Mapped Statements collection does not contain value for &amp;hellip;.“错误提示&lt;/p&gt;
&lt;p&gt;常见的错误原因有几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mapper.xml中没有加入namespace&lt;/li&gt;
&lt;li&gt;mapper.xml中的方法和接口mapper的方法不对应&lt;/li&gt;
&lt;li&gt;mapper.xml没有加入到mybatis-config.xml中(即总的配置文件)，例外：配置了mapper文件的包路径的除外&lt;/li&gt;
&lt;li&gt;mapper.xml文件名和所写的mapper名称不相同。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Java开发之常量定义</title>
        <link>https://ianeiu.github.io/p/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89/</link>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89/</guid>
        <description>&lt;p&gt;原文： &lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/autofei/article/details/6419460&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何在Java中定义常量(Constant)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;java中定义常量的四种方法&#34;&gt;Java中定义常量的四种方法&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/** 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Method One 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 采用接口(Interface)的中变量默认为static final的特性。
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;  
&lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ConstantInterface&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;SUNDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;MONDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;TUESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;WEDNESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;THURSDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;FRIDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;SATURDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  

&lt;span class=&#34;cm&#34;&gt;/** 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Method Two
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 采用了Java 5.0中引入的Enum类型 (推荐使用)
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;  
&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConstantEnum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
 
&lt;span class=&#34;cm&#34;&gt;/** 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Method Three 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 采用了在普通类中使用static final修饰变量的方法
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;  
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ConstantClassField&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;SUNDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;MONDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;TUESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;WEDNESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;THURSDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;FRIDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;SATURDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;cm&#34;&gt;/** 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Method Four 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 类似方法三，但是通过函数来获取常量
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * http://www.ibm.com/developerworks/cn/java/l-java-interface/index.html
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;  
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ConstantClassFunction&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;SUNDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;MONDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;TUESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;WEDNESDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;THURSDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;FRIDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;SATURDAY&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getSunday&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getMonday&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getTuesday&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getWednesday&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getThursday&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getFirday&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getSaturday&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;TestConstant&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;day&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;saturday&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Is today Saturday?&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;day&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConstantInterface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;SATURDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;day&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConstantEnum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;SATURDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()));&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;day&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConstantClassField&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;SATURDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;  
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;day&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConstantClassFunction&lt;/span&gt;  
				&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getSaturday&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()));&lt;/span&gt;  
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Java面试之初中级题集</title>
        <link>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%88%9D%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%9B%86/</link>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%88%9D%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%9B%86/</guid>
        <description>&lt;h3 id=&#34;数组在内存中如何分配&#34;&gt;数组在内存中如何分配&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;简单的值类型的数组，每个数组成员是一个引用（指针），引用到栈上的空间（因为值类型变量的内存分配在栈上）&lt;/li&gt;
&lt;li&gt;引用类型，类类型的数组，每个数组成员仍是一个引用（指针），引用到堆上的空间（因为类的实例的内存分配在堆上）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;string的substring方法内部是如何实现&#34;&gt;String的substring()方法内部是如何实现&lt;/h3&gt;
&lt;p&gt;substring方法通过原字符串创建了一个新的对象。&lt;br&gt;
当为字符串分配内存时，char数组value[]存储字符，offset=0，count=字符串长度。&lt;/p&gt;
&lt;p&gt;在Java6里，由substring(start,end)调用构造函数String(int,in,char[])时，实际上是改变offset和count的位置达到取得子字符串的目的，而子字符串里的value[]数组，因为引用是强引用，仍然指向原字符串。&lt;br&gt;
由于String是不可变的(immutable)，基于这种共享同一个字符数组的设计有以下好处：  调用substring()时无需复制数组，可重用value[]数组；且substring()的运行是常数时间，非线性，性能得到提高；而劣势，便是可能会产生内存泄露。&lt;br&gt;
假设原字符串s有1GB，且我们需要的是s.substring(1,10)这样一段小的字符串，但由于substring()里的value[]数组仍然指向1GB的原字符串，导致原字符串无法在GC中释放，从而产生了内存泄露。&lt;/p&gt;
&lt;p&gt;在Java7里，String的substring()方法实现已经改变，由原来的共享数组变成了传统的拷贝，原字符串的字符数组已经不再被引用，杜绝了内存泄露的同时也将运行时间由常数变成了线性，这个改变也使得substring()创建字符串的操作更加耗时，以前的开销是O(1)，现在最坏情况是O(n)。&lt;/p&gt;
&lt;h3 id=&#34;什么是不可修改对象immutable-object&#34;&gt;什么是不可修改对象(Immutable Object)&lt;/h3&gt;
&lt;p&gt;可修改对象是那些一旦被创建就不能修改的对象。对这种对象的任何改动的后果都是会创建一个新的对象，而不是在原对象本身做修改。&lt;/p&gt;
&lt;p&gt;大多数这样的类通常都是final类型的，因为这样可以避免自己被继承继而被覆盖方法。例如Java中的String类。&lt;/p&gt;
&lt;p&gt;也可以通过将类的成员设置成private非final的来获得同样的效果。同时类不能通过方法暴露成员，特别是可修改类型的成员。&lt;br&gt;
当类的方法接收客户类传入的可修改对象的话，应该使用一个复制的对象来防止客户代码来修改这个传入的可修改类。比如，传入java.util.Date对象的话，应该使用clone()方法来获得一个副本。&lt;br&gt;
当通过类方法返回一个可修改对象时，需要返回的是类对象的副本，防止客户代码通过此引用修改了成员对象的属性。&lt;/p&gt;
&lt;h3 id=&#34;什么时候需要重写hashcode和equals方法&#34;&gt;什么时候需要重写hashCode()和equals()方法&lt;/h3&gt;
&lt;p&gt;当你需要根据业务逻辑来进行相等性判断、而不是根据对象相等性来判断的时候你就需要重写这两个函数了。&lt;br&gt;
例如，两个Employee对象相等的依据是它们拥有相同的emp_id，尽管它们有可能是两个不同的对象，并且分别在不同的地方被创建。同时，如果你准备把它们当作HashMap中的key来使用的话，你也必须重写这两个方法。现在，作为Java中equals-hashcode的一个约定，当你重写equals的时候必须也重写hashcode，否则你会打破诸如Set, Map等集合赖以正常工作的约定。&lt;/p&gt;
&lt;p&gt;当你向HashMap插入一个key的时候，首先，这个对象的hashCode()方法会被调用，调用结果用来计算将要存储的位置(bucket)。&lt;br&gt;
因为某个位置上可能以链表的方式已经包含了多个Map.Entry对象，所以HashMap会使用equals()方法来将此对象与所有这些Map.Entry所包含的key进行对比，以确定此key对象是否已经存在。&lt;/p&gt;
&lt;h3 id=&#34;mybatis如何处理结果集&#34;&gt;mybatis如何处理结果集&lt;/h3&gt;
&lt;p&gt;MyBatis的结果集是通过反射来实现的。并不是通过get/set方法。在实体类中无论是否定义get/set()方法，都是可以接收到的。&lt;/p&gt;
&lt;h3 id=&#34;cookie和session的区别分布式环境怎么保存用户状态&#34;&gt;cookie和session的区别，分布式环境怎么保存用户状态&lt;/h3&gt;
&lt;p&gt;1、cookie数据存放在客户的浏览器上，session数据放在服务器上。&lt;br&gt;
2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。&lt;br&gt;
3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。&lt;br&gt;
4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。&lt;/p&gt;
&lt;p&gt;分布式环境下的session（举例两种）：&lt;/p&gt;
&lt;p&gt;服务器session复制&lt;br&gt;
原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。&lt;br&gt;
优点：可容错，各个服务器间session能够实时响应。&lt;br&gt;
缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。&lt;/p&gt;
&lt;p&gt;session共享机制&lt;br&gt;
使用分布式缓存方案比如memcached、redis，但是要求Memcached或Redis必须是集群。&lt;/p&gt;
&lt;h3 id=&#34;写一段栈溢出堆溢出的代码&#34;&gt;写一段栈溢出、堆溢出的代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test {  
 
    //不断创建对象可以导致堆溢出
   public void testHeap(){  
       for(;;){  
             ArrayList list = new ArrayList (2000);  
         }  
   }  
   
   //递归调用可以导致栈溢出
   int num=1;  
   public void testStack(){  
       num++;  
       this.testStack();  
    }  
	 
   public static void main(String[] args){  
       Test  t  = new Test ();  
       t.testHeap();  
       t.testStack();     
   }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;char型变量中能不能存储一个中文汉字&#34;&gt;char型变量中能不能存储一个中文汉字&lt;/h3&gt;
&lt;p&gt;在Java中，char类型占2个字节，而且Java默认采用Unicode编码，以个Unicode码是16位，所以一个Unicode码占两个字节，Java中无论汉子还是英文字母都是用Unicode编码来表示的。所以在Java中char类型变量可以存储一个中文汉字。&lt;/p&gt;
&lt;h3 id=&#34;java中实现多态的机制是什么&#34;&gt;java中实现多态的机制是什么&lt;/h3&gt;
&lt;p&gt;靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。&lt;/p&gt;
&lt;h2 id=&#34;java-io-中的设计模式&#34;&gt;JAVA IO 中的设计模式&lt;/h2&gt;
&lt;p&gt;Java I/O库的总体设计是符合装饰模式和适配器模式的。&lt;/p&gt;
&lt;p&gt;装饰模式：在由InputStream、OutputStream、Reader和Writer代表的等级结构内部，有一些流处理器可以对另一些流处理器起到装饰作用，形成新的、具有改善了的功能的流处理器。&lt;/p&gt;
&lt;p&gt;适配器模式：在由InputStream、OutputStream、Reader和Writer代表的等级结构内部，有一些流处理器是对其他类型的流处理器的适配。这就是适配器的应用。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JVM笔记之JVM结构</title>
        <link>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/</link>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h2 id=&#34;jvm运行时数据区&#34;&gt;JVM运行时数据区&lt;/h2&gt;
&lt;p&gt;运行时数据区（分布在操作系统堆中，由程序员管理）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;虚拟机栈（Java栈）&lt;/li&gt;
&lt;li&gt;堆（Java堆）&lt;/li&gt;
&lt;li&gt;本地方法栈/区&lt;/li&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/JVM%E7%BB%93%E6%9E%84.jpg&#34; data-size=&#34;473x474&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/JVM%E7%BB%93%E6%9E%84_hu2e55354234b01ccc46138ee3e1dda078_27827_480x0_resize_q75_box.jpg 480w, https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/JVM%E7%BB%93%E6%9E%84_hu2e55354234b01ccc46138ee3e1dda078_27827_1024x0_resize_q75_box.jpg 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/JVM%E7%BB%93%E6%9E%84.jpg&#34; width=&#34;473&#34; height=&#34;474&#34; loading=&#34;lazy&#34;
				alt=&#34;JVM结构&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;JVM结构&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;虽然这几个区域都是属于运行时数据区，但是这几个区域的创建时机是不一致的，有的是随虚拟机启动而创建的，随虚拟机销毁而销毁；有的是随线程创建而创建，随线程销毁而销毁。&lt;/p&gt;
&lt;h2 id=&#34;线程独享的区域&#34;&gt;线程独享的区域&lt;/h2&gt;
&lt;h4 id=&#34;程序计数器&#34;&gt;程序计数器&lt;/h4&gt;
&lt;p&gt;程序计数器是来指示当前线程正在执行的JVM指令，因此程序计数器是线程独有的。一个JVM支持多个线程，每一个线程都要自己的程序计数器。&lt;br&gt;
如果线程正在执行的方法是Java方法，则程序计数器保存的是当前线程正在执行的JVM指令，如果正在执行的方法是Native方法，则保存为空（undefined)。&lt;/p&gt;
&lt;h4 id=&#34;虚拟机栈&#34;&gt;虚拟机栈&lt;/h4&gt;
&lt;p&gt;每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用。每个栈中的数据(原始类型和对象引用)都是私有的。数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失。 &lt;br&gt;
栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。&lt;/p&gt;
&lt;h4 id=&#34;本地方法区&#34;&gt;本地方法区&lt;/h4&gt;
&lt;p&gt;本地方法区存储着native方法的调用状态，一般会随着线程创建而针对每一个线程分配。&lt;/p&gt;
&lt;h2 id=&#34;全局共享的区域&#34;&gt;全局共享的区域&lt;/h2&gt;
&lt;h4 id=&#34;方法区&#34;&gt;方法区&lt;/h4&gt;
&lt;p&gt;方法区是可供各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量等。当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域。&lt;/p&gt;
&lt;p&gt;由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行时常量池&lt;/strong&gt; ：方法区的一部分&lt;!-- raw HTML omitted --&gt;（Java jdk1.7中的常量池是移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域）	&lt;!-- raw HTML omitted --&gt;，存放着类中固定的常量信息、方法、和field的引用信息。JVM在加载类的时候会为每一个Class分配一个独立的常量池。&lt;/p&gt;
&lt;h4 id=&#34;堆&#34;&gt;堆&lt;/h4&gt;
&lt;p&gt;JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，存储着所有类实例即类对象和数组对象。对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定&lt;/p&gt;
&lt;p&gt;理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/JVM.png&#34; data-size=&#34;841x566&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/JVM_huf42431e4d3f849fd5ce15bbefe0a07a3_53400_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/JVM_huf42431e4d3f849fd5ce15bbefe0a07a3_53400_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/JVM.png&#34; width=&#34;841&#34; height=&#34;566&#34; loading=&#34;lazy&#34;
				alt=&#34;JVM&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;JVM&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;JVM 本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT Compiler 在运行时对热点方法进行编译，就会将编译后的方法储存在 Code Cache 里面；GC 等功能需要运行在本地线程之中，类似部分都需要占用内存空间。&lt;/p&gt;
&lt;p&gt;JDK 已经发生了很大变化，Intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，Intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。&lt;/p&gt;
&lt;h2 id=&#34;堆内部结构&#34;&gt;堆内部结构&lt;/h2&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/HeapInner.png&#34; data-size=&#34;970x302&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/HeapInner_hu738fb74c2abf465018e53ea09ad814c8_36750_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/HeapInner_hu738fb74c2abf465018e53ea09ad814c8_36750_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8Bjvm%E7%BB%93%E6%9E%84/HeapInner.png&#34; width=&#34;970&#34; height=&#34;302&#34; loading=&#34;lazy&#34;
				alt=&#34;堆内部结构&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;堆内部结构&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新生代&lt;/p&gt;
&lt;p&gt;新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫from、to 区域，被用来放置从 Minor GC 中保留下来的对象。&lt;/p&gt;
&lt;p&gt;JVM 会随意选取一个 Survivor 区域作为“to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 from 区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老年代&lt;/p&gt;
&lt;p&gt;放置长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久代&lt;/p&gt;
&lt;p&gt;这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存，在 JDK 8 之后就不存在永久代这块儿了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>WebService简介</title>
        <link>https://ianeiu.github.io/p/webservice%E7%AE%80%E4%BB%8B/</link>
        <pubDate>Mon, 03 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/webservice%E7%AE%80%E4%BB%8B/</guid>
        <description>&lt;h1 id=&#34;webservice简介&#34;&gt;WebService简介&lt;/h1&gt;
&lt;p&gt;webService（又名XML Web Service）是一种跨语言跨操作系统的远程调用技术（是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术）。&lt;/p&gt;
&lt;h3 id=&#34;webservice平台技术&#34;&gt;WebService平台技术&lt;/h3&gt;
&lt;h4 id=&#34;xmlxsd&#34;&gt;XML+XSD&lt;/h4&gt;
&lt;p&gt;WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的 返回结果是什么）。&lt;br&gt;
XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。&lt;/p&gt;
&lt;h4 id=&#34;soap&#34;&gt;SOAP&lt;/h4&gt;
&lt;p&gt;SOAP是&amp;quot;简单对象访问协议&amp;quot;，是一种简单的、基于HTTP和XML的协议, 用于在WEB上交换结构化的数据。&lt;br&gt;
soap消息：请求消息和响应消息&lt;/p&gt;
&lt;h4 id=&#34;wsdl&#34;&gt;WSDL&lt;/h4&gt;
&lt;p&gt;WSDL是webservice定义语言, 对应.wsdl文档, 一个webservice会对应一个唯一的wsdl文档, 定义了客户端与服务端发送请求和响应的数据格式和过程。&lt;/p&gt;
&lt;h3 id=&#34;工作调用原理&#34;&gt;工作调用原理&lt;/h3&gt;
&lt;p&gt;对客户端而言，我们给这各类WebService客户端API传递wsdl文件的url地址，这些API就会创建出底层的代理类，我们调用 这些代理，就可以访问到webservice服务。&lt;/p&gt;
&lt;p&gt;代理类把客户端的方法调用变成soap格式的请求数据再通过HTTP协议发出去，并把接收到的soap 数据变成返回值返回。&lt;/p&gt;
&lt;p&gt;对服务端而言，各类WebService框架的本质就是一个大大的Servlet，当远程调用客户端给它通过http协议发送过来 soap格式的请求数据时，它分析这个数据，就知道要调用哪个java类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成 soap格式的数据，通过http响应消息回给客户端。&lt;/p&gt;
&lt;h3 id=&#34;相比httppostget的优势&#34;&gt;相比HTTP（post/get）的优势&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;接口中实现的方法和要求参数一目了然&lt;/li&gt;
&lt;li&gt;不用担心大小写问题&lt;/li&gt;
&lt;li&gt;不用担心中文urlencode问题&lt;/li&gt;
&lt;li&gt;代码中不用多次声明认证(账号,密码)参数&lt;/li&gt;
&lt;li&gt;传递参数可以为数组，对象等&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;框架简介&#34;&gt;框架简介&lt;/h1&gt;
&lt;h3 id=&#34;jws&#34;&gt;JWS&lt;/h3&gt;
&lt;p&gt;JWS是Java语言对WebService服务的一种实现，用来开发和发布服务。而从服务本身的角度来看JWS服务是没有语言界限的。但是Java语言为Java开发者提供便捷发布和调用WebService服务的一种途径。&lt;/p&gt;
&lt;h3 id=&#34;axis2&#34;&gt;Axis2&lt;/h3&gt;
&lt;p&gt;Axis2是从Axis1.x系列发展而来，不过它从底层全部重新实现，使用了新的扩展性更好模块架构。&lt;/p&gt;
&lt;p&gt;Axis2是Apache下的一个重量级WebService框架，准确说它是一个Web Services / SOAP / WSDL 的引擎，是WebService框架的集大成者，它能不但能制作和发布WebService，而且可以生成Java和其他语言版WebService客户端和服务端代码。这是它的优势所在。但是，这也不可避免的导致了Axis2的复杂性，使用过的开发者都知道，它所依赖的包数量和大小都是很惊人的，打包部署发布都比较麻烦，不能很好的与现有应用整合为一体。但是如果你要开发Java之外别的语言客户端，Axis2提供的丰富工具将是你不二的选择。&lt;/p&gt;
&lt;h3 id=&#34;xfire&#34;&gt;XFire&lt;/h3&gt;
&lt;p&gt;XFire是一个高性能的WebService框架，它的响应时间是Axis1.3的1/2到1/5，在Java6之前，它的知名度甚至超过了Apache的Axis2，XFire的优点是开发方便，与现有的Web整合很好，可以融为一体，并且开发也很方便。但是对Java之外的语言，没有提供相关的代码工具。XFire后来被Apache收购了，原因是它太优秀了，收购后，随着Java6 JWS的兴起，开源的WebService引擎已经不再被看好，渐渐的都败落了。现在估计只有老旧项目还在使用。&lt;/p&gt;
&lt;h3 id=&#34;cxf&#34;&gt;CXF&lt;/h3&gt;
&lt;p&gt;CXF是Apache旗下一个重磅的SOA简易框架，它实现了ESB（企业服务总线），支持可集成spring。CXF是XFire和Celtix项目的结合产品，是XFire经过改造后形成的，就像目前的Struts2来自WebWork一样。可以看出XFire的命运会和WebWork的命运一样，最终会淡出人们的视线。CXF不但是一个优秀的Web Services / SOAP / WSDL 引擎，也是一个不错的ESB总线，为SOA的实施提供了一种选择方案，当然他不是最好的，它仅仅实现了SOA架构的一部分。&lt;/p&gt;
&lt;h3 id=&#34;axis2与cxf比较&#34;&gt;Axis2与CXF比较&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通用结构WS-Policy等，数据并对XMLBeans等，Axis2与CXF后面的几个版本基本都支持了，差别不大。&lt;/li&gt;
&lt;li&gt;CXF可以很好支持Spring。Axis2不能&lt;/li&gt;
&lt;li&gt;Axis2支持多语言-除了Java,他还支持C/C++版本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从开发者的角度，两个框架的特性相当的不同。&lt;br&gt;
Axis2的开发方式类似一个小型的应用服务器，Axis2的开发包要以WAR的形式部署到Servlet容器中，比如Tomcat，通过这些容器可以对工作中的Web Service进行很好的监控和管理。Axis2的Web administrion模块可以让我们动态的配置Axis2.一个新的服务可以上载，激活，使之失效，修改web服务的参数。管理UI也可以管理一个或者多个处于运行状态的服务。这种界面化管理方式的一个弊端是所有在运行时修改的参数没有办法保存，因为在重启动之后，你所做的修改就会全部失效。Axis2允许自己作为独立的应用来发布Web Service，并提供了大量的功能和一个很好的模型，这个模型可以通过它本身的架构（modular architecture）不断添加新的功能。有些开发人员认为这种方式对于他们的需求太过于繁琐。这些开发人员会更喜欢CXF。&lt;br&gt;
CXF更注重开发人员的工效（ergonomics）和嵌入能力（embeddability）。大多数配置都可以API来完成，替代了比较繁琐的XML配置文件， Spring的集成性经常的被提及，CXF支持Spring2.0和CXF&amp;rsquo;s API和Spring的配置文件可以非常好的对应。CXF强调代码优先的设计方式（code-first design)，使用了简单的API使得从现有的应用开发服务变得方便。&lt;br&gt;
不过你选择Axis2还是CXF，你都可以从开源社区得到大量的帮助。这两个框架都有商业公司提供服务，WSO2提供AXIS2的支持，Iona提供CXF的支持。这两公司都有很活跃的开发者社区。&lt;/p&gt;
&lt;h3 id=&#34;如何选择&#34;&gt;如何选择？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如果应用程序需要多语言的支持，Axis2 应当是首选了；&lt;/li&gt;
&lt;li&gt;如果应用程序侧重JAVA并希望和Spring集，Apache CXF 是一种更好的选择，特别对嵌入式的 Web Services 来说；&lt;/li&gt;
&lt;li&gt;如果应用程序没有新的特性需要的话，就仍用原来项目所用的框架，比如 Axis1，XFire，Celtrix或 BEA 等等厂家自己的 Web Services 实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/growup/archive/2011/03/06/1972464.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;每天进步一点点~&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/xdp-gacl/p/4048937.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;孤傲苍狼~&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SpringMVC的运行流程及九大组件</title>
        <link>https://ianeiu.github.io/p/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/</link>
        <pubDate>Thu, 30 Aug 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/</guid>
        <description>&lt;h1 id=&#34;运行流程&#34;&gt;运行流程&lt;/h1&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;https://ianeiu.github.io/p/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/SpringMVC%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png&#34; data-size=&#34;641x274&#34;&gt;
			&lt;img srcset=&#34;https://ianeiu.github.io/p/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/SpringMVC%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B_hub7ac2502c531e108ef59893811657530_29061_480x0_resize_box_2.png 480w, https://ianeiu.github.io/p/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/SpringMVC%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B_hub7ac2502c531e108ef59893811657530_29061_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;https://ianeiu.github.io/p/springmvc%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6/SpringMVC%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png&#34; width=&#34;641&#34; height=&#34;274&#34; loading=&#34;lazy&#34;
				alt=&#34;&amp;nbsp;&#34;&gt;
		&lt;/a&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户发送请求至前置控制器DispatcherServlet&lt;/li&gt;
&lt;li&gt;DispatcherServlet收到请求调用HandlerMapping处理器映射器。&lt;/li&gt;
&lt;li&gt;处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。&lt;/li&gt;
&lt;li&gt;DispatcherServlet通过HandlerAdapter处理器适配器调用处理器&lt;/li&gt;
&lt;li&gt;执行处理器/后端控制器Controller&lt;/li&gt;
&lt;li&gt;Controller执行完成返回ModelAndView&lt;/li&gt;
&lt;li&gt;HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet&lt;/li&gt;
&lt;li&gt;DispatcherServlet将ModelAndView传给视图解析器ViewReslover&lt;/li&gt;
&lt;li&gt;ViewReslover解析后返回具体View&lt;/li&gt;
&lt;li&gt;DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。&lt;/li&gt;
&lt;li&gt;DispatcherServlet响应用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面可以看出，DispatcherServlet有接收请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度。&lt;/p&gt;
&lt;h1 id=&#34;九大组件&#34;&gt;九大组件&lt;/h1&gt;
&lt;h3 id=&#34;handlermapping&#34;&gt;HandlerMapping&lt;/h3&gt;
&lt;p&gt;处理器映射器:根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet&lt;/p&gt;
&lt;h3 id=&#34;handleradapter&#34;&gt;HandlerAdapter&lt;/h3&gt;
&lt;p&gt;适配器。因为SpringMVC中的Handler可以是任意的形式,但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。HandlerAdapter的作用就是让固定的Servlet处理方法调用Handler（Controller）来进行处理。&lt;/p&gt;
&lt;p&gt;有篇文章总结的很好：Handler是用来干活的工具；HandlerMapping用于根据需要干的活找到相应的工具；HandlerAdapter是使用工具干活的人。&lt;/p&gt;
&lt;h3 id=&#34;handlerexceptionresolver&#34;&gt;HandlerExceptionResolver&lt;/h3&gt;
&lt;p&gt;异常处理:自定义异常处理类继承此类或其子类，实现resolveException方法。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class GlobalExceptionResolver implements HandlerExceptionResolver {
	...
	/**
	 * 针对请求处理异常
	 */
	@Override
	public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
			Exception ex) {
		boolean isHttpApi = isHttpApi(handler);
		HandleResult result = handleException(ex);
		if (isReturnReponseBody(handler) || isHttpApi) {
			if(isHttpApi){
				result =  apiHandleException(ex);
			}
			
			ModelAndView modelAndView = new ModelAndView();
			//处理异常
			response.setContentType(&amp;quot;application/json;charset=UTF-8&amp;quot;);
			byte[] bytes = JSON.toJSONBytes(Result.fail(result.getCode(), result.getMessage()), SerializerFeature.DisableCircularReferenceDetect, SerializerFeature.WriteMapNullValue);
			try {
				response.getOutputStream().write(bytes);
				response.getOutputStream().flush();
			} catch (IOException e) {
				log.error(&amp;quot;打印错误信息出错!&amp;quot;, e);
			}
			modelAndView.clear();
			return modelAndView;
		}else {
			Map&amp;lt;String, String&amp;gt; model = Maps.newHashMap();
			model.put(&amp;quot;code&amp;quot;, result.getCode());
			model.put(&amp;quot;message&amp;quot;, result.getMessage());
			return new ModelAndView(&amp;quot;500&amp;quot;, model);
		}
	}
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;viewresolver&#34;&gt;ViewResolver&lt;/h3&gt;
&lt;p&gt;视图解析器：当Controller将请求处理结果放入到ModelAndView中以后，DispatcherServlet会根据ModelAndView选择合适的视图进行渲染。ViewResolver接口有众多实现类，根据viewName创建合适类型的View实现。配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean class=&amp;quot;org.Springframework.web.servlet.view.InternalResourceViewResolve&amp;quot;&amp;gt;
	&amp;lt;property name=&amp;quot;prefix&amp;quot; value=&amp;quot;/WEB-INF/views/&amp;quot; /&amp;gt;
	&amp;lt;property name=&amp;quot;suffix&amp;quot; value=&amp;quot;.jsp&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;requesttoviewnametranslator&#34;&gt;RequestToViewNameTranslator&lt;/h3&gt;
&lt;p&gt;当Controller处理器方法没有返回一个View对象或逻辑视图名称，并且在该方法中没有直接往response的输出流里面写数据的时候，Spring就会采用约定好的方式提供一个逻辑视图名称。可通过实现接口org.Springframework.web.servlet.RequestToViewNameTranslator接口的getViewName方法来实现。&lt;/p&gt;
&lt;h3 id=&#34;localeresolver&#34;&gt;LocaleResolver&lt;/h3&gt;
&lt;p&gt;国际化配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring的国际化配置三种方式
&lt;ul&gt;
&lt;li&gt;基于URL参数的配置：通过URL参数来控制国际化
&lt;ol&gt;
&lt;li&gt;页面： &lt;code&gt;&amp;lt;a href=&amp;quot;myTest.jsp?locale=zh_CN&amp;quot;&amp;gt;简体中文&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置文件：&lt;code&gt;&amp;lt;bean id=&amp;quot;localeResolver&amp;quot; class=&amp;quot;org.Springframework.web.servlet.i18n.AcceptHeaderLocaleResolver&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;基于session的配置：通过检验用户会话中预置的属性来解析区域，最常用的是根据用户本次会话过程中的语言设定决定语言种类，如果该会话不存在，它会根据accept-language HTTP头部确定默认区域。配置&lt;!-- raw HTML omitted --&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;localeResolver&amp;quot; class=&amp;quot;org.Springframework.web.servlet.i18n.SessionLocaleResolver&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基于Cookie的国际化配置：用于通过浏览器的cookie设置取得Locale对象，这种策略在应用程序不支持会话或者状态必须保存在客户端时有用。&lt;!-- raw HTML omitted --&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;localeResolver&amp;quot; class=&amp;quot;org.Springframework.web.servlet.i18n.CookieLocaleResolver&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;themeresolver&#34;&gt;ThemeResolver&lt;/h3&gt;
&lt;p&gt;解析主题。一个主题就是一组静态资源（比如样式表、图片等），它们可以影响应用程序的视觉效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SpringMVC中跟主题相关的类
&lt;ul&gt;
&lt;li&gt;ThemeResolver:主题解析器&lt;/li&gt;
&lt;li&gt;ThemeSource:主题资源&lt;/li&gt;
&lt;li&gt;Theme:主题接口&lt;/li&gt;
&lt;li&gt;ThemeChangeInterceptor:根据用户请求来改变主题(需要在handlerMapping中配置拦截器&lt;!-- raw HTML omitted --&gt;&lt;code&gt;&amp;lt;property name=&amp;quot;interceptors&amp;quot;&amp;gt;&amp;lt;list&amp;gt;&amp;lt;ref local=&amp;quot;themeChangeInterceptor&amp;quot; /&amp;gt;&amp;lt;/list&amp;gt;&amp;lt;/property&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ThemeResolver子类
&lt;ul&gt;
&lt;li&gt;AbstractThemeResolver:SessionThemeResolver和FixedThemeResolver继承的抽象类&lt;/li&gt;
&lt;li&gt;SessionThemeResolver:用户的主题保存在HTTP session中&lt;/li&gt;
&lt;li&gt;CookieThemeResolver:用于实现用户所选的主题，以cookie的形式存放在客户端的机器上&lt;/li&gt;
&lt;li&gt;FixedThemeResolver:用于选择一个固定的主题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;multipartresolver&#34;&gt;MultipartResolver&lt;/h3&gt;
&lt;p&gt;MultipartResolver 用于处理文件上传，当收到请求时 DispatcherServlet 的 checkMultipart() 方法会调用 MultipartResolver 的 isMultipart() 方法判断请求中是否包含文件。如果请求数据中包含文件，则调用 MultipartResolver 的 resolveMultipart() 方法对请求的数据进行解析，然后将文件数据解析成 MultipartFile 并封装在 MultipartHttpServletRequest (继承了 HttpServletRequest) 对象中，最后传递给 Controller.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MultipartResolver子类
&lt;ul&gt;
&lt;li&gt;CommonsMultipartResolver：使用 commons Fileupload来处理 multipart请求，所以在使用时，必须要引入相应的jar包。而像SpringBoot是不支持CommonsMultipartResolver&lt;/li&gt;
&lt;li&gt;StandardServletMultipartResolver：基于Servlet3.0来处理multipart请求的，所以不需要引用其他jar包，从Tomcat7.0.x的版本开始就支持 Servlet 3.0了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>常见状态码简介</title>
        <link>https://ianeiu.github.io/p/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E4%BB%8B/</link>
        <pubDate>Thu, 23 Aug 2018 16:01:23 +0800</pubDate>
        
        <guid>https://ianeiu.github.io/p/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E4%BB%8B/</guid>
        <description>&lt;h2 id=&#34;部分状态码简介&#34;&gt;部分状态码简介&lt;/h2&gt;
&lt;h1 id=&#34;200&#34;&gt;200&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;200&lt;!-- raw HTML omitted --&gt;—&lt;code&gt;请求成功&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;202—&lt;code&gt;常用于异步请求。客户端发送请求到服务器，服务器立即返回一个202 Accepted表示已经成功接收到客户端的请求。后面怎么处理由服务器自己决定，一般服务器会给客户端预留一个可以查询处理状态的接口，客户端可以选择轮训该接口来知道请求的处理进度和结果。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;30x&#34;&gt;30X&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;301—&lt;code&gt;永久移动。被请求的资源已被永久移动位置&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;302&lt;!-- raw HTML omitted --&gt;—&lt;code&gt;请求的资源现在临时从不同的 URI 响应请求（请求重定向）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;305—&lt;code&gt;使用代理。被请求的资源必须通过指定的代理才能被访问&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;304—&lt;code&gt;请求资源没有改变&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;307—&lt;code&gt;临时跳转。被请求的资源在临时从不同的URL响应请求&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4xx&#34;&gt;4XX&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;400—&lt;code&gt;错误请求&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;402—&lt;code&gt;需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;403—&lt;code&gt;禁止访问。服务器已经理解请求，但是拒绝执行它&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;404&lt;!-- raw HTML omitted --&gt;—&lt;code&gt;找不到对象。请求失败，资源不存在&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;406—&lt;code&gt;不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;408—&lt;code&gt;请求超时&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;409—&lt;code&gt;冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;410—&lt;code&gt;遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;413—&lt;code&gt;响应实体太大(客户端上传图片太大等情况)。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;414—&lt;code&gt;客户端访问的URI太长，超出了服务器允许限制&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;417—&lt;code&gt;期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;418—&lt;code&gt;我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;420—&lt;code&gt;方法失效&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;422—&lt;code&gt;不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;500&#34;&gt;500&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;500&lt;!-- raw HTML omitted --&gt;—&lt;code&gt;服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Java笔记之常见的RuntimeException</title>
        <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84runtimeexception/</link>
        <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84runtimeexception/</guid>
        <description>&lt;h2 id=&#34;runtimeexception&#34;&gt;RuntimeException&lt;/h2&gt;
&lt;p&gt;运行时异常，是所有Java虚拟机正常操作期间可以被抛出的异常的父类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NumberFormatException - 数字格式异常&lt;/li&gt;
&lt;li&gt;NullPointerException - 空指针引用异常&lt;/li&gt;
&lt;li&gt;ClassCastException - 类型强制转换异常。&lt;/li&gt;
&lt;li&gt;IllegalArgumentException - 传递非法参数异常。&lt;/li&gt;
&lt;li&gt;ArithmeticException - 算术运算异常&lt;/li&gt;
&lt;li&gt;ArrayStoreException - 向数组中存放与声明类型不兼容对象异常&lt;/li&gt;
&lt;li&gt;IndexOutOfBoundsException - 下标越界异常&lt;/li&gt;
&lt;li&gt;NegativeArraySizeException - 创建一个大小为负数的数组错误异常&lt;/li&gt;
&lt;li&gt;UnsupportedOperationException - 不支持的方法异常。指明请求的方法不被支持情况的异常&lt;/li&gt;
&lt;li&gt;EnumConstantNotPresentException - 枚举常量不存在异常。当应用试图通过名称和枚举类型访问一个枚举对象，但该枚举对象并不包含常量时，抛出该异常。&lt;/li&gt;
&lt;li&gt;IllegalMonitorStateException - 违法的监控状态异常。当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常。&lt;/li&gt;
&lt;li&gt;IllegalStateException - 违法的状态异常。当在Java环境和应用尚未处于某个方法的合法调用状态，而调用了该方法时，抛出该异常。&lt;/li&gt;
&lt;li&gt;NegativeArraySizeException - 数组大小为负值异常。当使用负数大小值创建数组时抛出该异常。&lt;/li&gt;
&lt;li&gt;SecurityException 安全异常。由安全管理器抛出，用于指示违反安全情况的异常。&lt;/li&gt;
&lt;li&gt;TypeNotPresentException - 类型不存在异常。当应用试图以某个类型名称的字符串表达方式访问该类型，但是根据给定的名称又找不到该类型是抛出该异常。该异常与ClassNotFoundException的区别在于该异常是unchecked（不被检查）异常，而ClassNotFoundException是checked（被检查）异常。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>兼容IE的代码片段</title>
        <link>https://ianeiu.github.io/p/%E5%85%BC%E5%AE%B9ie%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</link>
        <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/%E5%85%BC%E5%AE%B9ie%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</guid>
        <description>&lt;h1 id=&#34;js&#34;&gt;JS&lt;/h1&gt;
&lt;hr&gt;
&lt;h5 id=&#34;方法函数减少使用js原生方法&#34;&gt;方法/函数：减少使用JS原生方法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;indexOf。可用jquery里的$.inArray替代indexOf。 具体使用：$.inArray(“a”, divarr)==-1&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;ajax&#34;&gt;AJAX：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;上传文件：IE下ajaxSubmit将file对象传递到控制层，建议使用ajaxFileUpload。&lt;br&gt;
有些方法调用获取数据是直接读缓存的，这时候加个属性 cache:false 即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;dom&#34;&gt;DOM：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;复选框赋值兼容问题：&lt;br&gt;
for(var k =0; k&amp;lt;number.length; k++){&lt;br&gt;
//$(&amp;quot;:checkbox[name=&amp;lsquo;tCheckTwo&amp;rsquo;][value=&#39;&amp;quot;+number[k]+&amp;quot;&#39;]&amp;quot;).attr(&amp;ldquo;checked&amp;rdquo;, true);&lt;br&gt;
//解决ie8的复选框赋值兼容问题。eq的是索引&lt;br&gt;
$(&amp;quot;:checkbox[name=&amp;lsquo;tCheckTwo&amp;rsquo;]&amp;quot;).eq(number[k]).attr(&amp;ldquo;checked&amp;rdquo;, true);&lt;br&gt;
};&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;css&#34;&gt;CSS&lt;/h1&gt;
&lt;hr&gt;
&lt;h5 id=&#34;ie支持rgba半透明的方法&#34;&gt;IE支持rgba半透明的方法：&lt;/h5&gt;
&lt;p&gt;低版本IE下不支持rgba()的表示方法， 如：background:rgba(0,0,0,0.5);&lt;br&gt;
使用代码,filter:progid:DXImageTransform.Microsoft.gradient(startcolorstr=#7F000000,endcolorstr=#7F000000);即可实现&lt;br&gt;
7F其实就是alpha*255换成16进制 。常用的rgba和IE下filter数值的转换：&lt;br&gt;
rgba透明值：0.1　　0.2　　0.3　　0.4　　0.5　　0.6　　0.7　　0.8　　0.9&lt;br&gt;
IE下filter值：19　　 33　　 4c　　 66　　  7f　　 99　　 b2　　 c8　　  e5&lt;/p&gt;
&lt;h1 id=&#34;html&#34;&gt;HTML&lt;/h1&gt;
&lt;hr&gt;
&lt;h5 id=&#34;隐藏元素&#34;&gt;隐藏元素：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;bBox&amp;quot; id=&amp;quot;orderOperDiv&amp;quot; style=&amp;quot;display: none;&amp;quot;&amp;gt;&amp;lt;!-- 兼容IE，不使用hidden --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;按钮value显示null&#34;&gt;按钮value显示null&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;上传&amp;quot; class=&amp;quot;sBtn&amp;quot; onclick=&amp;quot;uploadDataFile(1,0);&amp;quot; /&amp;gt; --&amp;gt;
&amp;lt;a href=&amp;quot;javascript:void(0);&amp;quot; class=&amp;quot;sBtn&amp;quot;  onclick=&amp;quot;uploadDataFile(1,0)&amp;quot;&amp;gt;上传&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;插件&#34;&gt;插件&lt;/h1&gt;
&lt;hr&gt;
&lt;h5 id=&#34;webuploader-ie浏览器兼容问题点击无反应&#34;&gt;Webuploader IE浏览器兼容问题（点击无反应）&lt;/h5&gt;
&lt;p&gt;webuploader 加载后会默认先使用H5，在浏览器不支持H5,再采用flash,方式上传。&lt;br&gt;
所以  初始化webuploader,一定要添加 swf:xxx/Uploader.swf ,保证路径正确&lt;br&gt;
可能是 swf 路径不对，检查 dist 里面的 uploader.swf  文件。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
