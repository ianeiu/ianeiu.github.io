<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>吴炜棉</title>
        <link>https://ianeiu.github.io/</link>
        <description>Recent content on 吴炜棉</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <lastBuildDate>Tue, 27 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://ianeiu.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Java笔记之NIO</title>
        <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/</link>
        <pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/</guid>
        <description>&lt;h2 id=&#34;java-提供了哪些-io-方式-nio-如何实现多路复用&#34;&gt;Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？&lt;/h2&gt;
&lt;p&gt;Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。
首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。 交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时， 在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。
java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。&lt;/p&gt;
&lt;p&gt;很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、 HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。&lt;/p&gt;
&lt;p&gt;第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象， 可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。&lt;/p&gt;
&lt;p&gt;第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。
异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里， 当后台处理完成，操作系统会通知相应线程进行后续工作。&lt;/p&gt;
&lt;p&gt;NIO是一种非阻塞式I/O；采用了双向通道进行数据传输，NIO基于Channel和Buffer(缓冲区)进⾏操作，数据总是从通道读取到缓冲区中，或者从缓冲区
写⼊入到通道中。Selector(选择区 [阻塞] )用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。
利用单线程轮询事件的机制，有效避免大量客户端连接时，频繁线程切换带来的问题。&lt;/p&gt;
&lt;h2 id=&#34;ionio&#34;&gt;IO、NIO&lt;/h2&gt;
&lt;p&gt;IO 概览:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IO 不仅仅是对文件的操作，网络编程中，比如 Socket 通信，都是典型的 IO 操作目标。&lt;/li&gt;
&lt;li&gt;输入流、输出流（InputStream/OutputStream）是用于读取或写入字节的，例如操作图片文件。&lt;/li&gt;
&lt;li&gt;Reader/Writer 用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader/Writer 相当于构建了应用逻辑和原始数据之间的桥梁。&lt;/li&gt;
&lt;li&gt;BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。&lt;/li&gt;
&lt;li&gt;很多 IO 工具类都实现了 Closeable 接口，因为需要进行资源的释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NIO 概览：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的 Buffer 实现。&lt;/li&gt;
&lt;li&gt;Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式IO 操作的一种抽象。&lt;/li&gt;
&lt;li&gt;File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过Socket 获取 Channel，反之亦然。&lt;/li&gt;
&lt;li&gt;Selector，是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多Channel 的高效管理。&lt;/li&gt;
&lt;li&gt;Chartset，提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，Charset.defaultCharset().encode(&amp;ldquo;Hello world!&amp;quot;))进行字符串到 ByteBuffer 的转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IO 适用场景&lt;br&gt;
如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更更合适。使⽤用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作⽐比较来权衡选择。&lt;/p&gt;
&lt;p&gt;NIO 适用场景&lt;br&gt;
如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候用NIO处理数据可能是个很好的选择。(适⽤用于小数据多连接)&lt;/p&gt;
&lt;p&gt;NIO原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由一个专门的线程来处理所有的 IO 事件，并负责分发。&lt;/li&gt;
&lt;li&gt;事件驱动机制：事件到的时候触发，而不是同步的去监视事件。&lt;/li&gt;
&lt;li&gt;线程通讯：线程之间通过 wait，notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java笔记之基础篇</title>
        <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
        <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
        <description>&lt;img src="https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/matt-le-SJSpo9hQf7s-unsplash.jpg" alt="Featured image of post Java笔记之基础篇" /&gt;&lt;p&gt;Java基础笔记整理&lt;/p&gt;
&lt;h2 id=&#34;关键字&#34;&gt;关键字&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用于定义数据类型
&lt;ul&gt;
&lt;li&gt;class interface  【引用数据类型：类、接口、数组】&lt;/li&gt;
&lt;li&gt;boolean(1) char(2) byte(1) short(2) int(4) long(8) float(4) double(8) 【8个内置数据类型】&lt;br&gt;
类型转换：&lt;br&gt;
byte→short→int→→(可能丢失精度)float→→(可能丢失精度)long→→(可能丢失精度)double&lt;br&gt;
char→int&lt;br&gt;
int→long&lt;br&gt;
int→double&lt;br&gt;
float→double&lt;/li&gt;
&lt;li&gt;void&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于定义数据类型值
&lt;ul&gt;
&lt;li&gt;true false null&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于定义流程控制
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if else switch case default【选择】&lt;br&gt;
【switch jdk5前：case byte\short\int\char。jdk5：case：enum。jdk7：case String】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;while do for【循环】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;break continue return【流程跳转】&lt;/p&gt;
&lt;p&gt;直接for循环效率最高，其次是迭代器和 ForEach操作。作为语法糖，ForEach底层是使用迭代器实现，反编译后testForEach方法如下，可以看到，只比迭代器遍历多了生成中间变量这一步，因为性能也略微下降了一些。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void testForEach(List list) {  
    for (Iterator iterator = list.iterator(); iterator.hasNext();) {  
        Object t = iterator.next();  
        Object obj = t;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于定义访问权限修饰符
&lt;ul&gt;
&lt;li&gt;private public protected&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于定义类、函数、变量
&lt;ul&gt;
&lt;li&gt;abstract final static synchronized&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类与类之间的关系
&lt;ul&gt;
&lt;li&gt;extends implements&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建立实例、引用实例、判断实例
&lt;ul&gt;
&lt;li&gt;new this super instanceof&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异常处理
&lt;ul&gt;
&lt;li&gt;try catch throw throws finally&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;包
&lt;ul&gt;
&lt;li&gt;package import&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其它
&lt;ul&gt;
&lt;li&gt;native strictfp transient volatile assert&lt;/li&gt;
&lt;li&gt;保留字 goto const&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标识符&#34;&gt;标识符&lt;/h2&gt;
&lt;p&gt;类、接口、方法、变量的名字&lt;br&gt;
合法字符组成：英文字母、数字、$、_【不能以数字开头】&lt;/p&gt;
&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单行 //&lt;/li&gt;
&lt;li&gt;多行 /**/&lt;/li&gt;
&lt;li&gt;文档 /**  */&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;字面值 &amp;ldquo;hello&amp;rdquo;,10.true&lt;/li&gt;
&lt;li&gt;自定义 final int LINK_CODE = 0;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;final 修饰变量（基本类型值不变，引用类型地址值不变）（只能在构造方法执行之前赋值一次）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类变量（静态变量）&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;实例变量（成员变量）&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;局部变量（本地变量）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;位置（代码）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;类中&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;类中方法外&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;方法定义中、方法声明上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;位置（内存）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;方法区中静态区&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;堆&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;生命周期&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;随类加载而加载&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;随对象&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;随方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;this无法存在静态中；&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;静态方法只能访问静态变量&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;运算符&#34;&gt;运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;% + - * / ++  --
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;= += -= *= /= %=
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;比较运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;== != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;= 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;amp; | ^(异或) ! &amp;amp;&amp;amp; || 【&amp;amp;&amp;amp; || 有短路效果】
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;位运算符&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;
&amp;laquo; &amp;raquo; &amp;raquo;&amp;gt;(无符号右移) &amp;amp; | ^ ~(按位取反)
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三元运算符&lt;br&gt;
&lt;!-- raw HTML omitted --&gt;
max = a &amp;gt; b ? a : b
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码块&#34;&gt;代码块&lt;/h2&gt;
&lt;p&gt;代码块加载顺序： 静态代码块（类初始化）&amp;ndash;&amp;gt; 局部代码块 &amp;ndash;&amp;gt; 构造代码块（对象初始化）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Importtant06Code {
    static { System.out.println(&amp;quot;Importtant06Code静态代码块&amp;quot;);}
	
    public static void main(String[] args) {
        System.out.println(&amp;quot;main&amp;quot;);
        User user = new User();
        User user2 = new User();
    }
}

class User{
    static { System.out.println(&amp;quot;User静态代码块&amp;quot;);}
    {System.out.println(&amp;quot;User局部代码块&amp;quot;);}
    public User() {System.out.println(&amp;quot;User构造代码块&amp;quot;);}
	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Importtant06Code静态代码块
main
User静态代码块
User局部代码块
User构造代码块
User局部代码块
User构造代码块
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;java面向对象三大特性&#34;&gt;Java面向对象三大特性&lt;/h2&gt;
&lt;p&gt;封装、继承、多态&lt;/p&gt;
&lt;h2 id=&#34;类与对象&#34;&gt;类与对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类：一组相关属性和行为的集合（抽象）&lt;/li&gt;
&lt;li&gt;对象：改类事物的具体表现形式（具体存在的个体）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;封装&#34;&gt;封装&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口&lt;br&gt;
好处：隐藏实现细节,提供公共访问方式，复用性，安全性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键字：private、this、static、new&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;userName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;wm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Demo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对象构造过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将User.class文件加载到内存&lt;/li&gt;
&lt;li&gt;栈内存放置user，堆内存放置对象&lt;/li&gt;
&lt;li&gt;给成员变量进行初始化
&lt;ul&gt;
&lt;li&gt;默认初始化 name:null  age:0&lt;/li&gt;
&lt;li&gt;显示初始化 name:wm    age:18&lt;/li&gt;
&lt;li&gt;构造初始化 name:sg    age:25&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将地址值赋给变量user&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;从已有类得到继承信息创建新类的过程&lt;br&gt;
好处：复用、维护、多态前提&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键字：extends、this、super&lt;/p&gt;
&lt;h4 id=&#34;重载与重写&#34;&gt;重载与重写&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;重写（Override） 子类重写父类方法,多态的条件之一&lt;/li&gt;
&lt;li&gt;重载（Overload） 同一个类中不同参数的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;子类初始化之前会先进行父类的初始化&lt;/li&gt;
&lt;li&gt;父类没有无参构造，编译会报错&lt;/li&gt;
&lt;li&gt;子类重写父类方法，方法访问权限不能比之更低&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;多态&#34;&gt;多态&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;允许不同子类型的对象对同一消息作出不同的响应&lt;br&gt;
好处： 维护、扩展&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;父类接口指向子类对象，主要体现在抽象类&lt;/p&gt;
&lt;p&gt;Fu f = new Zi();&lt;br&gt;
成员方法：编译看父类，运行看子类。&lt;br&gt;
静态方法：编译看父类，运行看子类。&lt;br&gt;
成员变量：编译看父类，运行看子类。&lt;br&gt;
构造方法：编译看父类，运行看父子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;learn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d1tod4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Fu&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;new Fu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;show Fu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;function Fu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Zi&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;new Zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;show Zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;method zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;function Zi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Demo04DuoTai&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nd&#34;&gt;@SuppressWarnings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;static-access&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;父类引用指向子类对象&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;父&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;子&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;找不到符号&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		
		&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;找不到符号&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
		
		&lt;span class=&#34;o&#34;&gt;/*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;
		&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Zi&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Fu&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*/&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;java多态的实现原理&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;当JVM执行Java字节码时，类型信息会存储在方法区中，为了优化对象的调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。&lt;/p&gt;
&lt;p&gt;方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。
方法区的内存回收目标是针对常量池的回收及对类型的卸载。&lt;/p&gt;
&lt;p&gt;方法表的构造&lt;/p&gt;
&lt;p&gt;由于java的单继承机制，一个类只能继承一个父类，而所有的类又都继承Object类，方法表中最先存放的是Object的方法，接下来是父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。&lt;/p&gt;
&lt;p&gt;由于这样的特性，使得方法表的偏移量总是固定的，例如，对于任何类来说，其方法表的equals方法的偏移量总是一个定值，所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。&lt;/p&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;p&gt;假设Class A是Class B的子类，并且A改写了B的方法的method()，那么B来说，method方法的指针指向B的method方法入口；对于A来说，A的方法表的method项指向自身的method而非父类的。&lt;/p&gt;
&lt;p&gt;流程：调用方法时，虚拟机通过对象引用得到方法区中类型信息的方法表的指针入口，查询类的方法表 ，根据实例方法的符号引用解析出该方法在方法表的偏移量，子类对象声明为父类类型时，形式上调用的是父类的方法，此时虚拟机会从实际的方法表中找到方法地址，从而定位到实际类的方法。&lt;br&gt;
注：所有引用为父类，但方法区的类型信息中存放的是子类的信息，所以调用的是子类的方法表。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;抽象类与接口&#34;&gt;抽象类与接口&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;抽象类&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;接口&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;特点&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1.抽象类与方法需用abstract修饰&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1.接口用interface修饰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2.抽象类不一定有抽象方法，有则为抽象类&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2.类实现接口用implements&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3.不能直接实例化（通过多态可实例化）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3.不能被实例化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;成员特点-属性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;变量、常量&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;常量（任何成员属性都隐含着 public static final）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;成员特点-构造方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;成员特点-成员方法&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;抽象、非抽象&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;抽象、【JDK8有 default、static方法】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关键字&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不能与private、final、static(无意义)共存&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;java.util.AbstractList&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;java.util.List&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;内部类&#34;&gt;内部类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;成员内部类
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;99&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
       
    &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//30
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//20
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//10
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;局部内部类
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;99&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
       
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//存放于堆内存
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;101&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//随调用产生，随结束消失
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//System.out.println(o.num3);//无法访问，编译报错
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;``&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匿名内部类
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;study&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;PersonDemo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;study&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;PersonDemo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PersonDemo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
            &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;study&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;//dosomething;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;``&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;静态内部类（访问外部数据必须用static修饰）
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;99&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
       
    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//30
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//20
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//10
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;oi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
           
        &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;``&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://images2015.cnblogs.com/blog/679904/201510/679904-20151025210813989-921927916.jpg&#34; alt=&#34;yc&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Throwable
Throwable是 Java 语言中所有错误或异常的超类。
Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。
Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exception
Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RuntimeException
RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。
编译器不会检查RuntimeException异常。如NullPointerException、IndexOutOfBoundsException,ArithmeticException(除数为零时)，也能通过编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非RuntimeException
Exception类本身，以及Exception的子类中除了&amp;quot;运行时异常&amp;quot;之外的其它子类都属于被检查异常。 如IOException、SQLException，Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Error
和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。如StackOverflowError、OutOfMemoryError，和RuntimeException一样， 编译器也不会检查Error,。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hashcode的作用&#34;&gt;hashCode的作用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;hashCode的存在主要是用于查找的快捷性，作用于像散列集合Hashtable，HashMap等确定对象的存储地址的；&lt;/li&gt;
&lt;li&gt;如果两个对象相同，就是适⽤于equals(java.lang.Object)⽅方法，那么这两个对象的hashCode⼀定要相同；&lt;/li&gt;
&lt;li&gt;如果对象的equals⽅方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals⽅方法中使用的一致，否则就会违反上面提到的第2点；&lt;/li&gt;
&lt;li&gt;两个对象的hashCode相同，并不一定表示两个对象就相同（equals不一定为true），只能够说明这两个对象在散列列存储结构中，它们存放在同一个桶里面。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;collection概述&#34;&gt;Collection概述&lt;/h2&gt;
&lt;p&gt;Collection 是对象集合，继承了超级接口Iterable，使用Iterator迭代器实现遍历。 Collection 有两个子接口 List 和 Set。&lt;/p&gt;
&lt;p&gt;List 可以通过下标 (1,2..) 来取得值，值是有序重复，有自己的迭代器ListIterator，可以通过这个迭代器进行逆序的迭代。&lt;/p&gt;
&lt;p&gt;ArrayList、Vector、LinkedList 是List的实现类。&lt;/p&gt;
&lt;p&gt;ArrayList 是线程不安全的，底层采用数组实现（并且该数组的类型是Object类型的），默认长度为10。&lt;br&gt;
扩容的步长是0.5倍原容量，扩容⽅方式是利用数组的复制，因此有一定的开销。&lt;/p&gt;
&lt;p&gt;Vector 是线程安全的，底层采用数组实现。&lt;/p&gt;
&lt;p&gt;LinkedList 是线程不安全的，底层是由（双向循环Deque）链表实现的。&lt;br&gt;
LinkedList 有一个内部类作为存放元素的单元，⾥里里⾯面有三个属性，⽤用来存放元素本身以及前后2个单元的引用，另外LinkedList内部还有一个header属性，用来标识起始位置，第一个单元和最后一个单元都会指向header，因此形成了一个双向循环链表结构。&lt;/p&gt;
&lt;p&gt;Stack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。&lt;br&gt;
Queue接口：提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList（实现双端队列Deque）、PriorityQueue等。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Set 只能通过游标来取值，并且值是不能重复的。Set中的元素类必须有一个有效的equals方法。&lt;/p&gt;
&lt;p&gt;Set子接口有NavigableSet、SortedSet；Set子类有EnumSet、HashSet、LinkedHashSet、TreeSet、AbstractSet等。&lt;/p&gt;
&lt;p&gt;HashSet 底层是哈希表（元素为链表的数组）实现（方法代码使用了HashMap），由hashcode()和equals()方法保证元素唯一。&lt;br&gt;
TreeSet 底层是红黑树（自平衡的二叉树）实现，元素是可排序的。&lt;/p&gt;
&lt;p&gt;LinkedHashSet 底层由链表和哈希表实现，保证元素有序且唯一。&lt;/p&gt;
&lt;p&gt;TreeSet有两种排序实现。自然排序(内比较器)，类实现Comparable；比较器排序，使用匿名内部方式实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//比较器排序
TreeSet&amp;lt;User&amp;gt; userSet = new TreeSet&amp;lt;&amp;gt;(
	new Comparator&amp;lt;User&amp;gt;(){
		public int compare(User user1, User user2){
			if (user1.getAge() &amp;gt; user2.getAge()) return 1;
			else if (user1.getAge() = user2.getAge()) return 0;
			else  return -1;
		}
	}
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用迭代器Iterator遍历集合时修改添加元素会报并发修改异常，而用ListIterator则不会。&lt;/li&gt;
&lt;li&gt;使用size()获取集合长度&lt;/li&gt;
&lt;li&gt;toString()实现：AbstractColletion使用iterator()迭代器方法得到迭代器，之后使用StringBuilder拼接遍历的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;arraylistlinkedlistvector的底层实现和区别&#34;&gt;ArrayList、LinkedList、Vector的底层实现和区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从同步性来看，ArrayList和LinkedList是不同步的，而Vector是的。所以线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList、LinkedList，使我们也达到同步，但效率可能会有所降低。&lt;/li&gt;
&lt;li&gt;从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。如果你要在集合中保存大量的数据，那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。&lt;/li&gt;
&lt;li&gt;ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或者删除元素那么花费的时间会呈线性增长O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置，因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList底层是由双向循环链表实现的，LinkedList在插入、删除集合中任何位置的元素所花费的时间都是一样的O(1)，但它在索引一个元素的时候比较慢，为O(i)，其中i是索引的位置，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;map概述&#34;&gt;Map概述&lt;/h2&gt;
&lt;p&gt;Map 是键值对集合。HashTable和HashMap是Map的实现类。&lt;/p&gt;
&lt;p&gt;HashMap不是线程安全的，键唯一（哈希表实现），可以存储null值。&lt;br&gt;
HashTable是线程安全的，键唯一，不能存储null值。&lt;/p&gt;
&lt;p&gt;LinkedHashMap键是唯一有序的（哈希表和链表实现）&lt;br&gt;
TreeMap键是可排序的（红黑树实现）&lt;/p&gt;
&lt;h2 id=&#34;常用容器初始值大小&#34;&gt;常用容器初始值大小&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;StringBuffer和StringBuilder初始化默认大小为16个字符&lt;/li&gt;
&lt;li&gt;HashMap初始化默认大小16，自增为2n.&lt;/li&gt;
&lt;li&gt;HashTable默认初始值为11，加载因子为0.75，自增为2n+1&lt;/li&gt;
&lt;li&gt;ArrayList初始化默认值为10，自增为1.5n&lt;/li&gt;
&lt;li&gt;Vector初始化默认值为10，自增为2n&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;io流&#34;&gt;IO流&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;字节流
&lt;ul&gt;
&lt;li&gt;输入
&lt;ul&gt;
&lt;li&gt;InputSream
&lt;ul&gt;
&lt;li&gt;FileInputStream&lt;/li&gt;
&lt;li&gt;BufferedInputStream&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;输出
&lt;ul&gt;
&lt;li&gt;OutputStream
&lt;ul&gt;
&lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;li&gt;BufferedOutputStream&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字符流
&lt;ul&gt;
&lt;li&gt;输入
&lt;ul&gt;
&lt;li&gt;Reader
&lt;ul&gt;
&lt;li&gt;InputStreamReader
&lt;ul&gt;
&lt;li&gt;FileReader&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BufferedReader
&lt;ul&gt;
&lt;li&gt;LineNumberReader&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;输出
&lt;ul&gt;
&lt;li&gt;Writer
&lt;ul&gt;
&lt;li&gt;OutputStreamWriter
&lt;ul&gt;
&lt;li&gt;FileWirter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BufferedWriter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;close()与flush()：&lt;br&gt;
close() 关闭流对象，但会先刷新一次流缓冲区，关闭之后不可使用。&lt;br&gt;
flush() 仅仅刷新缓冲区，刷新之后，流对象还可以继续使用。&lt;/p&gt;
&lt;h2 id=&#34;线程状态&#34;&gt;线程状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新建（New）:创建后尚未启动的线程处于这种状态。线程启动start()。&lt;/li&gt;
&lt;li&gt;就绪/运行(Runnable)：Runnable包括了操作系统状态中的 &lt;!-- raw HTML omitted --&gt;就绪&lt;!-- raw HTML omitted --&gt; Ready和 &lt;!-- raw HTML omitted --&gt;运行&lt;!-- raw HTML omitted --&gt; Running，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间。&lt;/li&gt;
&lt;li&gt;无限期等待（Waiting）:处于这种状态的进程不会被分配CPU执行时间，它们要等待被其他线程显示的唤醒。以下方法会让线程陷入无限期的等待状态：
&lt;ul&gt;
&lt;li&gt;没有设置Timeout参数的Object.wait()方法&lt;/li&gt;
&lt;li&gt;没有设置Timeout参数的Thread.join()方法&lt;/li&gt;
&lt;li&gt;LockSupport.park()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;限期等待（Timed Waiting）:处于这种状态的进程不会被分配CPU执行时间，不过无需等待被其他线程显示的唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
&lt;ul&gt;
&lt;li&gt;Thread.sleep()方法&lt;/li&gt;
&lt;li&gt;设置了Timeout参数的Object.wait()方法&lt;/li&gt;
&lt;li&gt;设置了Timeout参数的Thread.join()方法&lt;/li&gt;
&lt;li&gt;LockSupport.parkNanos()方法&lt;/li&gt;
&lt;li&gt;LockSupport.parkUnitil()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;阻塞（Blocked）:进程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获取到一个排它锁，这个事件将在另一个线程放弃这个锁的时候发生；而等待状态则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。&lt;/li&gt;
&lt;li&gt;结束（Terminated）:已终止线程的线程状态，线程已经结束执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的控制&#34;&gt;线程的控制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;获取线程的名称 &lt;code&gt;public final String getName()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置线程的名称 &lt;code&gt;public final void setName(String name)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回当前正在执行的线程对象(名称) &lt;code&gt;public static Thread currentThread()&lt;/code&gt; -&amp;gt; &lt;code&gt;Thread.currentThread().getName()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;获取线程对象的优先级	 &lt;code&gt;public final int getPriority() &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置线程对象的优先级	 &lt;code&gt;public final void setPriority(int newPriority) &lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;线程默认优先级是5。&lt;/li&gt;
&lt;li&gt;线程优先级的范围是：1-10。&lt;/li&gt;
&lt;li&gt;线程优先级高仅仅表示线程获取的 CPU时间片的几率高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将该线程标记为守护线程或用户线程 &lt;code&gt;public final void setDaemon(boolean on)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程休眠	&lt;code&gt;public static void sleep(long millis)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加入线程	&lt;code&gt;public final void join()&lt;/code&gt;:等待该线程终止。&lt;/li&gt;
&lt;li&gt;礼让线程	&lt;code&gt;public static void yield()&lt;/code&gt;:暂停当前正在执行的线程对象，并执行其他线程。&lt;/li&gt;
&lt;li&gt;后台线程&lt;/li&gt;
&lt;li&gt;终止线程(掌握)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public final void stop()&lt;/code&gt;:让线程停止，过时了，但是还可以使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void interrupt()&lt;/code&gt;:中断线程。 把线程的状态终止，并抛出一个InterruptedException。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多线程相关&#34;&gt;多线程相关&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;多线程实现方案：
&lt;ul&gt;
&lt;li&gt;继承Thread类
&lt;ul&gt;
&lt;li&gt;自定义线程类继承Thread类，重写run()&lt;/li&gt;
&lt;li&gt;调用类 创建自定义线程类对象，启动线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现Runnable接口
&lt;ul&gt;
&lt;li&gt;自定义线程类实现Runable接口，重写run()&lt;/li&gt;
&lt;li&gt;调用类 创建自定义线程类对象&lt;/li&gt;
&lt;li&gt;调用类 以自定义线程类对象作为参数构造创建Thread对象，启动线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现Callable接口结合线程池
&lt;ul&gt;
&lt;li&gt;自定义线程类实现Callable接口，重写call方法
&lt;ul&gt;
&lt;li&gt;1
&lt;ul&gt;
&lt;li&gt;调用类 创建ExecutorService线程池对象,调用submit(Callable&lt;!-- raw HTML omitted --&gt; task)&lt;/li&gt;
&lt;li&gt;调用类 创建Future&lt;!-- raw HTML omitted --&gt;对象，接收上一步返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2
&lt;ul&gt;
&lt;li&gt;调用类 创建ExecutorService线程池对象,调用 submit(Runnable task)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pool.shutdown()结束;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程安全问题产生条件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;多线程环境&lt;/li&gt;
&lt;li&gt;有共享数据&lt;/li&gt;
&lt;li&gt;有多条语句操作共享数据&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;同步的方式：
&lt;ul&gt;
&lt;li&gt;同步代码块 &lt;code&gt;synchronized(对象){//doSomething}&lt;/code&gt; 或 同步锁 Lock
&lt;ul&gt;
&lt;li&gt;当线程访问较多时，每个线程都会去判断同步上的锁，非常消耗资源，降低程序运行效率，而且容易产生死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;run()与start()&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;run():封装了被线程执行的代码,直接调用仅仅是普通方法的调用&lt;/li&gt;
&lt;li&gt;start():启动线程，并由JVM自动调用run()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;sleep()与wait()&lt;br&gt;
sleep()是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时会自动恢复（线程回到就绪（ready）状态），调用sleep 不会释放对象锁。&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;
wait()是Object 类的方法，对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;死锁：两个或两个异常的线程争夺资源过程中，发生的一种互相等待的现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁的等级：方法锁、对象锁、类锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现Runnable接口相比继承Thread类有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以避免由于Java的单继承特性而带来的局限&lt;/li&gt;
&lt;li&gt;增强程序的健壮性，代码能够被多个程序共享，代码与数据是独立的&lt;/li&gt;
&lt;li&gt;适合多个相同程序代码的线程区处理同一资源的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;线程安全需要保证几个基本特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。&lt;/li&gt;
&lt;li&gt;可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。&lt;/li&gt;
&lt;li&gt;有序性，是保证线程内串行语义，避免指令重排等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;socket编程&#34;&gt;Socket编程&lt;/h2&gt;
&lt;p&gt;网络编程三要素： IP、端口、协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP
&lt;ul&gt;
&lt;li&gt;发送数据
&lt;ul&gt;
&lt;li&gt;创建发送端口DatagramSocket对象&lt;/li&gt;
&lt;li&gt;创建数据，并打开数据包&lt;/li&gt;
&lt;li&gt;调用DatagramSocket对象发送方法，发送数据包&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接收数据
&lt;ul&gt;
&lt;li&gt;创建DatagramSocket对象&lt;/li&gt;
&lt;li&gt;创建一个数据包（接收容器）&lt;/li&gt;
&lt;li&gt;调用容器接收数据&lt;/li&gt;
&lt;li&gt;解析数据包&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TCP
&lt;ul&gt;
&lt;li&gt;发送数据
&lt;ul&gt;
&lt;li&gt;创建发送端的Socket对象&lt;/li&gt;
&lt;li&gt;获取输出流，写数据&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接收数据
&lt;ul&gt;
&lt;li&gt;创建接收端的Socket&lt;/li&gt;
&lt;li&gt;监听客户端连接&lt;/li&gt;
&lt;li&gt;获取输入流&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;反射机制&#34;&gt;反射机制&lt;/h2&gt;
&lt;p&gt;反射技术：动态加载一个指定的类，并获取该类中所有的内容。并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;好处：大大增强了程序的扩展性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反射的基本步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获得Class对象，就是获得指定的名称的字节码文件对象&lt;/li&gt;
&lt;li&gt;实例化对象，获得类的属性、方法或者构造函数&lt;/li&gt;
&lt;li&gt;访问属性、调用方法、调用构造函数创建对象&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Java笔记之web篇</title>
        <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bweb%E7%AF%87/</link>
        <pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8Bweb%E7%AF%87/</guid>
        <description>&lt;p&gt;JavaWeb笔记整理&lt;/p&gt;
&lt;h2 id=&#34;xml&#34;&gt;XML&lt;/h2&gt;
&lt;p&gt;XML(EXtensible Markup Language):可扩展标记型语言，主要是为了存储数据（程序配置文件）、数据交换&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;XML两种文档约束类型： &lt;code&gt;dtd&lt;/code&gt; （file_name.dtd）和&lt;code&gt;schema&lt;/code&gt;（file_name.xsd 可被XML解析器解析）&lt;/p&gt;
&lt;p&gt;XML存储结构化信息，使用&lt;code&gt;DOM&lt;/code&gt;或&lt;code&gt;SAX&lt;/code&gt;（边读边解析）方式解析&lt;br&gt;
Properties存储平面信息，使用Properties类解析&lt;/p&gt;
&lt;p&gt;常见的XML解析器实现：JDOM、DOM4J（首选）、SAX&lt;/p&gt;
&lt;p&gt;XPath:XML路径语言，用来确定XML文档中某部分位置&lt;/p&gt;
&lt;h2 id=&#34;web服务器&#34;&gt;Web服务器&lt;/h2&gt;
&lt;p&gt;Tomcat（Apache）、JBOSS（Redhat）、WebLogic（Oracle）、WebSphere（IBM）等等&lt;/p&gt;
&lt;h2 id=&#34;javaweb三大组件&#34;&gt;JavaWeb三大组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Servlet&lt;/li&gt;
&lt;li&gt;Filter&lt;/li&gt;
&lt;li&gt;Listener&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;servlet&#34;&gt;Servlet&lt;/h2&gt;
&lt;p&gt;Servlet是多线程、单实例。&lt;br&gt;
继承关系：MyServlet &amp;ndash;extends&amp;ndash;&amp;gt; HttpServlet &amp;ndash;extends&amp;ndash;&amp;gt; QenericServlet  &amp;ndash;implements&amp;ndash;&amp;gt; Servlet、ServletConfig&lt;/p&gt;
&lt;h4 id=&#34;servlet生命周期&#34;&gt;Servlet生命周期&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;初始化：服务器在Servlet第一次被访问时或在服务器启动时创建Servlet。创建后，调用init()方法；&lt;/li&gt;
&lt;li&gt;提供服务：当服务器每次接收到请求时，会调用service()方法处理请求；&lt;/li&gt;
&lt;li&gt;销毁：当服务器关闭时，服务器会去销毁Servlet。销毁前会调用destroy()方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;在webxml中配置&#34;&gt;在web.xml中配置&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;...
&amp;lt;servlet&amp;gt;
	&amp;lt;servlet-name&amp;gt;myServlet&amp;lt;/servlet-name&amp;gt;
	&amp;lt;servlet-class&amp;gt;com.ianeiu.web.MyServlet&amp;lt;/servlet-class&amp;gt;
	&amp;lt;!-- 通过ServletConfig获取 --&amp;gt;
	&amp;lt;init-param&amp;gt;
		&amp;lt;param-name&amp;gt;key&amp;lt;/param-name&amp;gt;
		&amp;lt;param-value&amp;gt;value&amp;lt;/param-value&amp;gt;
	&amp;lt;/init-param&amp;gt;
	&amp;lt;!-- 值越小，优先级越大 --&amp;gt;
	&amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
	&amp;lt;servlet-name&amp;gt;myServlet&amp;lt;/servlet-name&amp;gt;
	&amp;lt;url-pattren&amp;gt;/my/*&amp;lt;/url-pattren&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问路径可以使用通配符 &lt;!-- raw HTML omitted --&gt;* /* /myName/* *.do&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;httpservlet&#34;&gt;HttpServlet&lt;/h4&gt;
&lt;p&gt;实现了service(..,..),重写service(HttpServletRequest ..,HttpServletResponse &amp;hellip;),子类只需调用doGet() doPost()。&lt;/p&gt;
&lt;h2 id=&#34;请求request&#34;&gt;请求request&lt;/h2&gt;
&lt;p&gt;URL相关：&lt;br&gt;
&lt;code&gt;http://127.0.0.1:8080/myproject/myServlet?name=admin  &lt;/code&gt;&lt;br&gt;
.getRequestURL()+&amp;quot;?&amp;quot;+ .getQueryString&lt;br&gt;
或者&lt;br&gt;
.getScheme() +&amp;quot;://&amp;quot;+ .getServerName() +&amp;quot;:&amp;quot;+.getServerPort() +&amp;quot;/&amp;quot;+ .getContextPath +&amp;quot;/&amp;quot;+ .getServerPath +&amp;quot;?&amp;quot;+ .getQueryString&lt;br&gt;
/myproject/myServlet 可用 .getRequestURI() 获取&lt;/p&gt;
&lt;h4 id=&#34;get和post&#34;&gt;get和post&lt;/h4&gt;
&lt;p&gt;get：没有请求体，参数在url中显示，长度理论限制1K之内&lt;br&gt;
post: 参数在请求体中，长度无限制&lt;/p&gt;
&lt;h4 id=&#34;请求转发和请求包含&#34;&gt;请求转发和请求包含&lt;/h4&gt;
&lt;p&gt;都是一个请求跨多个Servlet（可以共享request的域属性）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class AServlet extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		RequestDispacter rd = request.getRequestDispacter(&amp;quot;/BServlet&amp;quot;);
		rd.forward(request,response);//A不能输响应体，可设置响应头，最后由B处理
		rd.include(request,response);//无限制，共同处理请求
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;响应response&#34;&gt;响应response&lt;/h2&gt;
&lt;p&gt;可设置响应信息、发送状态码、设置响应正文、重定向（response.sendRedirect(&amp;quot;/myProject/BServlet&amp;quot;)）&lt;/p&gt;
&lt;h4 id=&#34;响应编码&#34;&gt;响应编码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;response.setCharacterEncoding(&amp;ldquo;utf-8&amp;rdquo;); response.getWriter(&amp;quot;..&amp;quot;);&lt;/li&gt;
&lt;li&gt;response.setHeader(&amp;ldquo;content-type&amp;rdquo;,&amp;ldquo;text/html;charset=utf-8&amp;rdquo;);&lt;/li&gt;
&lt;li&gt;response.setContentType(&amp;ldquo;text/html;charset=utf-8&amp;rdquo;);&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;请求转发和重定向302&#34;&gt;请求转发和重定向（302）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;请求转发是一个请求，但是重定向是两个请求。&lt;/li&gt;
&lt;li&gt;请求转发只能是一种请求方式，要么是Get要么是Post ,但是重定向的第二个请求一定是Get。&lt;/li&gt;
&lt;li&gt;请求转发的地址栏并不会发生变化(服务器请求资源)，但是重定向的会变化，因为它是两个请求(浏览器重新请求地址)。&lt;/li&gt;
&lt;li&gt;请求转发只能在本应用下的资源，但是重定向却可以跨应用，比如重定向到百度的主页。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;javaweb四大域对象&#34;&gt;JavaWeb四大域对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PageContext - page    （jsp）&lt;/li&gt;
&lt;li&gt;ServletRequest - request     （servlet、jsp）&lt;/li&gt;
&lt;li&gt;HttpSession - session     （servlet、jsp）&lt;/li&gt;
&lt;li&gt;ServletContext - application     （servlet、jsp）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;servletcontext&#34;&gt;ServletContext&lt;/h2&gt;
&lt;p&gt;ServletContext是Servlet域三大对象之一。&lt;br&gt;
在服务器启动时创建，关闭时销毁，单实例。&lt;br&gt;
用来存取数据、读取web.xml中初始化参数、读取应用资源（文件名、输入流、文件路径集合）&lt;/p&gt;
&lt;h3 id=&#34;响应头&#34;&gt;响应头&lt;/h3&gt;
&lt;p&gt;防盗链：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Referer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;禁用浏览器缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Expies:-1&lt;/li&gt;
&lt;li&gt;Cache-Control:no-cache&lt;/li&gt;
&lt;li&gt;Pragma:no-cache&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三秒后跳转至百度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;Refresh&amp;quot; content=&amp;quot;3;url=http://www.baidu.com&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jsp九大内置对象&#34;&gt;JSP九大内置对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;request - HttpServletRequest&lt;/li&gt;
&lt;li&gt;response - HttpServletResponse&lt;/li&gt;
&lt;li&gt;session - HttpSession&lt;/li&gt;
&lt;li&gt;application - ServletContext&lt;/li&gt;
&lt;li&gt;config - ServletConfig&lt;/li&gt;
&lt;li&gt;exception - 只有在错误页面才可使用&lt;/li&gt;
&lt;li&gt;page - 作用本JSP页面中&lt;/li&gt;
&lt;li&gt;out - JSPWriter&lt;/li&gt;
&lt;li&gt;pageContext - 页面上下文对象（作用域最小）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jsp中的java脚本&#34;&gt;JSP中的Java脚本&amp;lt;%%&amp;gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;脚本
&lt;ul&gt;
&lt;li&gt;&amp;lt;% .. %&amp;gt; 脚本片段&lt;/li&gt;
&lt;li&gt;&amp;lt;%= ..%&amp;gt; 表达式&lt;/li&gt;
&lt;li&gt;&amp;lt;%! ..%&amp;gt; 声明，定义成员&lt;/li&gt;
&lt;li&gt;示例：&lt;code&gt;&amp;lt;% int a=10; %&amp;gt; &amp;lt;%= a %&amp;gt; &amp;lt;%! private String hello=&amp;quot;hello&amp;quot;;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释
&lt;ul&gt;
&lt;li&gt;&amp;lt;%&amp;ndash; ..  &amp;ndash;%&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令
&lt;ul&gt;
&lt;li&gt;&amp;lt;%@ .. %&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jsp原理&#34;&gt;JSP原理&lt;/h2&gt;
&lt;p&gt;客户端 访问 index.jsp,服务器将jsp文件编译成java文件，JVM将java文件编译成class文件。&lt;br&gt;
服务器初始化jsp实例，创建该类对象，调用service()。&lt;br&gt;
客户端再次访问则直接调用service()。&lt;/p&gt;
&lt;h2 id=&#34;jsp三大指令&#34;&gt;JSP三大指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;page&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;错误页面配置 &lt;code&gt;&amp;lt;%@ page language=&amp;quot;java&amp;quot; contentType=&amp;quot;text/html; charset=UTF-8&amp;quot;  pageEncoding=&amp;quot;UTF-8&amp;quot; isErrorPage=&amp;quot;true&amp;quot;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;脚本获取错误 &lt;code&gt;&amp;lt;%= exception.getMessage()%&amp;gt;&lt;/code&gt; [exception为jsp内置对象，error页面独有]&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;include&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;静态包含&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;taglib&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;%@ taglib uri=&amp;quot;&amp;quot; prefix=&amp;quot;c&amp;quot;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在webxml中配置错误页面&#34;&gt;在web.xml中配置错误页面&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 默认的错误处理页面 --&amp;gt;  
&amp;lt;error-page&amp;gt;  
	&amp;lt;error-code&amp;gt;403&amp;lt;/error-code&amp;gt;  
	&amp;lt;location&amp;gt;/403.html&amp;lt;/location&amp;gt;  
&amp;lt;/error-page&amp;gt;  
&amp;lt;error-page&amp;gt;  
	&amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;  
	&amp;lt;location&amp;gt;/404.html&amp;lt;/location&amp;gt;  
&amp;lt;/error-page&amp;gt;  
&amp;lt;!-- 仅仅在调试的时候注视掉,在正式部署的时候不能注释 --&amp;gt;  
&amp;lt;!-- 这样配置也是可以的，表示发生500错误的时候，转到500.jsp页面处理。 --&amp;gt;  
&amp;lt;error-page&amp;gt;   
	&amp;lt;error-code&amp;gt;500&amp;lt;/error-code&amp;gt;   
	&amp;lt;location&amp;gt;/500.html&amp;lt;/location&amp;gt;   
&amp;lt;/error-page&amp;gt;
&amp;lt;!-- 这样的配置表示如果jsp页面或者servlet发生java.lang.Exception类型（当然包含子类）的异常就会转到500.jsp页面处理。 --&amp;gt;  
&amp;lt;error-page&amp;gt;   
	&amp;lt;exception-type&amp;gt;java.lang.Exception&amp;lt;/exception-type&amp;gt;   
	&amp;lt;location&amp;gt;/500.jsp&amp;lt;/location&amp;gt;   
&amp;lt;/error-page&amp;gt;   
  
&amp;lt;error-page&amp;gt;   
	&amp;lt;exception-type&amp;gt;java.lang.Throwable&amp;lt;/exception-type&amp;gt;   
	&amp;lt;location&amp;gt;/500.jsp&amp;lt;/location&amp;gt;   
&amp;lt;/error-page&amp;gt;  
&amp;lt;!--   
当error-code和exception-type都配置时，exception-type配置的页面优先级高  
及出现500错误，发生异常Exception时会跳转到500.jsp  
 --&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;在webxml中配置jstl&#34;&gt;在web.xml中配置jstl&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;...  
&amp;lt;jsp-config&amp;gt;  
   &amp;lt;taglib&amp;gt;  
	   &amp;lt;taglib-uri&amp;gt;myjstl&amp;lt;/taglib-uri&amp;gt;  
	   &amp;lt;taglib-location&amp;gt;/WEB-INF/tld/c.tld&amp;lt;/taglib-location&amp;gt;  
   &amp;lt;/taglib&amp;gt;  
&amp;lt;/jsp-config&amp;gt;  
...  
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;jsp基本动作&#34;&gt;JSP基本动作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;include&lt;/li&gt;
&lt;li&gt;useBean&lt;/li&gt;
&lt;li&gt;setProperty&lt;/li&gt;
&lt;li&gt;getProperty&lt;/li&gt;
&lt;li&gt;forward&lt;/li&gt;
&lt;li&gt;plugin&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态包含和静态包含&#34;&gt;动态包含和静态包含&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;动态包含&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;jsp:include page=&amp;quot;navigation.jsp&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求处理阶段执行&lt;/li&gt;
&lt;li&gt;会检查所含文件变化，用于动态页面&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;静态包含&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;%@ include file=&amp;quot;resource.html&amp;quot;%&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;翻译阶段执行（合并再编译）&lt;/li&gt;
&lt;li&gt;不检查所含文件变化，用于静态页面&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cookie&#34;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;Cookie是Http协议的规范之一，是服务端和客户端之间传输的小数据。
特点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大小4KB（实际上不止）&lt;/li&gt;
&lt;li&gt;服务器最多在客户端浏览器上保存20个&lt;/li&gt;
&lt;li&gt;浏览器最多保存300个&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;httpsession&#34;&gt;HttpSession&lt;/h2&gt;
&lt;p&gt;用来会话跟踪的类。session是服务端对象，保存在服务端。&lt;br&gt;
HttpSession底层依赖Cookie或是URL重写。&lt;/p&gt;
&lt;p&gt;会话的实现依赖于容器，大多数容器采用基于Cookie的实现机制，使用名字为JSESSIONID的cookie作为session的唯一标识。&lt;/p&gt;
&lt;h4 id=&#34;url重写&#34;&gt;URL重写&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href =&amp;quot;/myproject/myjsp.jsp;jsessionid=&amp;lt;%=session.getId()%&amp;gt;&amp;quot;&amp;gt;跳转&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href =&amp;quot;&amp;lt;response.encodeURL(&#39;/myproject/myjsp.jsp&#39;)&amp;gt;&amp;quot;&amp;gt;跳转&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;el表达式&#34;&gt;EL表达式&lt;/h2&gt;
&lt;p&gt;EL表达式主要是用来替代JSP页面中的脚本表达式，获取JavaBean、Map、List、数组及域内置对象属性。也可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;${标识符}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取数据&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;List/数组 &lt;code&gt;${userList[0]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Bean &lt;code&gt;${user.userName}&lt;/code&gt;或&lt;code&gt;${user[&#39;userName&#39;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Map &lt;code&gt;${paramMap.key}&lt;/code&gt;或&lt;code&gt;${paramMap[&#39;key&#39;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内置对象 &lt;code&gt;${sessionScope.userName}&lt;/code&gt;、&lt;code&gt;${initParam[&#39;maxNum&#39;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果Map的键或Bean的属性名中包含&lt;code&gt;_&lt;/code&gt;或&lt;code&gt;-&lt;/code&gt;时，只有${initParam[&amp;lsquo;max_num&amp;rsquo;]}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;运算&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${1+2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${3&amp;gt;5}&lt;/code&gt;或&lt;code&gt;${3 gt 5}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${isSuccess &amp;amp;&amp;amp; length&amp;gt;0}&lt;/code&gt; 或&lt;code&gt;${isSuccess and length&amp;gt;0}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${!isSuccess}&lt;/code&gt; 或&lt;code&gt;${not isSuccess}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;empty判断字符串、数组、集合的长度是否为0(可与not或!连用)	&lt;code&gt;${empty &amp;quot;&amp;quot;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;el-11个内置对象&#34;&gt;EL 11个内置对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pageScope：获取pageContext域属性，相当于pageContext.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;requestScope：获取request域属性，相当于request.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;sessionScope：获取session域属性，相当于session.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;applicationScope：获取application域属性，相当于application.getAttribute(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;param：对应参数，它是一个Map，其中key是参数，value是参数值，适用于单值的参数，相当于request.getParameter(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;paramValues：对应参数，她是一个Map，其中key是参数，value是多个参数值，适用于多值的参数，相当于request.getParameterValues(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;header：对应请求头，它是一个Map，其中key表示头名称，value是单个头值，适用于单值的请求头，相当于request.getHeader(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;headerValues：对应请求头，它是一个Map，其中key表示头名称，value是多个头值，适用于多值的请求头，相当于request.getHeaders(&amp;ldquo;xxx&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;initParam：获取web.xml中&lt;!-- raw HTML omitted --&gt;内的参数，${ initParam.xxx}，xxx就是&lt;!-- raw HTML omitted --&gt;标签内的值，进而得到&lt;!-- raw HTML omitted --&gt;中的值&lt;/li&gt;
&lt;li&gt;cookie：用于获取cookie，Map&amp;lt;String,Cookie&amp;gt;，其中key是cookie的name，value是cookie对象，例如${cookie.JSESSIONID.value }就是获取sessionId&lt;/li&gt;
&lt;li&gt;pageContext：可以获取JSP九大内置对象，相当于使用该对象调用getxxx()方法，例如pageContext.getRequest()可以写为${pageContext.request)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jstl&#34;&gt;JSTL&lt;/h2&gt;
&lt;p&gt;JSTL是一个不断完善的开放源代码的JSP标签库，依赖于EL，使用需要导入jstl.jar。&lt;/p&gt;
&lt;p&gt;JSTL标签库可分为四种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;core&lt;/li&gt;
&lt;li&gt;fmt&lt;/li&gt;
&lt;li&gt;sql&lt;/li&gt;
&lt;li&gt;xml&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中sql标签库和xml标签库已过时。使用标签的JSP页面中使用taglib指令导入标签库，如下：&lt;br&gt;
&lt;code&gt;&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot;uri=&amp;quot;http://java.sun.com/jstl/core&amp;quot; %&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prefix=&amp;quot;c&amp;quot;&lt;/code&gt;：指定标签库的前缀，这个前缀可以随便给值，但大家都会在使用core标签库时指定前缀为c；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uri=&amp;quot;http://java.sun.com/jstl/core&amp;quot;&lt;/code&gt;：指定标签库的uri，它不一定是真实存在的网址，但它可以让JSP找到标签库的描述文件；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;core标签库常用标签&#34;&gt;core标签库常用标签&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;out&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:out value=&amp;quot;aaa&amp;quot;/&amp;gt;&lt;/code&gt; 输出aaa字符串常量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:out value=&amp;quot;${aaa}&amp;quot;/&amp;gt;&lt;/code&gt; 	与${aaa}相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:out value=&amp;quot;${aaa}&amp;quot; default=&amp;quot;xxx&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:set var=&amp;quot;a&amp;quot; value=&amp;quot;hello&amp;quot;/&amp;gt;&lt;/code&gt; 在pageContext中添加name为a，value为hello的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:set var=&amp;quot;a&amp;quot; value=&amp;quot;hello&amp;quot; scope=&amp;quot;session&amp;quot;/&amp;gt;&lt;/code&gt; 在session中添加name为a，value为hello的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;remove&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; &amp;lt;c: remove var=&amp;quot;a&amp;quot;/&amp;gt;&lt;/code&gt; 删除所有域中name为a的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:remove var=&amp;quot;a&amp;quot; scope=&amp;quot;page&amp;quot;/&amp;gt;&lt;/code&gt; 删除pageContext中name为a的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;url&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/&amp;quot;/&amp;gt;&lt;/code&gt; 输出上下文路径：/项目名/&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/&amp;quot; var=&amp;quot;a&amp;quot; scope=&amp;quot;request&amp;quot;/&amp;gt;&lt;/code&gt; 把本该输出的结果赋给变量a。范围为request&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/AServlet&amp;quot;/&amp;gt;&lt;/code&gt;   输出：/项目名/AServlet&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:url value=&amp;quot;/AServlet&amp;quot;&amp;gt; &amp;lt;c:param name=&amp;quot;username&amp;quot; value=&amp;quot;abc&amp;quot;/&amp;gt; &amp;lt;c:param name=&amp;quot;password&amp;quot; value=&amp;quot;123&amp;quot;/&amp;gt; &lt;/code&gt; 输出：/项目名/AServlet?username=abc&amp;amp;password=123。如果参数中包含中文，那么会自动使用URL编码！&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:if test=&amp;quot;条件&amp;quot;&amp;gt;满足条件执行的JSP代码&amp;lt;/c:if&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;choose&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:choose&amp;gt; &amp;lt;c:when test=&amp;quot;条件&amp;quot;&amp;gt;处理&amp;lt;/c:when&amp;gt; &amp;lt;c:when test=&amp;quot;条件&amp;quot;&amp;gt;处理&amp;lt;/c:when&amp;gt; &amp;lt;c:otherwise&amp;gt;处理&amp;lt;/c:otherwise&amp;gt; &amp;lt;/c:choose&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;forEach&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:forEach var=&amp;quot;名字(i)&amp;quot; begin=&amp;quot;开始数字(1)&amp;quot; end=&amp;quot;结束数字(5)&amp;quot;&amp;gt; ${i} &amp;lt;/c:forEach&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:forEach var=&amp;quot;item&amp;quot; items=&amp;quot;数组/集合&amp;quot;&amp;gt; ${item} &amp;lt;/c:forEach&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;:forTokens&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;c:forTokens items=&amp;quot;google,runoob,taobao&amp;quot; delims=&amp;quot;,&amp;quot; var=&amp;quot;name&amp;quot;&amp;gt; &amp;lt;c:out value=&amp;quot;${name}&amp;quot;/&amp;gt;&amp;lt;p&amp;gt; &amp;lt;/c:forTokens&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;fmt标签库&#34;&gt;fmt标签库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;fmt:formatNumber value=”被格式化的数据”[type=”number|currency|percent”]

                                               [pattern=”pattern”]

                                               [currencyCode=”code”]

                                               [currencySymbol=”symbol”]

                                               [groupingUsed=”true|false”]

                                               [maxIntergerDigits=”maxDigits”]

                                               [minIntergerDigits=”minDigits”]

                                               [maxFractionDigits=”maxDigits”]

                                               [minFractionDigits=”minDigits”]

                                               [var=”name”]

                                               [scope=page|request|session|application]

/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;详见 &lt;!-- raw HTML omitted --&gt;fmt&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;jstl自定义标签&#34;&gt;JSTL自定义标签&lt;/h2&gt;
&lt;p&gt;JSP中使用自定义标签移除只需要完成以下两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写一个实现Tag接口的java类（标签处理类）；&lt;/li&gt;
&lt;li&gt;编写标签库描述符（tld）文件，在tld文件中对标签处理类进行描述。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;详见 &lt;!-- raw HTML omitted --&gt;JSTL自定义标签&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;jdbc&#34;&gt;JDBC&lt;/h2&gt;
&lt;p&gt;JDBC核心类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DriverManager&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;注册驱动&lt;/li&gt;
&lt;li&gt;获取Connection&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Connection&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;与数据库通讯&lt;/li&gt;
&lt;li&gt;获取Statement&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Statement&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;向数据库发送SQL语句&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;ResultSet&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;结果集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JDBC编写顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册驱动层序&lt;/li&gt;
&lt;li&gt;获取数据库连接&lt;/li&gt;
&lt;li&gt;创建Statement/PreparedStatement&lt;/li&gt;
&lt;li&gt;发送执行sql语句&lt;/li&gt;
&lt;li&gt;处理结果集（如果有）&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;statement&#34;&gt;Statement&lt;/h4&gt;
&lt;p&gt;con.createStatement()（结果集不滚动、不敏感、不可更新）&lt;br&gt;
con.createStatement(int,int)&lt;/p&gt;
&lt;h2 id=&#34;jdbc之statementpreparedstatementcallablestatement&#34;&gt;JDBC之Statement,PreparedStatement,CallableStatement&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Statement、PreparedStatement和CallableStatement都是接口(interface)。&lt;/li&gt;
&lt;li&gt;Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。&lt;/li&gt;
&lt;li&gt;Statement接口提供了执行语句和获取结果的基本方法；&lt;br&gt;
PreparedStatement接口添加了处理 IN 参数的方法；&lt;br&gt;
CallableStatement接口添加了处理 OUT 参数的方法。&lt;/li&gt;
&lt;li&gt;特性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Statement
&lt;ul&gt;
&lt;li&gt;普通的不带参的查询SQL；&lt;/li&gt;
&lt;li&gt;支持批量更新,批量删除;&lt;/li&gt;
&lt;li&gt;Statement每次执行sql语句，数据库都要执行sql语句的编译;用于仅执行一次查询并返回结果的情形时，效率高于PreparedStatement。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PreparedStatement
&lt;ul&gt;
&lt;li&gt;可变参数的SQL,编译一次,执行多次,效率高;安全性好，有效防止Sql注入等问题&lt;/li&gt;
&lt;li&gt;支持批量更新,批量删除;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CallableStatement
&lt;ul&gt;
&lt;li&gt;继承自PreparedStatement,支持带参数的SQL操作;&lt;/li&gt;
&lt;li&gt;支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用PreparedStatement有几个好处&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。&lt;/li&gt;
&lt;li&gt;安全性好，有效防止Sql注入等问题。&lt;/li&gt;
&lt;li&gt;对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；&lt;/li&gt;
&lt;li&gt;代码的可读性和可维护性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;execute&#34;&gt;execute&amp;hellip;&lt;/h4&gt;
&lt;p&gt;executeQuery：返回结果集(ResultSet)。&lt;br&gt;
executeUpdate: 执行给定SQL语句,该语句可能为 INSERT、UPDATE 或 DELETE 语句，或者不返回任何内容的SQL语句（如 SQL DDL 语句）。&lt;br&gt;
execute: 可用于执行任何SQL语句，返回一个boolean值，表明执行该SQL语句是否返回了ResultSet。如果执行后第一个结果是ResultSet，则返回true，否则返回false。&lt;/p&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;事务的四大特性及隔离级别&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据库连接池&#34;&gt;数据库连接池&lt;/h2&gt;
&lt;p&gt;DBCP（hibernate3不再支持）&lt;/p&gt;
&lt;p&gt;C3P0&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java笔记之名词简介</title>
        <link>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E7%AE%80%E4%BB%8B/</link>
        <pubDate>Sat, 29 Sep 2018 00:00:00 +0000</pubDate>
        
        <guid>https://ianeiu.github.io/p/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E7%AE%80%E4%BB%8B/</guid>
        <description>&lt;h2 id=&#34;web容器&#34;&gt;web容器&lt;/h2&gt;
&lt;p&gt;给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。&lt;/p&gt;
&lt;h2 id=&#34;ejb容器&#34;&gt;EJB容器&lt;/h2&gt;
&lt;p&gt;Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jdbc&#34;&gt;JDBC&lt;/h2&gt;
&lt;p&gt;用来访问数据库的API（规范）&lt;/p&gt;
&lt;h2 id=&#34;jndijava-naming--directory-interface&#34;&gt;JNDI：（Java Naming &amp;amp; Directory Interface）&lt;/h2&gt;
&lt;p&gt;JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。&lt;/p&gt;
&lt;h2 id=&#34;jmsjava-message-service&#34;&gt;JMS：（Java Message Service）&lt;/h2&gt;
&lt;p&gt;JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。&lt;/p&gt;
&lt;h2 id=&#34;jtajava-transaction-api&#34;&gt;JTA：（Java Transaction API）&lt;/h2&gt;
&lt;p&gt;JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。&lt;/p&gt;
&lt;h2 id=&#34;jafjava-action-framework&#34;&gt;JAF：（Java Action FrameWork）&lt;/h2&gt;
&lt;p&gt;JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。&lt;/p&gt;
&lt;h2 id=&#34;rmiiiopremote-method-invocation-internet对象请求中介协议&#34;&gt;RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）&lt;/h2&gt;
&lt;p&gt;他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。&lt;/p&gt;
&lt;h2 id=&#34;jsp&#34;&gt;JSP&lt;/h2&gt;
&lt;p&gt;Jsp页面由HTML和前去其中的Java代码组成，用来实现动态视图&lt;/p&gt;
&lt;h2 id=&#34;javamail&#34;&gt;JavaMail&lt;/h2&gt;
&lt;p&gt;JavaMail利用JAF来初拉力MIME编码的邮件附件&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;mvc&#34;&gt;MVC&lt;/h2&gt;
&lt;p&gt;标准主流现在的编程方式都是采用MVC综合设计模式，MVC本身不属于设计模式的一种，它描述的是一种结构，最终目的达到解耦（更改某一层代码不会影响我其他层代码）。&lt;br&gt;
视图层如jsp调用控制层，控制层action调用业务层service，业务层调用数据dao访问层。&lt;/p&gt;
&lt;h2 id=&#34;dao层&#34;&gt;DAO层&lt;/h2&gt;
&lt;p&gt;DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，DAO层的设计首先是设计DAO的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。&lt;/p&gt;
&lt;h2 id=&#34;service层&#34;&gt;Service层&lt;/h2&gt;
&lt;p&gt;Service层主要负责业务模块的逻辑应用设计。同样是首先设计接口，再设计其实现的类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。&lt;/p&gt;
&lt;h2 id=&#34;controller层&#34;&gt;Controller层&lt;/h2&gt;
&lt;p&gt;Controller层负责具体的业务模块流程的控制，在此层里面要调用Serice层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;vo&#34;&gt;VO&lt;/h2&gt;
&lt;p&gt;即value object值对象。主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象。然后用一个VO对象在控制层与视图层进行传输交换。&lt;/p&gt;
&lt;h2 id=&#34;dto&#34;&gt;DTO&lt;/h2&gt;
&lt;p&gt;Data Transfer Object数据传输对象，经过处理后的PO，可能增加或者减少PO的属性，主要用于远程调用等需要大量传输对象的地方。&lt;/p&gt;
&lt;h2 id=&#34;pojo&#34;&gt;POJO&lt;/h2&gt;
&lt;p&gt;POJO（plain ordinary java object）即简单java对象，是一种概念或者接口，身份及作用随环境变化而变化。
它不包含业务逻辑或持久逻辑等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;springmvc&#34;&gt;SpringMVC&lt;/h2&gt;
&lt;p&gt;Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。&lt;/p&gt;
&lt;h2 id=&#34;ioc容器&#34;&gt;IOC容器&lt;/h2&gt;
&lt;p&gt;IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。在Spring中BeanFactory是IOC容器的实际代表者。&lt;/p&gt;
&lt;h2 id=&#34;aop-面向切面&#34;&gt;AOP (面向切面)&lt;/h2&gt;
&lt;p&gt;简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系&lt;/p&gt;
&lt;h2 id=&#34;mybatis&#34;&gt;Mybatis&lt;/h2&gt;
&lt;p&gt;MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。&lt;/p&gt;
&lt;h2 id=&#34;dubbo&#34;&gt;Dubbo&lt;/h2&gt;
&lt;p&gt;Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC（远程过程调用协议）远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。&lt;/p&gt;
&lt;h2 id=&#34;maven&#34;&gt;Maven&lt;/h2&gt;
&lt;p&gt;项目管理和构建自动化工具&lt;/p&gt;
&lt;h2 id=&#34;rabbitmq&#34;&gt;RabbitMQ&lt;/h2&gt;
&lt;p&gt;消息队列一般是在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。&lt;/p&gt;
&lt;h2 id=&#34;log4jlog4j2logback&#34;&gt;Log4j、Log4j2、Logback&lt;/h2&gt;
&lt;p&gt;日志记录框架&lt;/p&gt;
&lt;h2 id=&#34;ehcache&#34;&gt;Ehcache&lt;/h2&gt;
&lt;p&gt;EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展，缓存异常处理程序，一个gzip缓存servlet过滤器，支持REST和SOAP api等特点。&lt;/p&gt;
&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;
&lt;p&gt;redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。Redis数据库完全在内存中，使用磁盘仅用于持久性。Redis可以将数据复制到任意数量的从服务器。&lt;/p&gt;
&lt;h2 id=&#34;shiro&#34;&gt;Shiro&lt;/h2&gt;
&lt;p&gt;Apache Shiro是Java的一个安全框架，旨在简化身份验证和授权。Shiro在JavaSE和JavaEE项目中都可以使用。它主要用来处理身份认证，授权，企业会话管理和加密等。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;分布式系统&#34;&gt;分布式系统&lt;/h2&gt;
&lt;p&gt;若干独立计算机（相关系统）的集合。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用可以按业务类型拆分成多个应用，再按结构分成接口层、服务层；我们也可以按访问入口分，如移动端、PC端等定义不同的接口应用；&lt;/li&gt;
&lt;li&gt;数据库可以按业务类型拆分成多个实例，还可以对单表进行分库分表；&lt;/li&gt;
&lt;li&gt;增加分布式缓存、搜索、文件、消息队列、非关系型数据库等中间件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分布式系统虽好，也带来了系统的复杂性，如分布式事务、分布式锁、分布式session、数据一致性等都是现在分布式系统中需要解决的难题，虽然已经有很多成熟的方案，但都不完美。分布式系统也增加了开发测试运维成本，工作量增加，分布式系统管理不好反而会变成一种负担。&lt;/p&gt;
&lt;h2 id=&#34;cdn&#34;&gt;CDN&lt;/h2&gt;
&lt;p&gt;全称为Content Delivery Network，即内容分发网络。&lt;/p&gt;
&lt;p&gt;其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。&lt;/p&gt;
&lt;p&gt;现在CDN一般都以缓存网站的静态内容为主，如果静态网页页面、JS、CSS、图片等静态文件。如用户访问一个动态网站，首先从服务器请求到动态数据，再从CDN上请求下载静态数据的，因为CDN能就近网络取材，从而减少了下载静态数据的时间，加快了网页的显示速度。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可扩展性，能应对激增的大量用户请求的扩展能力。&lt;/li&gt;
&lt;li&gt;安全性，CDN可以减少DDOS攻击及其他恶意攻击行为，避免对网站业务造成中断。&lt;/li&gt;
&lt;li&gt;可靠性，CDN通过负载均衡能及时提供网络的容错机制能力。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式：简单工厂模式（抽象工厂模式），工厂方法模式，建造者模式，原型模式，单例模式√。(5个)&lt;/li&gt;
&lt;li&gt;结构型模式：外观模式、适配器模式、代理模式、装饰模式、桥接模式、组合模式、享元模式。(7个)&lt;/li&gt;
&lt;li&gt;行为型模式：模版方法模式、观察者模式、状态模式、职责链模式、命令模式、访问者模式、策略模式、备忘录模式、迭代器模式、解释器模式、 中介者模式。(11个)&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
