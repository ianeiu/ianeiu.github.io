<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0">
  <channel>
    <title>ianeiu</title>
    <link>https://ianeiu.github.io/</link>
    <description>Recent content on ianeiu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>WuWeiMian</copyright>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://ianeiu.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://ianeiu.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://ianeiu.github.io/about/</guid>
      
        <description>

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;吴炜棉&lt;/li&gt;
&lt;li&gt;weimianwu@foxmail.com&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span style=&#34;display:none&#34;&gt;### 友链&lt;/span&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Spring面试题</title>
      <link>https://ianeiu.github.io/2020/05/31/spring%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/05/31/spring%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      
        <description>

&lt;h2 id=&#34;spring装配bean的过程&#34;&gt;Spring装配Bean的过程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;实例化;&lt;/li&gt;
&lt;li&gt;设置属性值;&lt;/li&gt;
&lt;li&gt;如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name;&lt;/li&gt;
&lt;li&gt;如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory;&lt;/li&gt;
&lt;li&gt;如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext&lt;/li&gt;
&lt;li&gt;调用BeanPostProcessor的预先初始化方法;&lt;/li&gt;
&lt;li&gt;调用InitializingBean的afterPropertiesSet()方法;&lt;/li&gt;
&lt;li&gt;调用定制init-method方法；&lt;/li&gt;
&lt;li&gt;调用BeanPostProcessor的后初始化方法;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;springboot的启动过程&#34;&gt;springboot的启动过程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;通过 SpringFactoriesLoader加载 META-INF/spring.factories文件，获取并创建 SpringApplicationRunListener对象&lt;/li&gt;
&lt;li&gt;然后由 SpringApplicationRunListener来发出 starting 消息&lt;/li&gt;
&lt;li&gt;创建参数，并配置当前 SpringBoot 应用将要使用的 Environment&lt;/li&gt;
&lt;li&gt;完成之后，依然由 SpringApplicationRunListener来发出 environmentPrepared 消息&lt;/li&gt;
&lt;li&gt;创建 ApplicationContext&lt;/li&gt;
&lt;li&gt;初始化 ApplicationContext，并设置 Environment，加载相关配置等&lt;/li&gt;
&lt;li&gt;由 SpringApplicationRunListener来发出 contextPrepared消息，告知SpringBoot 应用使用的ApplicationContext已准备OK&lt;/li&gt;
&lt;li&gt;将各种 beans 装载入 ApplicationContext，继续由 SpringApplicationRunListener来发出 contextLoaded 消息，告知SpringBoot 应用使用的 ApplicationContext已装填OK&lt;/li&gt;
&lt;li&gt;refresh ApplicationContext，完成IoC容器可用的最后一步&lt;/li&gt;
&lt;li&gt;由 SpringApplicationRunListener来发出 started 消息&lt;/li&gt;
&lt;li&gt;完成最终的程序的启动&lt;/li&gt;
&lt;li&gt;由 SpringApplicationRunListener来发出 running 消息，告知程序已运行行起来了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://ianeiu.github.io/resouce/spring/springboot的启动过程.png&#34;  alt=&#34;nio&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;spring事件的实现原理-写出常用的几个事件&#34;&gt;spring事件的实现原理，写出常用的几个事件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;事件机制：Spring中的事件机制是一个观察者模式的实现.观察者模式就是一个目标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。&lt;/li&gt;
&lt;li&gt;spring默认存在的事件：

&lt;ol&gt;
&lt;li&gt;ContextStartedEvent：ApplicationContext启动后触发的事件&lt;/li&gt;
&lt;li&gt;ContextStoppedEvent：ApplicationContext停止后触发的事件&lt;/li&gt;
&lt;li&gt;ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件&lt;/li&gt;
&lt;li&gt;ContextClosedEvent：ApplicationContext关闭后触发的事件&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Java笔记之NIO</title>
      <link>https://ianeiu.github.io/2020/05/20/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/</link>
      <pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/05/20/java%E7%AC%94%E8%AE%B0%E4%B9%8Bnio/</guid>
      
        <description>

&lt;h2 id=&#34;java-提供了哪些-io-方式-nio-如何实现多路复用&#34;&gt;Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？&lt;/h2&gt;

&lt;p&gt;Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。
首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。 交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时， 在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。
java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。&lt;/p&gt;

&lt;p&gt;很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、 HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。&lt;/p&gt;

&lt;p&gt;第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象， 可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。&lt;/p&gt;

&lt;p&gt;第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。
异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里， 当后台处理完成，操作系统会通知相应线程进行后续工作。&lt;/p&gt;

&lt;p&gt;NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，
仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。&lt;/p&gt;

&lt;p&gt;NIO是一种非阻塞式I/O；采用了双向通道进行数据传输，NIO基于Channel和Buffer(缓冲区)进⾏行行操作，数据总是从通道读取到缓冲区中，或者从缓冲区
写⼊入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。&lt;/p&gt;

&lt;h2 id=&#34;io-nio&#34;&gt;IO、NIO&lt;/h2&gt;

&lt;p&gt;IO 概览:&lt;br /&gt;
* IO 不仅仅是对文件的操作，网络编程中，比如 Socket 通信，都是典型的 IO 操作目标。
* 输入流、输出流（InputStream/OutputStream）是用于读取或写入字节的，例如操作图片文件。
* 而 Reader/Writer 则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader/Writer 相当于构建了应用逻辑和原始数据之间的桥梁。
* BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。
* 很多 IO 工具类都实现了 Closeable 接口，因为需要进行资源的释放。&lt;/p&gt;

&lt;p&gt;NIO 概览：&lt;br /&gt;
* Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的 Buffer 实现。
* Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式IO 操作的一种抽象。
* File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过Socket 获取 Channel，反之亦然。
* Selector，是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多Channel 的高效管理。
* Chartset，提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，Charset.defaultCharset().encode(&amp;ldquo;Hello world!&amp;rdquo;))进行字符串到 ByteBuffer 的转换&lt;/p&gt;

&lt;p&gt;IO 适用场景&lt;br /&gt;
如果只有少量量的连接，⽽而这些连接每次要发送⼤大量量的数据，这时候传统的IO更更合适。使⽤用哪种处理理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作⽐比较来权衡选择。&lt;/p&gt;

&lt;p&gt;NIO 适用场景&lt;br /&gt;
如果需要管理理同时打开的成千上万个连接，这些连接每次只是发送少量量的数据，例例如聊天服务器器，这时候⽤用NIO处理理数据可能是个很好的选择。(适⽤用于⼩小数据多连接)&lt;/p&gt;

&lt;p&gt;原理：
1.  由一个专⻔门的线程来处理所有的 IO 事件，并负责分发。
2.  事件驱动机制：事件到的时候触发，而不是同步的去监视事件。
3.  线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少⽆无谓的线程切换。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ianeiu.github.io/resouce/java/nio.png&#34;  alt=&#34;nio&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JVM笔记之调优及参数</title>
      <link>https://ianeiu.github.io/2020/05/18/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B0%83%E4%BC%98%E5%8F%8A%E5%8F%82%E6%95%B0/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/05/18/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B0%83%E4%BC%98%E5%8F%8A%E5%8F%82%E6%95%B0/</guid>
      
        <description>

&lt;h1 id=&#34;调优&#34;&gt;调优&lt;/h1&gt;

&lt;h2 id=&#34;调优时机&#34;&gt;调优时机&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;内存（⽼年代）持续上涨达到设置的最大内存值；&lt;/li&gt;
&lt;li&gt;Full GC 次数频繁；&lt;/li&gt;
&lt;li&gt;GC 停顿时间过长（超过1秒）；&lt;/li&gt;
&lt;li&gt;应用出现OutOfMemory 等内存异常；&lt;/li&gt;
&lt;li&gt;应⽤中使用本地缓存占用大量内存空间；&lt;/li&gt;
&lt;li&gt;系统吞吐量量与响应性能不高或下降。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;调优原则&#34;&gt;调优原则&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;多数的Java应用不需要在服务器上进行JVM优化，JVM优化是到最后不得已才采用的⼿段；&lt;/li&gt;
&lt;li&gt;多数导致GC问题的Java应用，往往是代码问题，分析GC情况优化代码；&lt;/li&gt;
&lt;li&gt;在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；&lt;/li&gt;
&lt;li&gt;减少创建对象的数量；&lt;/li&gt;
&lt;li&gt;减少使用全局变量和大对象&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;调优目标&#34;&gt;调优目标&lt;/h2&gt;

&lt;p&gt;GC低停顿、低频率； 低内存占用；⾼吞吐量&lt;/p&gt;

&lt;h2 id=&#34;调优步骤&#34;&gt;调优步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;分析GC日志及dump⽂文件，判断是否需要优化，确定瓶颈问题点；&lt;/li&gt;
&lt;li&gt;确定jvm调优量化目标；&lt;/li&gt;
&lt;li&gt;确定jvm调优参数（根据历史jvm参数来调整）；&lt;/li&gt;
&lt;li&gt;调优一台服务器，对比观察调优前后的差异；&lt;/li&gt;
&lt;li&gt;不断的分析和调整，直到找到合适的jvm参数配置；&lt;/li&gt;
&lt;li&gt;找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;参数&#34;&gt;参数&lt;/h1&gt;

&lt;h2 id=&#34;堆参数设置&#34;&gt;堆参数设置&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;-Xms 设置Java程序启动时初始化JVM堆内存大小。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-Xmx 设置Java程序能获得最大JVM堆内存大小。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-XX:+PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-XX:+PrintGCDetails 可以查看详细信息，包括各个区的情况&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-XX:+PrintHeapAtGC 打印 GC 前后的详细堆栈信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-XX:+PrintFlagsInitial打印JVM初始化参数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-XX:+PrintFlagsFinal　标记人为修改过的参数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-XX:+PrintCommandLineFlags 查看默认垃圾回收器。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;新生代参数设置&#34;&gt;新生代参数设置&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;-XX:NewSize=5m 设置新生代最小空间大小&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-XX:MaxNewSize=10m 设置新生代最大空间大小&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-Xmn2g 设置新生代大小为2G，设置一个比较大的新生代会减少老年代的大小，这个参数对系统性能以及GC行为有很大的影响，&lt;b&gt;新生代大小一般会设置整个堆空间的1/3&lt;/b&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-XX:SurvivorRatio=8（默认）用来设置新生代中eden空间和from/to空间的比例。-XX:SurvivorRatio=eden/from=eden/to。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本策略：尽可能将对象预留在新生代，减少老年代的GC次数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-XX:NewRatio=2（默认）设置新生代和老年代的比例 。-XX：NewRatio=老年代/新生代。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;对象进入老年代参数设置&#34;&gt;对象进入老年代参数设置&lt;/h2&gt;

&lt;p&gt;-XX:MaxTenuringThreshold=15&lt;/p&gt;

&lt;p&gt;新生代每次GC之后如果对象没有被回收，则年龄加1，默认情况下为15&lt;/p&gt;

&lt;h2 id=&#34;堆溢出参数配置&#34;&gt;堆溢出参数配置&lt;/h2&gt;

&lt;p&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/p&gt;

&lt;p&gt;使用该参数可以在内存溢出时导出整个堆信息&lt;/p&gt;

&lt;p&gt;-XX:HeapDumpPath=D:/OOM.dump&lt;/p&gt;

&lt;p&gt;可以设置导出堆的存放路径。&lt;/p&gt;

&lt;h2 id=&#34;堆栈相关参数配置&#34;&gt;堆栈相关参数配置&lt;/h2&gt;

&lt;p&gt;　-Xss1m（默认）
　
来指定线程的最大栈空间&lt;/p&gt;

&lt;h2 id=&#34;方法区相关参数配置&#34;&gt;方法区相关参数配置&lt;/h2&gt;

&lt;p&gt;JDK1.2 ~ JDK6，使用永久代来实现方法区&lt;/p&gt;

&lt;p&gt;-XX:PermSize=64M&lt;/p&gt;

&lt;p&gt;设置永久代最小空间大小。&lt;/p&gt;

&lt;p&gt;-XX:MaxPermSize=64M（默认）&lt;/p&gt;

&lt;p&gt;如果系统运行时生产大量的类，就需要设置一个相对合适的方法区，以免出现永久区内存溢出的问题。&lt;/p&gt;

&lt;p&gt;Java8，元空间取代永久代，存储位置不同，永久代物理是堆的一部分，和新生代，老年代地址是连续的&lt;/p&gt;

&lt;p&gt;而元数据放到本地化的堆内存(native heap)中，这一块区域就叫Metaspace&lt;/p&gt;

&lt;p&gt;-XX:MetaspaceSize=128m（默认）&lt;/p&gt;

&lt;p&gt;初始化大小。&lt;/p&gt;

&lt;p&gt;　-XX:MaxMetaspaceSize=128m　&lt;/p&gt;

&lt;p&gt;JVM默认在运行时根据需要动态地设置MaxMetaspaceSize的大小。&lt;/p&gt;

&lt;h2 id=&#34;直接内存-堆外内存-参数配置&#34;&gt;直接内存（堆外内存）参数配置&lt;/h2&gt;

&lt;p&gt;-XX:MaxDirectMemorySize=64m&lt;/p&gt;

&lt;p&gt;该值是有上限的，默认是64M，最大为sun.misc.VM.maxDirectMemory()。   直接内存使用达到上限时，就会触发垃圾回收（Full GC），如果不能有效的释放空间，就会引起系统的OOM。&lt;/p&gt;

&lt;h2 id=&#34;tlab参数配置&#34;&gt;TLAB参数配置&lt;/h2&gt;

&lt;p&gt;Thread Local Allocation Buffer即线程本地分配缓存：&lt;/p&gt;

&lt;p&gt;一个线程专用的内存分配区域，是为了加速对象分配对象而生的。每一个线程都会产生一个TLAB，该线程独享的工作区域，Java虚拟机使用这种TLAB区避免多线程冲突问题，提高了对象分配的效率。&lt;/p&gt;

&lt;p&gt;-XX:+UseTLAB（默认开启）&lt;/p&gt;

&lt;p&gt;使用TLAB&lt;/p&gt;

&lt;p&gt;-XX:TLABSize=64k（默认）　&lt;/p&gt;

&lt;p&gt;设置TLAB初始化大小&lt;/p&gt;

&lt;p&gt;-XX:TLABRefillWasteFraction=64&lt;/p&gt;

&lt;p&gt;设置维护进入TLAB空间的单个对象大小，它是一个比例值，默认为64，即如果对象大于整个空间的1/64，则在堆创建对象。&lt;/p&gt;

&lt;p&gt;　-XX:+ResizeTLAB　&lt;/p&gt;

&lt;p&gt;自调整TLABRefillWasteFraction阈值。&lt;/p&gt;

&lt;p&gt;-XX:+PrintTLAB　&lt;/p&gt;

&lt;p&gt;查看TLAB信息&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Spring中的设计模式</title>
      <link>https://ianeiu.github.io/2020/05/17/spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/05/17/spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;简单工厂：spring中的BeanFactory就是简单工厂模式的体现，根据传⼊入一个唯一的标识来获得bean对象，但是否是在传⼊参数后创建还是传入参数前创建这个要根据具体情况来定。&lt;/li&gt;
&lt;li&gt;单例模式：Spring下默认的bean均为singleton。&lt;/li&gt;
&lt;li&gt;代理模式：为其他对象提供⼀种代理以控制对这个对象的访问。从结构上来看和Decorator模式类似，但Proxy是控制，更更像是一种对功能的限制，而Decorator是增加职责。 spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。&lt;/li&gt;
&lt;li&gt;观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更更新。spring中Observer模式常用的地方是listener的实现。如ApplicationListener。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>贪婪模式与懒惰模式</title>
      <link>https://ianeiu.github.io/2020/03/20/%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/03/20/%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;p&gt;&lt;strong&gt;知识点：正则表达式中表示字符串重复个数的元字符，如 &lt;code&gt;?,+,*,{}&lt;/code&gt;  默认贪婪模式匹配最大长度匹配字符串。
在元字符后加个&lt;code&gt;?&lt;/code&gt;即可切换为懒惰模式&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;之前做过一个短信模版的配置功能，需要用到正则判断完成预览方法，踩了个小坑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 部分代码 --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;//libs.baidu.com/jquery/1.10.2/jquery.min.js&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
$(document).ready(function () {
	createContentPreview()
});


function createContentPreview(){
        //遍历获取所有input标签值
	var vals=[];
	$(&amp;quot;#tExaDiv&amp;quot;).find(&amp;quot;input&amp;quot;).each(function(){
		var val=$(this).val();
		vals.push(val);
	})
	
        // 含有&amp;lt;input type=&amp;quot;..&amp;quot; /&amp;gt;标签
	var html=$(&amp;quot;#tExaDiv&amp;quot;).html();

        //遍历替换
	var reg=/&amp;lt;input[^]*?&amp;gt;/;
	for(var i=0;i&amp;lt;vals.length;i++){
		html=html.replace(reg,vals[i]);
	}

        //渲染
	$(&amp;quot;#contentPreview&amp;quot;).html(html);
}
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;tExaDiv&amp;quot;&amp;gt;
	如果我是&amp;lt;input =&amp;quot;text&amp;quot; value=&amp;quot;dj&amp;quot;/&amp;gt;,你会&amp;lt;input =&amp;quot;text&amp;quot; value=&amp;quot;爱&amp;quot;/&amp;gt;我吗？
&amp;lt;/div&amp;gt;

&amp;lt;div id=&amp;quot;contentPreview&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contentPreview内容：如果我是dj,你会爱我吗？&lt;br /&gt;
如果未加?，则是贪婪模式。contentPreview显示错误内容：如果我是dj我吗？&lt;/p&gt;

&lt;h2 id=&#34;懒惰模式&#34;&gt;懒惰模式&lt;/h2&gt;

&lt;p&gt;对字符串进行最小长度匹配&lt;/p&gt;

&lt;p&gt;字符串：&lt;code&gt;&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br /&gt;
正则表达式：&lt;code&gt;&amp;lt;span&amp;gt;.*?&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br /&gt;
匹配结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;共找到 2 处匹配：  
	&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt; 
	&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;贪婪模式&#34;&gt;贪婪模式&lt;/h2&gt;

&lt;p&gt;对字符串进行最大长度匹配&lt;/p&gt;

&lt;p&gt;字符串：&lt;code&gt;&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br /&gt;
正则表达式：&lt;code&gt;&amp;lt;span&amp;gt;.*&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;br /&gt;
匹配结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;共找到 1 处匹配：
&amp;lt;span&amp;gt;321&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;12&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常见元字符及其含义&#34;&gt;常见元字符及其含义&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;符号               含义
————————————————————————————————————————————————————
.                  匹配除换行符之外的任意字符
^                  匹配字符的开始位置
$                  匹配字符的结束位置
*                  匹配0次，1次或多次前面的原子
?                  匹配0次或1次前面的原子
+                  匹配1次或多次前面的原子
{n}                前面的原子恰好出现n次
{n,}               前面的原子至少出现n次
{n,m}              前面的原子至少出现n次，至多出现m次
|                  模式选择符
()                 模式单元符   
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Java面试之并发</title>
      <link>https://ianeiu.github.io/2020/03/05/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/03/05/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/</guid>
      
        <description>

&lt;h2 id=&#34;什么是乐观锁和悲观锁&#34;&gt;什么是乐观锁和悲观锁？&lt;/h2&gt;

&lt;p&gt;1、悲观锁&lt;br /&gt;
Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。&lt;/p&gt;

&lt;p&gt;2、乐观锁&lt;br /&gt;
乐观锁（Optimstic Locking）其实是一种思想。相对悲观锁而言，乐观锁假定认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式地对数据的冲突与否进行检测，如果发现冲突了，则返回错误信息。&lt;/p&gt;

&lt;h2 id=&#34;什么是aqs&#34;&gt;什么是AQS&lt;/h2&gt;

&lt;p&gt;AbstractQueuedSynchronizer，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、FutureTask等。&lt;/p&gt;

&lt;p&gt;AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作 哨兵节点或这哑节点，它不与任何线程关联。其他节点与等待线程关联，每个节点维护一个等待状态waitStatus。&lt;/p&gt;

&lt;h2 id=&#34;同步容器与并发容器&#34;&gt;同步容器与并发容器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;同步容器

&lt;ol&gt;
&lt;li&gt;同步容器主要代表用Vector和Hashtable，及Collections.synchronizedXXX等&lt;/li&gt;
&lt;li&gt;锁粒度为整体对象&lt;/li&gt;
&lt;li&gt;迭代器是及时失败的，迭代过程修改会抛出ConcurrentModificationException&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;并发容器

&lt;ol&gt;
&lt;li&gt;主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet&lt;/li&gt;
&lt;li&gt;锁粒度是分散的、细粒度，即读写使用不同锁&lt;/li&gt;
&lt;li&gt;迭代器具有弱一致性，能够迭代时修改。
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;synchronized-底层如何实现-什么是锁的升级-降级&#34;&gt;synchronized 底层如何实现？什么是锁的升级、降级？&lt;/h2&gt;

&lt;p&gt;synchronized 代码块是由 monitorenter/monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。&lt;/p&gt;

&lt;p&gt;在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。&lt;/p&gt;

&lt;p&gt;现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，
也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。&lt;/p&gt;

&lt;p&gt;所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，
当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。&lt;/p&gt;

&lt;p&gt;当没有竞争出现时，默认会使用偏斜锁。
JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。
这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。&lt;/p&gt;

&lt;p&gt;如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。
轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。&lt;/p&gt;

&lt;p&gt;当JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。&lt;/p&gt;

&lt;p&gt;偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，
只有当存在较多不会真正竞争的 synchronized 块儿时，才能体现出明显改善。
实践中对于偏斜锁的一直是有争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。
还有一方面是，偏斜锁会延缓 JIT 预热的进程，所以很多性能测试中会显式地关闭偏斜锁，命令：&lt;code&gt;-XX:-UseBiasedLocking&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;自旋锁-是做什么的吗-它的使用场景是什么&#34;&gt;“自旋锁”是做什么的吗？它的使用场景是什么？&lt;/h2&gt;

&lt;p&gt;自旋锁:&lt;br /&gt;
竞争锁失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，
在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。&lt;/p&gt;

&lt;p&gt;适用场景:&lt;br /&gt;
自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，
因为自旋的消耗会小于线程阻塞挂起操作的消耗。
如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁了，
因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费。&lt;/p&gt;

&lt;h2 id=&#34;一个线程两次调用-start-方法会出现什么情况-谈谈线程的生命周期和状态转移&#34;&gt;一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。&lt;/h2&gt;

&lt;p&gt;Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException。&lt;br /&gt;
在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。&lt;/p&gt;

&lt;p&gt;线程的生命周期和状态转移 详见java笔记基础篇&lt;/p&gt;

&lt;p&gt;线程是系统调度的最小单元，一个进程可以包含多个线程，
作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（ThreadLocal）等，
但是会和进程内其他线程共享文件描述符、虚拟地址空间等。&lt;/p&gt;

&lt;h2 id=&#34;虚假唤醒&#34;&gt;虚假唤醒&lt;/h2&gt;

&lt;p&gt;在多核处理器下，pthread_cond_signal可能会激活多于一个线程（阻塞在条件变量上的线程）。
结果就是，当一个线程调用pthread_cond_signal()后，多个调用pthread_cond_wait()或pthread_cond_timedwait()的线程返回。这种效应就称为“虚假唤醒”。&lt;/p&gt;

&lt;p&gt;举个例子，我们现在有一个生产者-消费者队列和三个线程。&lt;/p&gt;

&lt;p&gt;1） 1号线程从队列中获取了一个元素，此时队列变为空。&lt;/p&gt;

&lt;p&gt;2） 2号线程也想从队列中获取一个元素，但此时队列为空，2号线程便只能进入阻塞(cond.wait())，等待队列非空。&lt;/p&gt;

&lt;p&gt;3） 这时，3号线程将一个元素入队，并调用cond.notify()唤醒条件变量。&lt;/p&gt;

&lt;p&gt;4） 处于等待状态的2号线程接收到3号线程的唤醒信号，便准备解除阻塞状态，执行接下来的任务(获取队列中的元素)。&lt;/p&gt;

&lt;p&gt;5） 然而可能出现这样的情况：当2号线程准备获得队列的锁，去获取队列中的元素时，此时1号线程刚好执行完之前的元素操作，返回再去请求队列中的元素，1号线程便获得队列的锁，检查到队列非空，就获取到了3号线程刚刚入队的元素，然后释放队列锁。&lt;/p&gt;

&lt;p&gt;6） 等到2号线程获得队列锁，判断发现队列仍为空，1号线程“偷走了”这个元素，所以对于2号线程而言，这次唤醒就是“虚假”的，它需要再次等待队列非空。&lt;/p&gt;

&lt;p&gt;如果用if判断，多个等待线程在满足if条件时都会被唤醒(虚假的)，但实际上条件并不满足，生产者生产出来的消费品已经被第一个线程消费了。
这就是我们使用while去做判断而不是使用if的原因：因为等待在条件变量上的线程被唤醒有可能不是因为条件满足而是由于虚假唤醒。
所以，我们需要对条件变量的状态进行不断检查直到其满足条件，不仅要在pthread_cond_wait前检查条件是否成立，在pthread_cond_wait之后也要检查。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while ( isCondition()) {
    waitForAConfition(...);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;慎用threadlocal&#34;&gt;慎用ThreadLocal&lt;/h2&gt;

&lt;p&gt;慎用ThreadLocal，这是 Java 提供的一种保存线程私有信息的机制，
因为其在整个线程生命周期内有效，所以可以方便地在一个线程关联的不同业务模块之间传递信息，比如事务 ID、Cookie 等上下文相关信息。&lt;/p&gt;

&lt;p&gt;它的实现结构，可以参考源码，数据存储于线程相关的 ThreadLocalMap，其内部条目是弱引用，如下面片段。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static class ThreadLocalMap {
    static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
        /** The value associated with this ThreadLocal. */
        Object value;
        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
            super(k);
            value = v;
        }
    }
    // …
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 Key 为 null 时，该条目就变成“废弃条目”，相关“value”的回收，往往依赖于几个关键点，即 set、remove、rehash。&lt;/p&gt;

&lt;p&gt;下面是 set 的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void set(ThreadLocal&amp;lt;?&amp;gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp;amp; (len-1);
    for (Entry e = tab[i];; …) {
        //…
        if (k == null) {
            // 替换废弃条目
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    tab[i] = new Entry(key, value);
    int sz = ++size;
    // 扫描并清理发现的废弃条目，并检查容量是否超限
    if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)
        rehash();// 清理废弃条目，如果仍然超限，则扩容（加倍）
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常弱引用都会和引用队列配合清理机制使用，但是 ThreadLocal 是个例外，它并没有这么做。&lt;/p&gt;

&lt;p&gt;这意味着，废弃项目的回收依赖于显式地触发，否则就要等待线程结束，进而回收相应ThreadLocalMap！
这就是很多 OOM 的来源，所以通常都会建议，应用一定要自己负责remove，并且不要和线程池配合，因为 worker 线程往往是不会退出的。&lt;/p&gt;

&lt;h2 id=&#34;jvm-启动-hello-world的线程分析&#34;&gt;JVM 启动 Hello World的线程分析&lt;/h2&gt;

&lt;p&gt;检测获得
Thread[Reference Handler,10,system]&lt;br /&gt;
Thread[Finalizer,8,system]&lt;br /&gt;
Thread[main,5,main]&lt;br /&gt;
Thread[Signal Dispatcher,9,system]&lt;br /&gt;
Hello World!&lt;/p&gt;

&lt;p&gt;其中：&lt;br /&gt;
Reference Handler：处理引用对象本身的垃圾回收&lt;br /&gt;
Finalizer：处理用户的Finalizer方法&lt;br /&gt;
Signal Dispatcher：外部jvm命令的转发器&lt;br /&gt;
在jdk6环境中,还有一个Attach Listener的线程是负责接收外部命令的，如jmap、jstack&lt;/p&gt;

&lt;h2 id=&#34;什么情况下-java-程序会产生死锁-如何定位-修复&#34;&gt;什么情况下 Java 程序会产生死锁？如何定位、修复？&lt;/h2&gt;

&lt;p&gt;死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。
死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。
通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。&lt;/p&gt;

&lt;p&gt;定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。
如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。&lt;/p&gt;

&lt;p&gt;如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。
所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。&lt;/p&gt;

&lt;p&gt;基本上死锁的发生是因为：
* 互斥条件，类似 Java 中 Monitor 都是独占的，要么是我用，要么是你用。
* 互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。
* 循环依赖关系，两个或者多个个体之间出现了锁的链条环。&lt;/p&gt;

&lt;p&gt;如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁；&lt;br /&gt;
如果必须使用多个锁，尽量设计好锁的获取顺序（根据对象之间组合、调用的关系对比和组合，考虑可能调用时序）；&lt;br /&gt;
使用带超时的方法，为程序带来更多可控性；&lt;br /&gt;
业界也有一些其他方面的尝试，比如通过静态代码分析（如 FindBugs）去查找固定的模式，进而定位可能的死锁或者竞争情况&lt;/p&gt;

&lt;p&gt;死循环死锁可以认为是自旋锁死锁的一种，其他线程因为等待不到具体的信号提示。导致线程一直饥饿。&lt;br /&gt;
这种情况下可以查看线程 cpu 使用情况，排查出使用 cpu 时间片最高的线程，再打出该线程的堆栈信息，排查代码。&lt;br /&gt;
比如Linux上，可以使用top命令配合grep Java之类，找到忙的pid；然后，转换成16进制，就是jstack输出中的格式；再定位代码&lt;/p&gt;

&lt;h2 id=&#34;java-并发包提供了哪些并发工具类&#34;&gt;Java 并发包提供了哪些并发工具类？&lt;/h2&gt;

&lt;p&gt;我们通常所说的并发包也就是 java.util.concurrent 及其子包，集中了 Java 并发的各种基础工具类，具体主要包括几个方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Sempahore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。&lt;/li&gt;
&lt;li&gt;各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的ConcunrrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList 等。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;各种并发队列实现，如各种 BlockedQueue 实现，比较典型的 ArrayBlockingQueue、SynchorousQueue 或针对特定场景的 PriorityBlockingQueue 等。&lt;/li&gt;
&lt;li&gt;强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CountDownLatch，允许一个或多个线程等待某些操作完成。&lt;br /&gt;
CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障。&lt;br /&gt;
Semaphore，Java 版本的信号量实现。&lt;/p&gt;

&lt;p&gt;两个应用并发工具的场景:&lt;br /&gt;
1. 请求熔断器，使用 Semaphore 熔断某些请求线程，待系统恢复以后再逐步释放信号量。
2. Worker 搜索停止标志。使用 countdownlatch 标记 Worker 找到的结果个数，达到结果后其他线程不再继续执行。&lt;/p&gt;

&lt;p&gt;Java 并发类库还提供了Phaser，功能与 CountDownLatch 很接近，但是它允许线程动态地注册到 Phaser 上面，而 CountDownLatch 显然是不能动态设置的。
Phaser 的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动。&lt;/p&gt;

&lt;p&gt;并发包里提供的线程安全 Map、List 和 Set，总体上种类和结构还是比较简单的。&lt;br /&gt;
如果我们的应用侧重于 Map 放入或者获取的速度，而不在乎顺序，大多推荐使用 ConcurrentHashMap，
反之则使用ConcurrentSkipListMap；如果我们需要对大量数据进行非常频繁地修改，ConcurrentSkipListMap 也可能表现出优势。&lt;/p&gt;

&lt;p&gt;关于两个 CopyOnWrite 容器，其实 CopyOnWriteArraySet 是通过包装了CopyOnWriteArrayList 来实现的
首先，CopyOnWrite 到底是什么意思呢？它的原理是，任何修改操作，如 add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean add (E e){
    synchronized (lock) {
        Object[] elements = getArray();
        int len = elements.length;
        // 拷贝
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        // 替换
        setArray(newElements);
        return true;
    }
}
final void setArray (Object[]a){
    array = a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;并发包中的-concurrentlinkedqueue-和-linkedblockingqueue-有什么区别&#34;&gt;并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue 内部则是基于锁，并提供了 BlockingQueue 的等待性方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;java.util.concurrent 包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为 Concurrent、CopyOnWrite和 Blocking* 等三类，同样是线程安全容，可以简单认为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。&lt;/li&gt;
&lt;li&gt;Concurrent 往往提供了较低的遍历一致性（弱一致性）。例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。size 等操作准确性是有限的。读取的性能具有一定的不确定性。&lt;/li&gt;
&lt;li&gt;与弱一致性对应的，就是我介绍过的同步容器常见的行为“fast-fail”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;哪些队列是有界的-哪些是无界的&#34;&gt;哪些队列是有界的，哪些是无界的？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ianeiu.github.io/resouce/java/mianshi/Queue.png&#34;  alt=&#34;Queue&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以从不同的角度进行分类，从基本的数据结构的角度分析，有两个特别的Deque实现，ConcurrentLinkedDeque 和 LinkedBlockingDeque。Deque 的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如:
* 尾部插入时需要的addLast(e)、offerLast(e)。
* 尾部删除所需要的removeLast()、pollLast()。&lt;/p&gt;

&lt;p&gt;从行为特征来看，绝大部分 Queue 都是实现了 BlockingQueue 接口。
在常规队列操作基础上，Blocking 意味着其提供了特定的等待性操作，获取时（take）等待元素进队，或者插入时（put）等待队列出现空位。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* 获取并移除队列头结点，如果必要，其会等待直到队列出现元素
…
*/
E take() throws InterruptedException;
/**
* 插入元素，如果队列已满，则等待直到队列出现空闲空间
…
*/
void put(E e) throws InterruptedException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个 BlockingQueue 经常被考察的点，就是是否有界（Bounded、Unbounded），这一点也往往会影响我们在应用开发中的选择。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ArrayBlockingQueue 是最典型的的有界队列，其内部以 final 的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建 ArrayBlockingQueue 时，都要指定容量，如
&lt;code&gt;
public ArrayBlockingQueue(int capacity, boolean fair)
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue，容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为Integer.MAX_VALUE，成为了无界队列。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SynchronousQueue，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PriorityBlockingQueue 是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DelayedQueue 和 LinkedTransferQueue 同样是无边界的队列。对于无边界的队列，有一个自然的结果，就是 put 操作永远也不会发生其他 BlockingQueue 的那种等待情况。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分析不同队列的底层实现，BlockingQueue 基本都是基于锁实现，一起来看看典型的LinkedBlockingQueue。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** Lock held by take, poll, etc */
private final ReentrantLock takeLock = new ReentrantLock();

/** Wait queue for waiting takes */
private final Condition notEmpty = takeLock.newCondition();

/** Lock held by put, offer, etc */
private final ReentrantLock putLock = new ReentrantLock();

/** Wait queue for waiting puts */
private final Condition notFull = putLock.newCondition();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayBlockingQueue，其条件变量与 LinkedBlockingQueue 版本的实现是有区别的，notEmpty、notFull都是同一个再入锁的条件变量，
而 LinkedBlockingQueue 则改进了锁操作的粒度，头、尾操作使用不同的锁，所以在通用场景下，它的吞吐量相对要更好一些。&lt;/p&gt;

&lt;p&gt;LinkedBlockingQueue 的 take 方法与 ArrayBlockingQueue 中的实现，也是有不同的，由于其内部结构是链表，需要自己维护元素数量值。&lt;/p&gt;

&lt;p&gt;类似 ConcurrentLinkedQueue 等，则是基于 CAS 的无锁技术，不需要在每个操作时使用锁，所以扩展性表现要更加优异。&lt;/p&gt;

&lt;p&gt;相对比较另类的 SynchronousQueue，在 Java 6 中，其实现发生了非常大的变化，利用 CAS
替换掉了原本基于锁的逻辑，同步开销比较小。它是 Executors.newCachedThreadPool() 的
默认队列。&lt;/p&gt;

&lt;h2 id=&#34;队列使用场景与典型用例&#34;&gt;队列使用场景与典型用例&lt;/h2&gt;

&lt;p&gt;在实际开发中，我提到过 Queue 被广泛使用在生产者 - 消费者场景，比如利用BlockingQueue 来实现，由于其提供的等待机制，我们可以少操心很多协调工作。&lt;/p&gt;

&lt;p&gt;在日常的应用开发中，如何进行选择呢？&lt;br /&gt;
以 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue 为例&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;考虑应用场景中对队列边界的要求。ArrayBlockingQueue 是有明确的容量限制的，而LinkedBlockingQueue 则取决于我们是否在创建时指定，SynchronousQueue 则干脆不能缓存任何元素。&lt;/li&gt;
&lt;li&gt;从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。&lt;/li&gt;
&lt;li&gt;通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。&lt;/li&gt;
&lt;li&gt;ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。&lt;/li&gt;
&lt;li&gt;如果我们需要实现的是两个线程之间接力性（handoff）的场景，可选择 CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。&lt;/li&gt;
&lt;li&gt;可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;java-并发类库提供的线程池有哪几种-分别有什么特点&#34;&gt;Java 并发类库提供的线程池有哪几种？ 分别有什么特点？&lt;/h2&gt;

&lt;p&gt;通常开发者都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。&lt;/p&gt;

&lt;p&gt;Executors 目前提供了 5 种不同的线程池创建配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。&lt;/li&gt;
&lt;li&gt;newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。&lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor()，它创建的是个 ScheduledExecutorService，也就是可以进行定时或周期性的工作调度。工作线程数目被限制为 1，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool(int corePoolSize)，同样是 ScheduledExecutorService，区别在于它会保持 corePoolSize 个工作线程。&lt;/li&gt;
&lt;li&gt;newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ianeiu.github.io/resouce/java/mianshi/Executor.png&#34;  alt=&#34;Executor&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Executor 是一个基础的接口，其初衷是将任务提交和任务执行细节解耦，这一点可以体会其定义的唯一方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void execute(Runnable command);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ExecutorService 则更加完善，不仅提供 service 的管理功能，比如 shutdown 等方法，也提供了更加全面的提交任务机制，如返回Future而不是 void 的 submit 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这个例子输入的可是Callable，它解决了 Runnable 无法返回结果的困扰。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java 标准类库提供了几种基础实现，比如ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool。这些线程池的设计特点在于其高度的可调节性和灵活性，以尽量满足复杂多变的实际应用场景。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Executors 则从简化使用的角度，为我们提供了各种方便的静态工厂方法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;threadpoolexecutor&#34;&gt;ThreadPoolExecutor&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ianeiu.github.io/resouce/java/mianshi/ThreadPoolExecutor.png&#34;  alt=&#34;ThreadPoolExecutor&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工作队列负责存储用户提交的各个任务，这个工作队列，可以是容量为 0 的 SynchronousQueue（使用 newCachedThreadPool），也可以是像固定大小线程池（newFixedThreadPool）那样使用 LinkedBlockingQueue
&lt;code&gt;
private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内部的“线程池”，这是指保持工作线程的集合，线程池需要在运行过程中管理线程创建、销毁。例如，对于带缓存的线程池，当任务压力较大时，线程池会创建新的工作线程；当业务压力退去，线程池会在闲置一段时间（默认 60 秒）后结束线程。
&lt;code&gt;
private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ThreadFactory 提供上面所需要的创建线程逻辑。&lt;/li&gt;
&lt;li&gt;如果任务提交时被拒绝，比如线程池已经处于 SHUTDOWN 状态，需要为其提供处理逻辑，Java 标准库提供了类似ThreadPoolExecutor.AbortPolicy等默认实现，也可以按照实际需求自定义。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程池的几个基本组成部分，一起都体现在线程池的构造函数中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目（除非设置了allowCoreThreadTimeOut）。对于不同的线程池，这个值可能会有很大区别，比如newFixedThreadPool 会将其设置为 nThreads，而对于 newCachedThreadPool 则是为0。&lt;/li&gt;
&lt;li&gt;maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数。同样进行对比，对于 newFixedThreadPool，当然就是 nThreads，因为其要求是固定大小，而newCachedThreadPool 则是 Integer.MAX_VALUE。&lt;/li&gt;
&lt;li&gt;keepAliveTime 和 TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。&lt;/li&gt;
&lt;li&gt;workQueue，工作队列，必须是 BlockingQueue。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过配置不同的参数，我们就可以创建出行为大相径庭的线程池，这就是线程池高度灵活性的基础。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
        int maximumPoolSize,
        long keepAliveTime,
        TimeUnit unit,
        BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
        ThreadFactory threadFactory,
        RejectedExecutionHandler handler)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;线程池实践&#34;&gt;线程池实践&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;避免任务堆积。newFixedThreadPool 是创建指定数目的线程，但是其工作队列是无界的，如果工作线程数目太少，导致处理跟不上入队的速度，这就很有可能占用大量统内存，甚至是出现 OOM。诊断时，你可以使用 jmap 之类的工具，查看是否有大量的任务对象入队。&lt;/li&gt;
&lt;li&gt;避免过度扩展线程。我们通常在处理大量短时任务时，使用缓存的线程池，比如在最新的HTTP/2 client API 中，目前的默认实现就是如此。我们在创建线程池的时候，并不能准确预计任务压力有多大、数据特征是什么样子（大部分请求是 1K 、100K 还是 1M 以上？），所以很难明确设定一个线程数目。&lt;/li&gt;
&lt;li&gt;如果线程数目不断增长（可以使用 jstack 等工具检查），也需要警惕另外一种可能性，就是线程泄漏，这种情况往往是因为任务逻辑有问题，导致工作线程迟迟不能被释放。建议你排查下线程栈，很有可能多个线程都是卡在近似的代码处。&lt;/li&gt;
&lt;li&gt;避免死锁等同步问题，对于死锁的场景和排查&lt;/li&gt;
&lt;li&gt;尽量避免在使用线程池时操作 ThreadLocal。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;线程池大小的选择策略&#34;&gt;线程池大小的选择策略&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果我们的任务主要是进行计算，那么就意味着 CPU 的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照 CPU 核的数目 N 或者 N+1。&lt;/li&gt;
&lt;li&gt;如果是需要较多等待的任务，例如 I/O 操作比较多，可以参考 Brain Goetz 推荐的计算方法：线程数 = CPU 核数 × （1 + 平均等待时间 / 平均工作时间）&lt;/li&gt;
&lt;li&gt;上面是仅仅考虑了 CPU 等限制，实际还可能受各种系统资源（文件句柄、内存）限制影响&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;atomicinteger-底层实现原理是什么-如何在自己的代码中应用cas-操作&#34;&gt;AtomicInteger 底层实现原理是什么？如何在自己的代码中应用CAS 操作？&lt;/h2&gt;

&lt;p&gt;AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术&lt;/p&gt;

&lt;p&gt;CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。
如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。&lt;/p&gt;

&lt;p&gt;从 AtomicInteger 的内部属性可以看出，它依赖于 Unsafe 提供的一些底层能力，进行底层操作；以 volatile 的 value 字段，记录数值，以保证可见性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();
private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &amp;quot;value&amp;quot;);
private volatile int value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的原子操作细节，可以参考任意一个原子更新方法，比如下面的 getAndIncrement。Unsafe 会利用 value 字段的内存地址偏移，直接完成操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final int getAndIncrement() {
    return U.getAndAddInt(this, VALUE, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 getAndIncrement 需要返归数值，所以需要添加失败重试逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而类似 compareAndSet 这种返回 boolean 类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final boolean compareAndSet(int expectedValue, int newValue)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CAS 是 Java 并发中所谓 lock-free 机制的基础。&lt;/p&gt;

&lt;p&gt;Java 9 中移除了 Unsafe.moniterEnter()/moniterExit()，导致无法平滑升级到新的 JDK 版本。
目前 Java 提供了两种公共 API，可以实现这种 CAS 操作，比如使用 java.util.concurrent.atomic.AtomicLongFieldUpdater，它是基于反射机制创建，我们需要保证类型和字段名称正确。&lt;/p&gt;

&lt;p&gt;Atomic 包提供了最常用的原子性数据类型，甚至是引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选。&lt;br /&gt;
atomic 包提供的LongAdder，在高度竞争环境下，可能就是比 AtomicLong 更佳的选择，尽管它的本质是空间换时间。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java面试题</title>
      <link>https://ianeiu.github.io/2020/02/15/java%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/02/15/java%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      
        <description>

&lt;h2 id=&#34;java平台理解及java是解释执行吗&#34;&gt;Java平台理解及Java是解释执行吗？&lt;/h2&gt;

&lt;p&gt;首先Java是一种面向对象的语言，本身具有两个特性：一个是跨平台能力（一次编写，到处运行），屏蔽了操作系统和硬件的细节；
第二个就是垃圾自动回收机制（GC）。&lt;/p&gt;

&lt;p&gt;我们日常接触到的jre（Java runtime environment）和jdk（Java development kit），
jre是Java运行时环境，包含了JVM和java类库；
jdk则是Java开发工具，里面提供了许多开发工具如；编译器(javac)、诊断和监控(jconsole)工具等。&lt;/p&gt;

&lt;p&gt;java生态：spring，spark，elasticsearch，maven&lt;/p&gt;

&lt;p&gt;不完全正确，Java是通过对源文件进行编译成字节码文件（.class），然后jvm（Java虚拟机）对字节码文件逐条进行解释运行。
但是往往有一部分热点代码（hot spot）会占有大部分时间解释，所以Java中会有jit（Just-In-Time）。即时编译器将该部分直接编译成机器代码直接运行，大大提高效率。
这部分热点代码就是编译执行了而不是解释执行。&lt;/p&gt;

&lt;p&gt;在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。
主流 Java 版本中，如 JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。
通常运行在 server 模式的 JVM，会进行上万次调用以收集足够的信息进行高效的编译，client 模式这个门限是 1500 次。
Oracle Hotspot JVM 内置了两个不同的 JIT compiler，
C1 对应前面说的 client 模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用；
C2 对应 server 模式，它的优化是为长时间运行的服务器端应用设计的，默认是采用所谓的分层编译（TieredCompilation）。&lt;/p&gt;

&lt;p&gt;除了我们日常最常见的 Java 使用模式，其实还有一种新的编译方式，
即所谓的 AOT（Aheadof-Time Compilation），直接将字节码编译成机器代码，
这样就避免了 JIT 预热等各方面的开销，
比如 Oracle JDK 9 就引入了实验性的 AOT 特性，并且增加了新的 jaotc 工具。&lt;/p&gt;

&lt;h2 id=&#34;java创建对象的方式&#34;&gt;java创建对象的方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;使用new关键字创建对象&lt;/li&gt;
&lt;li&gt;使用Class类的newInstance方法(反射机制)&lt;/li&gt;
&lt;li&gt;使用Constructor类的newInstance方法(反射机制)&lt;/li&gt;
&lt;li&gt;使用Clone方法创建对象&lt;/li&gt;
&lt;li&gt;使用(反)序列化机制创建对象&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;exception和error有什么区别&#34;&gt;Exception和Error有什么区别&lt;/h2&gt;

&lt;p&gt;Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。&lt;/p&gt;

&lt;p&gt;Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。&lt;/p&gt;

&lt;p&gt;Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM自身）处于非正常的、不可恢复状态。
既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。&lt;/p&gt;

&lt;p&gt;Exception 又分为可检查（checked）异常和不检查（unchecked）异常。
可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。
不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。&lt;/p&gt;

&lt;p&gt;扩展&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;NoClassDefFoundError 和 ClassNotFoundException 有什么区别，这也是个经典的入门题目。&lt;/li&gt;
&lt;li&gt;理解 Java 语言中操作 Throwable 的元素和实践。掌握最基本的语法是必须的，如 trycatch-finally 块，throw、throws 关键字等。&lt;/li&gt;
&lt;li&gt;与此同时，也要懂得如何处理典型场景。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常处理原则&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常。进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。&lt;/li&gt;
&lt;li&gt;不要生吞（swallow）异常&lt;/li&gt;
&lt;li&gt;try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码。&lt;/li&gt;
&lt;li&gt;请勿在try代码块中调用return、break或continue语句。万一无法避免，一定要确保finally的存在不会改变函数的返回值（不要在finally代码块中处理返回值）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;noclassdeffounderror-和-classnotfoundexception-有什么区别&#34;&gt;NoClassDefFoundError 和 ClassNotFoundException 有什么区别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;ClassNotFoundException&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;NoClassDefFoundError&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;从java.lang.Exception继承，是一个Exception类型&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从java.lang.Error继承，是一个Error类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;当动态加载Class的时候找不到类会抛出该异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当编译成功以后执行过程中Class找不到导致抛出该错误&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;一般在执行Class.forName()、ClassLoader.loadClass()或ClassLoader.findSystemClass()的时候抛出&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;由JVM的运行时系统抛出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;final-finally-finalize有什么不同&#34;&gt;final、finally、 finalize有什么不同&lt;/h2&gt;

&lt;p&gt;final 可以用来修饰类（不可继承扩展）、方法（不能重写）、变量（字段值不能修改。&lt;/p&gt;

&lt;p&gt;finally 异常处理理机制的关键字，表示最后执⾏行行。来进行类似关闭 JDBC 连接、保证 unlock 锁、释放资源等动作。&lt;/p&gt;

&lt;p&gt;finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。
finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为deprecated。
Java 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。&lt;/p&gt;

&lt;h2 id=&#34;不可变-immutable&#34;&gt;不可变 Immutable&lt;/h2&gt;

&lt;p&gt;Immutable 在很多场景是非常棒的选择，某种意义上说，Java 语言目前并没有原生的不可变支持，&lt;/p&gt;

&lt;p&gt;实现 immutable 的类&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将 class 自身声明为 final，这样别人就不能扩展来绕过限制了。&lt;/li&gt;
&lt;li&gt;将所有成员变量定义为 private 和 final，并且不要实现 setter 方法。&lt;/li&gt;
&lt;li&gt;通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。&lt;/li&gt;
&lt;li&gt;如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，使用 copy-on-write原则，创建私有的 copy。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;string-stringbuffer-stringbuilder-有什么区别&#34;&gt;String、StringBuffer、StringBuilder 有什么区别？&lt;/h2&gt;

&lt;p&gt;String是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性类似拼接、裁剪字符串等动作，都会产生新的 String 对象。&lt;/p&gt;

&lt;p&gt;原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。&lt;/p&gt;

&lt;p&gt;StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是StringBuilder。&lt;/p&gt;

&lt;p&gt;为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。&lt;br /&gt;
另外，这个内部数组应该创建成多大的呢？如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。
目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。
我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。
扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy&lt;/p&gt;

&lt;h4 id=&#34;字符串缓存&#34;&gt;字符串缓存&lt;/h4&gt;

&lt;p&gt;String 在 Java 6 以后提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。
在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。
一般来说，JVM 会将所有的类似“abc”这样的文本字符串，或者字符串常量之类缓存起来。&lt;/p&gt;

&lt;p&gt;看起来很不错是吧？但实际情况估计会让你大跌眼镜。一般使用 Java 6 这种历史版本，并不推荐大量使用 intern，为什么呢？
魔鬼存在于细节中，被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。
所以，如果使用不当，OOM 就会光顾。&lt;/p&gt;

&lt;p&gt;在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在JDK 8 中被 MetaSpace（元数据区）替代了。
而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用参数直接打印具体数字 &lt;code&gt;-XX:+PrintStringTableStatistics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;手动调整大小 &lt;code&gt;-XX:StringTableSize=N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intern 是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；
另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。&lt;br /&gt;
幸好在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。
它是通过将相同数据的字符串指向同一份数据来做到的，是 JVM 底层的改变，并不需要 Java 类库做什么修改。
这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用 G1 GC：&lt;br /&gt;
&lt;code&gt;-XX:+UseStringDeduplication&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;动态代理是基于什么原理&#34;&gt;动态代理是基于什么原理？&lt;/h2&gt;

&lt;p&gt;通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。&lt;/p&gt;

&lt;p&gt;Java 发射机制的常见应用：动态代理（AOP、RPC）、提供第三方开发者扩展能力（Servlet容器，JDBC连接）、第三方组件创建对象（DI）……&lt;/p&gt;

&lt;p&gt;动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，
比如用来包装 RPC 调用、面向切面的编程（AOP）。&lt;/p&gt;

&lt;p&gt;实现动态代理的方式很多，
比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。
还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。&lt;/p&gt;

&lt;p&gt;JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。新版本也开始结合ASM机制。
cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。&lt;/p&gt;

&lt;p&gt;JDK Proxy 的优势&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。&lt;/li&gt;
&lt;li&gt;平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。&lt;/li&gt;
&lt;li&gt;代码实现简单。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于类似 cglib 框架的优势&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。&lt;/li&gt;
&lt;li&gt;只操作我们关心的类，而不必为其他相关类增加工作量。&lt;/li&gt;
&lt;li&gt;高性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;有哪些方法可以在运行时动态生成一个-java-类&#34;&gt;有哪些方法可以在运行时动态生成一个 Java 类&lt;/h2&gt;

&lt;p&gt;直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。本质上还是在当前程序进程之外编译的。&lt;/p&gt;

&lt;p&gt;使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能。&lt;/p&gt;

&lt;p&gt;直接生成相应的字节码，然后交给类加载器去加载。通常我们可以利用 Java 字节码操纵工具和类库 ASM、Javassist、cglib 等 来实现。&lt;/p&gt;

&lt;h2 id=&#34;字节码和类加载到底是怎么无缝进行转换的-发生在整个类加载过程的哪一步&#34;&gt;字节码和类加载到底是怎么无缝进行转换的？发生在整个类加载过程的哪一步？&lt;/h2&gt;

&lt;p&gt;类从字节码到 Class 对象的转换，在类加载过程中，这一步是通过下面的方法提供的功能，或者 defineClass 的其他本地对等实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//只选取了最基础的两个典型的 defineClass 实现
protected final Class&amp;lt;?&amp;gt; defineClass(String name, byte[] b, int off, int len,
            ProtectionDomain protectionDomain)
protected final Class&amp;lt;?&amp;gt; defineClass(String name, java.nio.ByteBuffer b,
            ProtectionDomain protectionDomain)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要能够生成出规范的字节码，不管是作为 byte 数组的形式，还是放到 ByteBuffer里，都可以平滑地完成字节码到 Java 对象的转换过程。&lt;br /&gt;
JDK 提供的 defineClass 方法，最终都是本地代码实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private native Class&amp;lt;?&amp;gt; defineClass0(String name, byte[] b, int off, int len,
                                     ProtectionDomain pd);

private native Class&amp;lt;?&amp;gt; defineClass1(String name, byte[] b, int off, int len,
                                     ProtectionDomain pd, String source);

private native Class&amp;lt;?&amp;gt; defineClass2(String name, java.nio.ByteBuffer b,
                                     int off, int len, ProtectionDomain pd,
                                     String source);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;相关的字节码操纵逻辑&#34;&gt;相关的字节码操纵逻辑&lt;/h4&gt;

&lt;p&gt;JDK dynamic proxy （1.8） 的实现代码，对应逻辑是实现在 Proxy类中的 ProxyClassFactory 这个静态内部类，
通过 ProxyGenerator 生成字节码，并以 byte 数组的形式保存，然后调用 本地 的 defineClass0 入口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * Generate the specified proxy class.
 */
byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
    proxyName, interfaces, accessFlags);
try {
    return defineClass0(loader, proxyName,
                        proxyClassFile, 0, proxyClassFile.length);
} catch (ClassFormatError e) {
    /*
     * A ClassFormatError here means that (barring bugs in the
     * proxy class generation code) there was some other
     * invalid aspect of the arguments supplied to the proxy
     * class creation (such as virtual machine limitations
     * exceeded).
     */
    throw new IllegalArgumentException(e.toString());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JDK 内部动态代理的逻辑，可以参考java.lang.reflect.ProxyGenerator的内部实现。
可以认为这是种另类的字节码操纵技术，这种实现方式的好处是没有太多依赖关系，但是前提是需要懂各种JVM 指令，知道怎么处理那些偏移地址等，实际门槛非常高，所以并不适合大多数的普通开发场景。&lt;/p&gt;

&lt;p&gt;Java 社区专家提供了各种从底层到更高抽象水平的字节码操作类库。JDK 内部也集成了 ASM 类库。&lt;/p&gt;

&lt;h2 id=&#34;如何利用字节码操纵技术-实现基本的动态代理逻辑&#34;&gt;如何利用字节码操纵技术，实现基本的动态代理逻辑？&lt;/h2&gt;

&lt;p&gt;对于一个普通的 Java 动态代理，其实现过程可以简化成为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提供一个基础的接口，作为被调用类型（com.mycorp.HelloImpl）和代理类之间的统一入口，如 com.mycorp.Hello。&lt;/li&gt;
&lt;li&gt;实现InvocationHandler，对代理对象方法的调用，会被分派到其 invoke 方法来真正实现动作。&lt;/li&gt;
&lt;li&gt;通过 Proxy 类，调用其 newProxyInstance 方法，生成一个实现了相应基础接口的代理类实例，可以看下面的方法签名。
&lt;code&gt;
public static Object newProxyInstance(ClassLoader loader,
Class&amp;lt;?&amp;gt;[] interfaces,
InvocationHandler h)
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用 ASM 实现的简要过程:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
cw.visit(V1_8, // 指定 Java 版本
        ACC_PUBLIC, // 说明是 public 类型
        &amp;quot;com/mycorp/HelloProxy&amp;quot;, // 指定包和类的名称
        null, // 签名，null 表示不是泛型
        &amp;quot;java/lang/Object&amp;quot;, // 指定父类
        new String[]{ &amp;quot;com/mycorp/Hello&amp;quot; }); // 指定需要实现的接口

MethodVisitor mv = cw.visitMethod(
                ACC_PUBLIC, // 声明公共方法
                &amp;quot;sayHello&amp;quot;, // 方法名称
                &amp;quot;()Ljava/lang/Object;&amp;quot;, // 描述符
                null, // 签名，null 表示不是泛型
                null); // 可能抛出的异常，如果有，则指定字符串数组
mv.visitCode();
// 省略代码逻辑实现细节
cw.visitEnd(); // 结束类字节码生成
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同的 visitX 方法提供了创建类型，创建各种方法等逻辑。ASM API，广泛的使用了Visitor模式。
按照前面的分析，字节码操作最后大都应该是生成 byte 数组，ClassWriter 提供了一个简便的方法。&lt;code&gt;cw.toByteArray();&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;除了动态代理-字节码操纵技术还有那些应用场景&#34;&gt;除了动态代理，字节码操纵技术还有那些应用场景？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;各种 Mock 框架&lt;/li&gt;
&lt;li&gt;ORM 框架&lt;/li&gt;
&lt;li&gt;IOC 容器&lt;/li&gt;
&lt;li&gt;部分 Profiler 工具，或者运行时诊断工具等&lt;/li&gt;
&lt;li&gt;生成形式化代码的工具&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;假如我们有这样一个需求-需要添加某个功能-例如对某类型资源如网络通信的消耗进行统计-重点要求是-不开启时必须是零开销-而不是低开销&#34;&gt;假如我们有这样一个需求，需要添加某个功能，例如对某类型资源如网络通信的消耗进行统计，重点要求是，不开启时必须是零开销，而不是低开销&lt;/h2&gt;

&lt;p&gt;将资源消耗的这个实例，用动态代理的方式创建这个实例动态代理对象，在动态代理的invoke中添加新的需求。
开始使用代理对象，不开启则使用原来的方法，因为动态代理是在运行时创建。所以是零消耗。&lt;/p&gt;

&lt;h2 id=&#34;设计模式应用例子&#34;&gt;设计模式应用例子&lt;/h2&gt;

&lt;p&gt;装饰模式：BufferedInputStream 经过包装，为输入流过程增加缓存，类似这种装饰器还可以多次嵌套，不断地增加不同层次的功能。
&lt;code&gt;public BufferedInputStream(InputStream in)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;构建器模式：，JDK 最新版本中 HTTP/2 Client API，下面这个创建 HttpRequest的过程就是典型的构建器模式（Builder），
通常会被实现成fluent 风格的 API，也有人叫它方法链。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HttpRequest request = HttpRequest.newBuilder(new URI(uri))
                        .header(headerAlice, valueAlice)
                        .headers(headerBob, value1Bob,
                        headerCarl, valueCarl,
                       headerBob, value2Bob)
                        .GET()
                        .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Spring&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BeanFactory和ApplicationContext应用了工厂模式。&lt;/li&gt;
&lt;li&gt;在 Bean 的创建中，Spring 也为不同 scope 定义的对象，提供了单例和原型等模式实现。&lt;/li&gt;
&lt;li&gt;AOP 领域则是使用了代理模式、装饰器模式、适配器模式等。&lt;/li&gt;
&lt;li&gt;各种事件监听器，是观察者模式的典型应用。&lt;/li&gt;
&lt;li&gt;类似 JdbcTemplate 等则是应用了模板模式。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Mybatis之面试篇</title>
      <link>https://ianeiu.github.io/2020/02/09/mybatis%E4%B9%8B%E9%9D%A2%E8%AF%95%E7%AF%87/</link>
      <pubDate>Sun, 09 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/02/09/mybatis%E4%B9%8B%E9%9D%A2%E8%AF%95%E7%AF%87/</guid>
      
        <description>

&lt;h2 id=&#34;和-的区别&#34;&gt;#{}和${}的区别？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;${}&lt;/code&gt;是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换。&lt;br /&gt;
&lt;code&gt;#{}&lt;/code&gt;是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值&lt;/p&gt;

&lt;h2 id=&#34;最佳实践中-通常一个xml映射文件-都会写一个dao接口与之对应-请问-这个dao接口的工作原理是什么-dao接口里的方法-参数不同时-方法能重载吗&#34;&gt;最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？&lt;/h2&gt;

&lt;p&gt;Dao接口的全限定名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中MappedStatement的id值；接口方法内的参数，就是传递给sql的参数。&lt;/p&gt;

&lt;p&gt;Mapper接口是没有实现类的，当调用接口方法时，全限定名+方法名作为key值，可唯一定位一个MappedStatement。&lt;/p&gt;

&lt;p&gt;Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。&lt;/p&gt;

&lt;p&gt;Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。&lt;/p&gt;

&lt;h2 id=&#34;mybatis是如何分页的&#34;&gt;mybatis是如何分页的&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;SQL带参直接分页&lt;/li&gt;
&lt;li&gt;使用拦截器分页&lt;br /&gt;
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。&lt;/li&gt;
&lt;li&gt;RowBounds分页&lt;br /&gt;
Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。数据量小时，RowBounds不失为一种好办法。但是数据量大时，实现拦截器就很有必要了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;mybatis是如何将sql执行结果封装为目标对象并返回的-都有哪些映射形式&#34;&gt;Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;使用标签，逐一定义列名和对象属性名之间的映射关系。&lt;/li&gt;
&lt;li&gt;使用sql列的别名功能，将列别名书（不区分大小写）写为对象属性名，比如TNAME AS NAME&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;mybatis是否支持延迟加载-如果支持-它的实现原理是什么&#34;&gt;Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？&lt;/h2&gt;

&lt;p&gt;Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。&lt;/p&gt;

&lt;p&gt;原理：使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。&lt;/p&gt;

&lt;h2 id=&#34;mybatis都有哪些executor执行器-它们之间的区别是什么&#34;&gt;Mybatis都有哪些Executor执行器？它们之间的区别是什么？&lt;/h2&gt;

&lt;p&gt;Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。&lt;/p&gt;

&lt;p&gt;SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。&lt;/p&gt;

&lt;p&gt;ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。&lt;/p&gt;

&lt;p&gt;BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。&lt;/p&gt;

&lt;p&gt;作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。&lt;/p&gt;

&lt;h2 id=&#34;mybatis是否可以映射enum枚举类&#34;&gt;Mybatis是否可以映射Enum枚举类&lt;/h2&gt;

&lt;p&gt;Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java开发之命名规范</title>
      <link>https://ianeiu.github.io/2020/01/15/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2020/01/15/java%E5%BC%80%E5%8F%91%E4%B9%8B%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</guid>
      
        <description>

&lt;p&gt;原文： &lt;a href = &#34;https://mp.weixin.qq.com/s/q_C9daCZTq1SR0zwkrwyag&#34; target =&#34;_blank&#34;&gt;编码5分钟，命名2小时？史上最全的Java命名规范参考！&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-java中的命名规范&#34;&gt;一、Java中的命名规范&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;类型(名)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;约束&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;项目&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;全部小写&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;多个单词用中划线分隔‘-’  spring-cloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;包&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;全部小写&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;com.alibaba.fastjson&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;类&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;单词首字母大写&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Feature,FieldDeserializer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;变量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;首字母小写多个单词组成时，除首个单词其他单词首字母都要大写&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;password, userName&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;常量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;全部大写，多个单词，用&amp;rsquo;_&amp;lsquo;分隔&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CACHEEXPIREDTIME&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同变量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;read(), getById(Long id)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;二-包命名&#34;&gt;二、包命名&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;前缀&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;indi或onem&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;indi.发起者名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;个体项目&lt;br/&gt;个人发起，但非自己独自完成&lt;br/&gt;可公开或私有项目，copyright主要属于发起者。&lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pers&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pers.个人名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;个人项目&lt;br/&gt;指个人发起，独自完成，&lt;br/&gt;可分享的项目,copyright主要属于个人&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;priv&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;priv.个人名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;私有项目，指个人发起，独自完成&lt;br/&gt;非公开的私人使用的项目，copyright属于个人。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;team&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;team.团队名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;团队项目，指由团队发起&lt;br/&gt;并由该团队开发的项目,copyright属于该团队所有&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;顶级域名&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;com.公司名.项目名.模块名.……&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;公司项目，copyright由项目发起的公司所有&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;三-类命名&#34;&gt;三、类命名&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;属性&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;约束&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;抽象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Abstract 或 Base 开头&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BaseUserService&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;枚举&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Enum 作为后缀&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OSType&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;工具&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Utils作为后缀&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;StringUtils&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Exception结尾&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;RuntimeException&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;接口实现&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;接口名+ Impl&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;UserServiceImpl&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;领域模型相&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/DO/DTO/VO/DAO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;正例：UserDAO 反例：UserDao&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;设计模式相关&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Builder，Factory等&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当使用到设计模式时要使用对应的设计模式作为后缀，如ThreadFactory&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;处理特定功能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Handler，Predicate，Validator&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;表示处理器，校验器，断言&lt;br/&gt;这些类工厂还有配套的方法名，如handle，predicate，validate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;测试&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Test后缀&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;UserServiceTest，表示用来测试UserService类的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;MVC分层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Controller，Service，ServiceImpl，DAO后缀&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;UserManageController，UserManageDAO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;四-方法&#34;&gt;四、方法&lt;/h2&gt;

&lt;p&gt;注：pre- prefix前缀，suf- suffix后缀，alo-alone 单独使用&lt;/p&gt;

&lt;h4 id=&#34;4-1-返回真伪值的方法-pre&#34;&gt;4.1 返回真伪值的方法（pre）&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;is&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对象是否符合期待的状态&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;isValid&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;can&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对象能否执行所期待的动作&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;canRemove&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;should&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;调用方执行某个命令或方法是好还是不好、应不应该，&lt;br/&gt;或者说推荐还是不推荐&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;shouldMigrate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;has&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对象是否持有所期待的数据和属性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;hasObservers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;needs&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;调用方是否需要执行某个命令或方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;needsMigrate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-2-用来检查的方法&#34;&gt;4.2 用来检查的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ensure&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;检查是否为期待的状态，不是则抛出异常或返回error code&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ensureCapacity&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;validate&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;检查是否为正确的状态，不是则抛出异常或返回error code&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;validateInputs&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-3-按需求才执行的方法&#34;&gt;4.3 按需求才执行的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;位置&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;IfNeeded&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要的时候执行，不需要则什么都不做&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;drawIfNeeded&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;might&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;mightCreate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;try&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;尝试执行，失败时抛出异常，或是返回errorcode&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;tryCreate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OrDefault&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;尝试执行，失败时返回默认值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;getOrDefault&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OrElse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;尝试执行，失败时返回，实际参数中指定的值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;getOrElse&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;force&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;强制尝试执行，error抛出异常或是返回值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;forceCreate, forceStop&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-4-异步相关方法&#34;&gt;4.4 异步相关方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;位置&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;blocking&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;线程阻塞方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;blockingGetUser&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;InBackground&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;执行在后台线程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;doInBackground&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Async&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;异步方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sendAsync&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;suf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sync&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同步方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sendSync&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;schedule&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Job和Task放入队列&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;schedule, scheduleJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;post&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;postJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;execute&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;执行异步或同步方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;execute,executeTask&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;start&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;star,startJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;cancel&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;停止异步方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;cancel,cancelJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre/alo&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;stop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;stop,stopJob&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-5-回调方法&#34;&gt;4.5 回调方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;位置&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;on&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事件发生时执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;onCompleted&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;before&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事件发生前执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;beforeUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;preUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;will&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;willUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;after&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事件发生后执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;afterUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;post&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;postUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;did&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;didUpdate&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pre&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;should&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;确认事件是否可以执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;shouldUpdate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-6-操作对象生命周期的方法&#34;&gt;4.6 操作对象生命周期的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;initialize&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;初始化或延迟初始化使用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;initialize&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pause&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;暂停&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;onPause,pause&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;stop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;停止&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;onStop,stop&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;abandon&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;销毁的替代&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;abandon&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;destroy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;destroy&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dispose&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dispose&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-7-与集合操作相关的方法&#34;&gt;4.7 与集合操作相关的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;contains&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是包含指定对象相同的对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;contains&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;add&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;addJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;append&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;appendJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;insert&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;插入到下标n&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;insertJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;put&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加与key对应的元素&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;putJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;remove&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;移除元素&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;removeJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;enqueue&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加到队列的最末位&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;enqueueJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dequeue&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从队列中头部取出并移除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dequeueJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;push&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;添加到栈头&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pushJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从栈头取出并移除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;popJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;peek&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从栈头取出但不移除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;peekJob&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;find&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;寻找符合条件的某物&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;findById&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-8-与数据相关的方法&#34;&gt;4.8 与数据相关的方法&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;create&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;新创建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;createAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;new&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;新创建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;newAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;from&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;从既有的某物新建或是从其他的数据新建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;fromConfig&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;to&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;转换&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;toString&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;update&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;更新既有某物&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;updateAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;load&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;读取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;loadAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;fetch&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;远程读取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;fetchAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;delete&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;deleteAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;remove&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;删除&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;removeAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;save&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;saveAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;store&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;storeAccount&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;commit&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;commitChange&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;apply&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保存或应用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;applyChange&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;clear&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;清除或是恢复到初始状态&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;clearAll&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;reset&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;清除或是恢复到初始状态&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;resetAll&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;4-9-成对出现的动词&#34;&gt;4.9 成对出现的动词&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;单词/意义&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;单词/意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;get获取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;set 设置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;add 增加&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;remove 删除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;create 创建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;destory 移除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;start 启动&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;stop 停止&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;open 打开&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;close 关闭&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;read 读取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;write 写入&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;load 载入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;save 保存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;create 创建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;destroy 销毁&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;begin 开始&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;end 结束&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;backup 备份&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;restore 恢复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;import 导入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;export 导出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;split 分割&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;merge 合并&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;inject 注入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;extract 提取&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;attach 附着&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;detach 脱离&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;bind 绑定&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;separate 分离&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;view 查看&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;browse 浏览&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;edit 编辑&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;modify 修改&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;select 选取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;mark 标记&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;copy 复制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;paste 粘贴&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;undo 撤销&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;redo 重做&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;insert 插入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;delete 移除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;add 加入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;append 添加&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;clean 清理&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;clear 清除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;index 索引&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sort 排序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;find 查找&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search 搜索&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;increase 增加&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;decrease 减少&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;play 播放&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pause 暂停&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;launch 启动&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;run 运行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;compile 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;execute 执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;debug 调试&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;trace 跟踪&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;observe 观察&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;listen 监听&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;build 构建&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;publish 发布&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;input 输入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;output 输出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;encode 编码&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;decode 解码&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;encrypt 加密&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;decrypt 解密&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;compress 压缩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;decompress 解压缩&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pack 打包&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;unpack 解包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;parse 解析&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;emit 生成&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;connect 连接&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;disconnect 断开&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;send 发送&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;receive 接收&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;download 下载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;upload 上传&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;refresh 刷新&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;synchronize 同步&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;update 更新&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;revert 复原&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;lock 锁定&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;unlock 解锁&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;check out 签出&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;check in 签入&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;submit 提交&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;commit 交付&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;push 推&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pull 拉&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;expand 展开&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;collapse 折叠&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;begin 起始&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;end 结束&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;start 开始&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;finish 完成&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;enter 进入&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;exit 退出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;abort 放弃&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;quit 离开&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;obsolete 废弃&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;depreciate 废旧&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;collect 收集&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;aggregate 聚集&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;五-变量-常量命名&#34;&gt;五，变量&amp;amp;常量命名&lt;/h2&gt;

&lt;h4 id=&#34;5-1-变量命名&#34;&gt;5.1 变量命名&lt;/h4&gt;

&lt;p&gt;变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 computedValues，index、变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。&lt;/p&gt;

&lt;p&gt;变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo中的布尔变量，都不要加is(数据库中的布尔字段全都要加 is_ 前缀)。&lt;/p&gt;

&lt;h4 id=&#34;5-2-常量命名&#34;&gt;5.2 常量命名&lt;/h4&gt;

&lt;p&gt;常量命名CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。那么什么是常量呢？&lt;/p&gt;

&lt;p&gt;常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，全局常量（public static final修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。&lt;/p&gt;

&lt;p&gt;常量一般都有自己的业务含义,不要害怕长度过长而进行省略或者缩写。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。&lt;/p&gt;

&lt;h4 id=&#34;通用命名规则&#34;&gt;通用命名规则&lt;/h4&gt;

&lt;p&gt;尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。正例：BeiJing， HangZhou 反例：validateCanShu&lt;/p&gt;

&lt;p&gt;命名过程中尽量不要出现特殊的字符，常量除外。&lt;/p&gt;

&lt;p&gt;尽量不要和jdk或者框架中已存在的类重名，也不能使用java中的关键字命名。&lt;/p&gt;

&lt;p&gt;妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。&lt;/p&gt;

&lt;h4 id=&#34;六-代码注解&#34;&gt;六，代码注解&lt;/h4&gt;

&lt;h4 id=&#34;6-1-注解的原则&#34;&gt;6.1 注解的原则&lt;/h4&gt;

&lt;p&gt;好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。&lt;/p&gt;

&lt;p&gt;优雅的注解通常要满足三要素。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nothing is strange 没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。&lt;/li&gt;
&lt;li&gt;Less is more 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。
&lt;code&gt;
// 根据id获取信息【废话注解】
getMessageById(id)
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Advance with the time 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;6-2-注解格式&#34;&gt;6.2 注解格式&lt;/h4&gt;

&lt;p&gt;注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。&lt;/p&gt;

&lt;p&gt;javadoc注解可以生成JavaAPI为外部用户提供有效的支持javadoc注解通常在使用IDEA或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。&lt;/p&gt;

&lt;p&gt;a. 包注解&lt;br /&gt;
包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 落地也质量检测
 * 1. 用来解决什么问题
 * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等; 模拟不同的网络：2G，3G，4G，wifi等
 *
 * 2. 如何实现
 * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络，OS参数，获取到浏览器返回结果。
 *
 * 注意：网络环境配置信息{@link cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum}目前使用是常规速度，可以根据实际情况进行调整
 *
 * @author cruder
 * @time 2019/12/7 20:3 下午
 */
package.cn.mycookies.landingpagecheck;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b. 类注接&lt;br /&gt;
javadoc注解中，每个类都必须有注解。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* Copyright (C), 2019-2020, Jann  balabala...
*
* 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....
*
* @author   类创建者姓名 保持对齐
* @date     创建日期 保持对齐
* @version  版本号 保持对齐
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c. 属性注解&lt;br /&gt;
在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** 提示信息 */
private String userName;
/**
 * 密码
 */
private String password;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;d. 方法注释&lt;br /&gt;
在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
  * 方法的详细说明，能干嘛，怎么实现的，注意事项...
  *
  * @param xxx      参数1的使用说明， 能否为null
  * @return 返回结果的说明， 不同情况下会返回怎样的结果
  * @throws 异常类型   注明从此类方法中抛出异常的说明
  */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;e. 构造方法注释&lt;br /&gt;
在每个构造方法前面必须加上注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
  * 构造方法的详细说明
  *
  * @param xxx      参数1的使用说明， 能否为null
  * @throws 异常类型   注明从此类方法中抛出异常的说明
  */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而简单注解往往是需要工程师字节定义，在使用注解时应该注意一下几点：&lt;/p&gt;

&lt;p&gt;枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。&lt;/p&gt;

&lt;p&gt;保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用1个空格分隔。&lt;/p&gt;

&lt;p&gt;对于不同的逻辑说明，可以用空行分隔&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;无论是命名和注解，他们的目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优秀的代码往往能够见名知意，注解往往是对命名的补充和完善。命名太南了！&lt;/p&gt;

&lt;p&gt;参考文献：&lt;br /&gt;
《码出高效》&lt;br /&gt;
&lt;code&gt;https://www.cnblogs.com/wangcp-2014/p/10215620.html&lt;/code&gt;
&lt;code&gt;https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6&lt;/code&gt;
&lt;code&gt;https://google.github.io/styleguide/javaguide.html#s2.1-file-name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;原文： &lt;a href = &#34;https://mp.weixin.qq.com/s/q_C9daCZTq1SR0zwkrwyag&#34; target =&#34;_blank&#34;&gt;编码5分钟，命名2小时？史上最全的Java命名规范参考！&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Mybatis之XML篇</title>
      <link>https://ianeiu.github.io/2019/12/31/mybatis%E4%B9%8Bxml%E7%AF%87/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2019/12/31/mybatis%E4%B9%8Bxml%E7%AF%87/</guid>
      
        <description>

&lt;p&gt;Mybatis xml映射文件中，除了常见的select、insert、updae、delete标签之外
还有动态sql标签 trim、 where、set、foreach、if、choose、when、otherwise、bind等&lt;/p&gt;

&lt;h3 id=&#34;where标签&#34;&gt;where标签&lt;/h3&gt;

&lt;p&gt;反例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT
module_code, oper_type, oper_content, data_id, oper_by, oper_name, oper_dt, INET_NTOA(oper_ip) as oper_ip
FROM tb_operation_log l WHERE 1=1
&amp;lt;if test=&amp;quot;param.moduleCode != null&amp;quot;&amp;gt;
    AND l.module_code = #{param.moduleCode}
&amp;lt;/if&amp;gt;
&amp;lt;if test=&amp;quot;param.operBy != null and param.operBy !=&#39;&#39;&amp;quot;&amp;gt;
    AND l.oper_by = #{param.operBy}
&amp;lt;/if&amp;gt;
&amp;lt;if test=&amp;quot;param.operName != null and param.operName !=&#39;&#39;&amp;quot;&amp;gt;
    AND l.oper_name LIKE CONCAT(&amp;quot;%&amp;quot;,#{param.operName},&amp;quot;%&amp;quot;)
&amp;lt;/if&amp;gt;
&amp;lt;if test=&amp;quot;param.operDtStart != null and param.operDtEnd != null&amp;quot;&amp;gt;
    AND l.oper_dt BETWEEN #{param.operDtStart} AND #{param.operDtEnd}
&amp;lt;/if&amp;gt;
order by l.oper_dt desc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT
module_code, oper_type, oper_content, data_id, oper_by, oper_name, oper_dt, INET_NTOA(oper_ip) as oper_ip
FROM tb_operation_log l
&amp;lt;where&amp;gt;
    &amp;lt;if test=&amp;quot;param.moduleCode != null&amp;quot;&amp;gt;
        AND l.module_code = #{param.moduleCode}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;param.operBy != null and param.operBy !=&#39;&#39;&amp;quot;&amp;gt;
        AND l.oper_by = #{param.operBy}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;param.operName != null and param.operName !=&#39;&#39;&amp;quot;&amp;gt;
        AND l.oper_name LIKE CONCAT(&amp;quot;%&amp;quot;,#{param.operName},&amp;quot;%&amp;quot;)
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;param.operDtStart != null and param.operDtEnd != null&amp;quot;&amp;gt;
        AND l.oper_dt BETWEEN #{param.operDtStart} AND #{param.operDtEnd}
    &amp;lt;/if&amp;gt;
&amp;lt;/where&amp;gt;
order by l.oper_dt desc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;foreach标签&#34;&gt;foreach标签&lt;/h3&gt;

&lt;p&gt;参数未加@Param命名，默认是list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select p.* from tb_process_btn_param p where p.param_type = 0 and p.btn_id in
&amp;lt;foreach collection=&amp;quot;list&amp;quot; item=&amp;quot;btnId&amp;quot; index=&amp;quot;index&amp;quot; open=&amp;quot;(&amp;quot; close=&amp;quot;)&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
    #{btnId}
&amp;lt;/foreach&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Spring常用注解</title>
      <link>https://ianeiu.github.io/2019/11/01/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2019/11/01/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</guid>
      
        <description>

&lt;h2 id=&#34;常用注解&#34;&gt;常用注解&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;注解&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Component&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;泛指组件，类似在xml中配置bean &lt;bean id=&#34;beanId&#34; class=&#34;包名.类名&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Configuration&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;把类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Repository&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于标注数据访问组件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Service&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于标注业务层组件,默认bean的id为类名且首字母小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Controller&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于标注控制层组件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@RestController&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;spring4.0之后，@controller和@responsebody的结合&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Scope&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作用域 表示将Action的范围声明为原型，可以利用容器的scope=&amp;ldquo;prototype&amp;rdquo;来保证每一个请求有一个单独的Action来处理，避免struts中Action的线程安全问题。spring默认scope是单例模式(scope=&amp;ldquo;singleton&amp;rdquo;)，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2是要求每次次访问都对应不同的Action，scope=&amp;ldquo;prototype&amp;rdquo;可以保证当有请求的时候都创建一个Action对象。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Lazy(true)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;延迟初始化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@RequestMapping&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。value：指定请求的实际地址；method：指定请求的method类型，GET、POST、PUT、DELETE等（Spring4.3中引进了｛@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping｝，来帮助简化常用的HTTP方法的映射）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@ResponseBody&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，效果等同于通过response对象输出指定格式的数据 效果等同于如下代码：@RequestMapping(&amp;ldquo;/login&amp;rdquo;)   public void login(User user, HttpServletResponse response){  response.getWriter.write(JSONObject.fromObject(user).toString());  }&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@PostConstruct&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;初始化注解,用于指定初始化方法（用在方法上）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@PreDestory&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于指定销毁方法（用在方法上）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@DependsOn&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;定义Bean初始化及销毁时的顺序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Primary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Autowired&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Resource&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认按名称装配,当找不到与名称匹配的bean才会按类型装配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@Async&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;异步方法调用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@RequestParam&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;接收参数,从request里面拿取值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@PathVariable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;接收参数,从一个URI模板里面来填充&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@PathParam&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@QueryParam&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;JAX-RS 提供的，和Spring的RequestParam作用一致&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@RequestBody&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;一般是post请求的时候才会使用这个请求(处理application/json、application/xml等格式的数据)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;属性注入&#34;&gt;属性注入&lt;/h2&gt;

&lt;h3 id=&#34;autowired&#34;&gt;@Autowired&lt;/h3&gt;

&lt;p&gt;自动装配，可消除代码里的getter/setter与bean属性中的property&lt;/p&gt;

&lt;p&gt;如果不使用注解自动注入，必须通过代码手动注入,如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot; /&amp;gt;
    &amp;lt;property name=&amp;quot;student&amp;quot; ref=&amp;quot;student&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;xxx.Student&amp;quot; /&amp;gt;
...

@Test
public void test(){
    //读取配置文件
    ApplicationContext ctx=new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);
    User user=(User) ctx.getBean(&amp;quot;user&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而使用注解@Autowired大大减少了代码量，提高可读性。&lt;br /&gt;
使用前配置文件要添加扫描器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;context:component-scan base-package=&amp;quot;xxx.vo&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;xxx.Student&amp;quot; /&amp;gt;
...

class User{
    @Autowired
    private Student student;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当xml配置了user的属性时，Spring会按照xml优先的原则去User.java中寻找这两个属性的getter/setter，导致的结果就是初始化bean报错&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&amp;quot;xxx.vo&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;student&amp;quot; ref=&amp;quot;student&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;xxx.Student&amp;quot; /&amp;gt;

class User{
    @Autowired
    private Student student;
    //无getter/setter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当xml未配置了student的bean时会抛出找不到bean的异常，可将@Autowired注解的required设置为false，默认student为null&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&amp;quot;xxx.vo&amp;quot; /&amp;gt;
&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;xxx.User&amp;quot; /&amp;gt;

class User{
    @Autowired(required=false)
    private Student student;
    //无getter/setter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;qualifier&#34;&gt;Qualifier&lt;/h3&gt;

&lt;p&gt;指定注入Bean的名称&lt;/p&gt;

&lt;h3 id=&#34;resource&#34;&gt;@Resource&lt;/h3&gt;

&lt;p&gt;@Resource注解与@Autowired注解作用相似&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class User{
    @Resource(name=&amp;quot;student&amp;quot;)
    private Student student;

    //@Resource(type=&amp;quot;Student.class&amp;quot;)
    //private Student student;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@Resource的装配顺序：
(1)、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配
(2)、指定了name或者type则根据指定的类型去匹配bean，任何一个不匹配都将报错&lt;/p&gt;

&lt;p&gt;@Autowired和@Resource两个注解的区别：
(1)、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配
(2)、@Autowired是Spring的注解，@Resource是J2EE的注解&lt;/p&gt;

&lt;h3 id=&#34;value&#34;&gt;@Value&lt;/h3&gt;

&lt;p&gt;基本数值的填充 :@Value(&amp;ldquo;&amp;rdquo;)&lt;br /&gt;
常用于获取配置文件参数值 ${配置文件中参数名}&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;直接new对象是无法获取参数值的，必须通过springIOC&lt;/p&gt;

&lt;p&gt;@Value注入static属性的两种方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1.通过执行set方法进行参数注入
private static String userName;
@Value(&amp;quot;${git.userName}&amp;quot;)
public void setUserName(String userName) {
    GitUtils.userName = userName;
}

//2.通过中间变量赋值
private static String userName; 
@Value(&amp;quot;${git.userName}&amp;quot;)
private String userNameTmp;
@PostConstruct
public void init() {
    userName = userNameTmp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;接收参数&#34;&gt;接收参数&lt;/h2&gt;

&lt;h3 id=&#34;requestparam&#34;&gt;@RequestParam&lt;/h3&gt;

&lt;p&gt;处理Content-Type为 application/x-www-form-urlencoded编码的内容&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20&#34;&gt;http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20&lt;/a&gt;&lt;br /&gt;
根据上面的这个URL，你可以用这样的方式来进行获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String getDetails(
    @RequestParam(value=&amp;quot;param1&amp;quot;, required=true) String param1,
    @RequestParam(value=&amp;quot;param2&amp;quot;, required=false) String param2){
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@RequestParam 支持下面四种参数
    defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值
    name 绑定本次参数的名称，要跟URL上面的一样
    required 这个参数是不是必须的
    value 跟name一样的作用，是name属性的一个别名&lt;/p&gt;

&lt;h3 id=&#34;pathvariable&#34;&gt;@PathVariable&lt;/h3&gt;

&lt;p&gt;这个注解能够识别URL里面的一个模板，我们看下面的一个URL
&lt;a href=&#34;http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20&#34;&gt;http://localhost:8080/springmvc/hello/101?param1=10&amp;amp;param2=20&lt;/a&gt;
上面的一个url你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String getDetails(
    @RequestMapping(&amp;quot;/hello/{id}&amp;quot;)
    public String getDetails(@PathVariable(value=&amp;quot;id&amp;quot;) String id,
    @RequestParam(value=&amp;quot;param1&amp;quot;, required=true) String param1,
    @RequestParam(value=&amp;quot;param2&amp;quot;, required=false) String param2){
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;requestbody&#34;&gt;@RequestBody&lt;/h3&gt;

&lt;p&gt;@RequestBody用于post请求，处理 application/json、application/xml等格式的数据&lt;/p&gt;

&lt;h3 id=&#34;modelattribute&#34;&gt;@ModelAttribute&lt;/h3&gt;

&lt;p&gt;@ModelAttribute注解类型将参数绑定到Model对象，处理 multipart/form-data 格式的数据&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JVM之volatile关键字</title>
      <link>https://ianeiu.github.io/2019/07/25/jvm%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2019/07/25/jvm%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      
        <description>

&lt;h2 id=&#34;引入&#34;&gt;引入&lt;/h2&gt;

&lt;p&gt;Java内存模型简称JMM（Java Memory Model），是Java虚拟机所定义的一种抽象规范，
用来屏蔽不同硬件和操作系统的内存访问差异，让java程序在各种平台下都能达到一致的内存访问效果。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;主内存（Main Memory）&lt;br /&gt;
主内存可以简单理解为计算机当中的内存，但又不完全等同。&lt;br /&gt;
主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;工作内存（Working Memory）&lt;br /&gt;
工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。&lt;br /&gt;
每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。&lt;br /&gt;
线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。&lt;br /&gt;
不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于一个静态变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int s = 0；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程A执行如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = 3；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过一系列内存读写的操作指令，线程A把静态变量 s=0 从主内存读到工作内存，再把 s=3 的更新结果同步到主内存当中。&lt;/p&gt;

&lt;p&gt;从单线程的角度来看，这个过程没有任何问题。这时候我们引入线程B，执行如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(&amp;quot;s=&amp;quot; + s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有可能输出 0 或 3&lt;/p&gt;

&lt;p&gt;可以使用synchronized同步锁（影响性能）或者使用volatile关键字修饰（轻量）&lt;/p&gt;

&lt;h2 id=&#34;volatile-之-可见性&#34;&gt;volatile 之 可见性&lt;/h2&gt;

&lt;p&gt;volatile关键字具有许多特性，其中最重要的特性就是保证了用volatile修饰的变量对所有线程的可见性[当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值]。&lt;/p&gt;

&lt;p&gt;但volatile不能保证变量的原子性即无法保证线程安全。&lt;/p&gt;

&lt;h4 id=&#34;什么时候适合用&#34;&gt;什么时候适合用&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class VolatileTest {
    public volatile static int count = 0;
    
    public static void main(String[] args) {
        //开启 10个线程
        for (int i = 0; i &amp;lt; 10; i++) {
            new Thread(
                    new Runnable() {
                        public void run() {
                            try {
                                Thread.sleep(1);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            //每个线程当中让count值自增 100次
                            for (int j = 0; j &amp;lt; 100; j++) {
                                count++;
                            }
                        }
                    }
            ).start();
        }
        try {
            Thread.Weep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System, out.print(&amp;quot;count&amp;quot; + count);
        //最终count的结果值未必是1000，有可能小于1000。
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量不需要与其他的状态变量共同参与不变约束。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;volatile static int start = 3;
volatile static int end = 6;
    
线程A执行如下代码：
while (start &amp;lt; end){
  //do something
}
    
线程B执行如下代码：
start+=3;
end+=3;
    
//这种情况下，一旦在线程A的循环中执行了线程B，start有可能先更新成6，
//造成了一瞬间 start == end，从而跳出while循环的可能性。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;volatile-之-阻止指令重排&#34;&gt;volatile 之  阻止指令重排&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton2 {
    private static Singleton2 instance;

    public static Singleton2 getInstance() {
    	//双重检测机制
        if (instance == null) {
        	//同步锁
            synchronized (Singleton2.class) {
            	//双重检测机制
                if (instance == null) {
                    instance = new Singleton2();
                }
            }
        }
        return instance;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;已上代码存在问题，可能会得到一个没有初始化完成的对象&lt;/p&gt;

&lt;p&gt;JVM编译器的指令重排，可能会得到一个没有初始化的对象&lt;/p&gt;

&lt;p&gt;java中简单的一句 &lt;code&gt;instance = new Singleton&lt;/code&gt;，会被编译器编译成如下JVM指令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;memory =allocate();    //1：分配对象的内存空间 
ctorInstance(memory);  //2：初始化对象 
instance =memory;     //3：设置instance指向刚分配的内存地址 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;memory =allocate();    //1：分配对象的内存空间 
instance =memory;     //3：设置instance指向刚分配的内存地址 
ctorInstance(memory);  //2：初始化对象 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当线程A执行完1,3,时，instance对象还未完成初始化，但已经不再指向null。&lt;br /&gt;
此时如果线程B抢占到CPU资源，执行  if（instance == null）的结果会是false，从而返回一个没有初始化完成的instance对象。&lt;/p&gt;

&lt;p&gt;如何避免这一情况呢？我们需要在instance对象前面增加一个修饰符volatile。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>redis笔记</title>
      <link>https://ianeiu.github.io/2019/07/25/redis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2019/07/25/redis%E7%AC%94%E8%AE%B0/</guid>
      
        <description>

&lt;h2 id=&#34;redis&#34;&gt;redis&lt;/h2&gt;

&lt;p&gt;Redis本质上是一个Key-Value类型的内存数据库，支持保存多种数据结构，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。&lt;br /&gt;
因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。&lt;/p&gt;

&lt;p&gt;Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。&lt;/p&gt;

&lt;h2 id=&#34;redis的数据类型-以及每种数据类型的使用场景&#34;&gt;redis的数据类型，以及每种数据类型的使用场景&lt;/h2&gt;

&lt;p&gt;(一)String&lt;br /&gt;
这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。&lt;/p&gt;

&lt;p&gt;(二)hash&lt;br /&gt;
这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。&lt;/p&gt;

&lt;p&gt;(三)list&lt;br /&gt;
使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。&lt;/p&gt;

&lt;p&gt;(四)set&lt;br /&gt;
因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。&lt;/p&gt;

&lt;p&gt;(五)sorted set&lt;br /&gt;
sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。还可以用来做延时任务(&lt;a href=&#34;https://www.cnblogs.com/rjzheng/p/8972725.html&#34; target=&#34;_blank&#34;&gt;分布式之延时任务方案解析&lt;/a&gt;)、范围查找。&lt;/p&gt;

&lt;h2 id=&#34;项目中使用redis&#34;&gt;项目中使用redis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;响应请求获取数据时经过redis查询（如果没有则访问数据库，并将数据存储至redis），达到极速响应；&lt;/li&gt;
&lt;li&gt;高并发的情况，可能减少数据库压力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;redis单线程工作模型优势&#34;&gt;redis单线程工作模型优势&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;纯内存操作&lt;/li&gt;
&lt;li&gt;单线程操作，避免了频繁的上下文切换&lt;/li&gt;
&lt;li&gt;采用了非阻塞I/O多路复用机制（单个线程，跟踪每个I/O流的状态，来管理多个I/O流。）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;使用redis存在的问题&#34;&gt;使用redis存在的问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;缓存和数据库双写一致性问题&lt;/li&gt;
&lt;li&gt;缓存雪崩问题&lt;/li&gt;
&lt;li&gt;缓存击穿问题&lt;/li&gt;
&lt;li&gt;缓存的并发竞争问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;redis的过期策略以及内存淘汰机制&#34;&gt;redis的过期策略以及内存淘汰机制&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;为什么不用定时删除策略?&lt;br /&gt;
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.&lt;/li&gt;
&lt;li&gt;定期删除+惰性删除是如何工作的呢?&lt;br /&gt;
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。&lt;/li&gt;
&lt;li&gt;采用定期删除+惰性删除就没其他问题了么?&lt;br /&gt;
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在redis.conf中有一行配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# maxmemory-policy volatile-lru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。
3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。
4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐
5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐
6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用redis实现分布式锁&#34;&gt;使用Redis实现分布式锁&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//伪代码
//当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；
//当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败。
if（setnx（key，1） == 1）{
    //设置锁超时
    expire（key，30）
    try {
        do something ......
    } finally {
        //解锁
        del（key）
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的伪代码中，存在着三个致命问题：
1. setnx和expire的非原子性&lt;br /&gt;
设想一个极端场景，当线程A执行setnx，成功得到了锁，setnx刚执行成功，还未来得及执行expire指令，节点1（线程A）挂掉了。&lt;br /&gt;
这样一来，这把锁就没有设置过期时间，变得“长生不老”，别的线程再也无法获得锁了。&lt;br /&gt;
解决方法：使用set（key，1，30，NX）取代 setnx&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;del 导致误删&lt;br /&gt;
又是一个极端场景，假如某线程成功得到了锁，并且设置的超时时间是30秒。&lt;br /&gt;
如果某些原因导致线程A执行的很慢很慢，过了30秒都没执行完，这时候锁过期自动释放，线程B得到了锁。&lt;br /&gt;
随后，线程A执行完了任务，线程A接着执行del指令来释放锁。&lt;br /&gt;
但这时候线程B还没执行完，线程A实际上删除的是线程B加的锁。&lt;br /&gt;
解决方法：可以在加锁的时候把当前的线程ID当做value，并在删除之前验证key对应的value是不是自己线程的ID。&lt;br /&gt;
&lt;code&gt;
String threadId = Thread.currentThread().getId()
set（key，threadId ，30，NX）
//解锁
if（threadId .equals(redisClient.get(key))）{
    del(key)
}
&lt;/code&gt;
但是，这样做又隐含了一个新的问题，判断和释放锁是两个独立操作，不是原子性。
使用用Lua脚本来实现：
&lt;code&gt;
String luaScript = &amp;quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&amp;quot;;
redisClient.eval(luaScript , Collections.singletonList(key), Collections.singletonList(threadId));
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;出现并发的可能性
还是刚才第二点所描述的场景，虽然我们避免了线程A误删掉key的情况，但是同一时间有A，B两个线程在访问代码块，仍然是不完美的。&lt;br /&gt;
我们可以让获得锁的线程开启一个守护线程，用来给快要过期的锁“续航”。&lt;br /&gt;
当过去了29秒，线程A还没执行完，这时候守护线程会执行expire指令，为这把锁“续命”20秒。&lt;br /&gt;
守护线程从第29秒开始执行，每20秒执行一次。&lt;br /&gt;
当线程A执行完任务，会显式关掉守护线程。&lt;br /&gt;
另一种情况，如果节点1 忽然断电，由于线程A和守护线程在同一个进程，守护线程也会停下。&lt;br /&gt;
这把锁到了超时的时候，没人给它续命，也就自动释放了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;ref&#34;&gt;REF&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/rjzheng/p/9096228.html&#34; target=&#34;_blank&#34;&gt;分布式之redis复习精讲&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.cnblogs.com/Survivalist/p/10321476.html&#34; target=&#34;_blank&#34;&gt;Redis的那些最常见面试问题&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://mp.weixin.qq.com/s/8fdBKAyHZrfHmSajXT_dnA&#34; target=&#34;_blank&#34;&gt;什么是分布式锁？&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Eclipse笔记</title>
      <link>https://ianeiu.github.io/2019/07/15/eclipse%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/2019/07/15/eclipse%E7%AC%94%E8%AE%B0/</guid>
      
        <description>

&lt;h2 id=&#34;快捷键&#34;&gt;快捷键&lt;/h2&gt;

&lt;h4 id=&#34;使用频率极高的快捷键&#34;&gt;使用频率极高的快捷键&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;DESC&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;代码提示&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;alt+/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;自动生成object方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;alt + shift + s，然后根据提示继续&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;复制当前行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl +alt + ↓&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;查找文本&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + k ,ctrl + shfit + k&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;如何跳转到文件中的特定行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + l&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;调出搜索文本的视图&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + f&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;进行全局搜索和局部搜索&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + h&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;文件&#34;&gt;文件&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;DESC&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;创建各种类型的文件&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + n&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;关闭当前文件&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + w&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;关闭所有文件&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + shift + w&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;打开文件所在目录&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;alt + shift + w，选择system explorer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;类&#34;&gt;类&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;DESC&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;显示出当前打开的所有文件&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + e&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;文件切换&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + pg、up ,ctrl + pg、dn&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;视图切换&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + f7  跳转到代码编辑器视图 f12&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;经典的quick access&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + 3  搜maven、server&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;eclipse的面包屑功能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;alt + shift + b （右键面包屑有关闭按钮）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;文本&#34;&gt;文本&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;DESC&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;KEY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;删除当前行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;查看字符串出现的地方&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + shift + u&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;显示html和xml元素的所有属性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ctrl + shift + ,&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;大小写转换&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;变小写ctrl + shift + y,变大写ctrl +shift + x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;重构-修改名字&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;alt + shift + r 统一修改方法的参数名字、或者类变量、方法变量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;重构-抽取类方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;选中代码，然后使用alt + shift + m,就会弹出抽取视图&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;eclipse-插件&#34;&gt;Eclipse-插件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Team

&lt;ul&gt;
&lt;li&gt;Subclipse&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Theme

&lt;ul&gt;
&lt;li&gt;Eclipse Color Theme&lt;/li&gt;
&lt;li&gt;Darkest Dark Theme with DevStyle&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;反编译

&lt;ul&gt;
&lt;li&gt;Enhanced Class Decompiler&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UML

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ianeiu.github.io/resouce/IDE-PLUGN/AmaterasUML_1.3.4.zip&#34; target=&#34;blank&#34;&gt;AmaterasUML_1.3.4.zip&lt;/a&gt;解压放入plugins目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;lombok&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;方式1&lt;br /&gt;
将&lt;a href=&#34;https://ianeiu.github.io/resouce/IDE-PLUGN/lombok.jar&#34; target=&#34;blank&#34;&gt;lombok.jar&lt;/a&gt;文件，放到eclipse安装路径，该jar包也就是lombok插件的jar文件了&lt;br /&gt;
打开eclipse.ini文件，添加如下内容：&lt;br /&gt;
-javaagent:lombok.jar&lt;br /&gt;
-Xbootclasspath/a:lombok.jar&lt;/li&gt;
&lt;li&gt;方式2(推荐)&lt;br /&gt;
&lt;a href=&#34;https://blog.csdn.net/dorothy1224/article/details/79280591/&#34; target=&#34;blank&#34;&gt;eclipse安装lombok&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;修改tomcat设置内存大小&#34;&gt;修改tomcat设置内存大小&lt;/h2&gt;

&lt;p&gt;方式1（推荐）：&lt;br /&gt;
在Eclipse中下面Servers双击Tomcat Server&amp;hellip; 然后点击General InformAtion 下的Open launch configuration；&lt;br /&gt;
会弹出Edit Configuration，然后在选中Arguments选项卡；在VM arguments文本框中最后面添加
-Xms256m -Xmx1024m -XX:MaxPermSize=256m 。&lt;/p&gt;

&lt;p&gt;方式2：&lt;br /&gt;
在Eclipse菜单栏中Window ——》Preferences ——》Server ———》 Runtime Environment；&lt;br /&gt;
选择您用的Tomcat 然后点击Edit&amp;hellip;弹出Edit Server Runtime Ecvironment 下面JRE选项后面的Installed JREs&amp;hellip;
点击弹出Installed JREs；在选中您用的Jre在点击Edit..在Defaul VM Arguments：中填入-Xms256m -Xmx512m&lt;/p&gt;

&lt;h2 id=&#34;删除某个工作空间&#34;&gt;删除某个工作空间&lt;/h2&gt;

&lt;p&gt;方式1（推荐）：&lt;br /&gt;
   打开你的Eclipse，菜单中找到：Window&amp;ndash;&amp;gt;Preferences&amp;ndash;&amp;gt;General&amp;ndash;&amp;gt;Startup and Shutdown&amp;ndash;&amp;gt;WorkSpace，
然后选中你想要删除的工作空间，点击右边的remove按钮即可。&lt;/p&gt;

&lt;p&gt;方式2：&lt;br /&gt;
   在你的Eclipse目录中找到以下文件configuration.settings\org.eclipse.ui.ide.prefs，这个就是工作空间的配置文件了。
然后将RECENT_WORKSPACES后面你想删除的工作空间删除即可。&lt;/p&gt;

&lt;h2 id=&#34;问题记录&#34;&gt;问题记录&lt;/h2&gt;

&lt;h2 id=&#34;tomcat启动报nullpointerexception&#34;&gt;tomcat启动报NullPointerException&lt;/h2&gt;

&lt;p&gt;在自己设置的workspace目录下面，打开目录：.metadata.plugins\org.eclipse.wst.server.core\ ，然后删除“temp0”文件夹即可。&lt;/p&gt;

&lt;h2 id=&#34;server视图加载项目之后项目名后边有带括号的名字&#34;&gt;Server视图加载项目之后项目名后边有带括号的名字&lt;/h2&gt;

&lt;p&gt;复制过来的项目会出现的一种情况：有时即使是项目改了名字在添加到Server上的时候在Server视图中看到项目名后边有一个带括号的名字,还是复制之前的项目名。&lt;/p&gt;

&lt;p&gt;解决：打开文件“你的工程目录.settings\org.eclipse.wst.common.component”看到内容，将里面所有为你原来工程名的字符串替换为新工程名字。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
