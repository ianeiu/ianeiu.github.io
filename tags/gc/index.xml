<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gc on 吴炜棉</title>
    <link>https://ianeiu.github.io/tags/gc/</link>
    <description>Recent content in gc on 吴炜棉</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 10 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://ianeiu.github.io/tags/gc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM笔记之引用、GC及OOM</title>
      <link>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%95%E7%94%A8gc%E5%8F%8Aoom/</link>
      <pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ianeiu.github.io/p/jvm%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%95%E7%94%A8gc%E5%8F%8Aoom/</guid>
      <description>强引用、软引用、弱引用和虚引用 强引用（Strong Reference）只有这个引用被释放之后，对象才会被释放掉。只要引用存在，垃圾回收器永远不会回收。
我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。
当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。
对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了， 具体回收时机还是要看垃圾收集策略。
软引用（Soft Reference）内存溢出之前通过代码回收的引用。 通常用来实现内存敏感的缓存（图片缓存框架中，“内存缓存”中的图片是以这种引用来保存）。
软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度； 当内存不足时，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象，自动删除这部分缓存数据，从真正的来源查询这些数据。
弱引用（Weak Reference）第二次垃圾回收时回收的引用，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。 同样可用于内存敏感的缓存（在静态内部类中，经常会使用虚引用。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏） 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。
虚引用（Phantom Reference) 又称幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例的任何属性或函数。
可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。
当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。
虚引用和软引用弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有
Java内存回收机制 不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。
Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。
在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，另一个是给对象赋予了新值，这样重新分配了内存空间。
GC算法分类  引用计数法(没有被java采⽤用) 标记清除法（通过根节点标记所有从根节点开始的可达对象，清除没标记过的对象，标记和清除两个过程效率不高，产生内存碎⽚） 标记压缩法（压缩：将所有存活对象压缩到内存的一端，清除边界外所有的空间） 复制回收算法 分代回收法（根据对象存活周期的不同将内存划分几块，一般是新生代和老年代，新⽣代基本采用复制算法，老年代采⽤用标记清除算法。  MinorGC &amp;amp; FullGC  Minor GC通常发生在新生代的Eden区，一般采用复制回收算法（对象生存期短，发生GC的频率较高，回收速度比较快）。 Full GC/Major GC 发生在老年代，所采用的是标记清除算法。  内存泄漏 内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示Out of memory。
Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：
1、静态集合类引起内存泄漏
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。
static Vector v = new Vector(10); for (int i = 1; i&amp;lt;100; i++){ Object o = new Object(); v.</description>
    </item>
    
  </channel>
</rss>
